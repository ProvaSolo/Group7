[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "access",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "R_OK",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "urandom",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argv",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "platform",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argv",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "platform",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argv",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argv",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_output",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "CalledProcessError",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_output",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "CalledProcessError",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "CalledProcessError",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_output",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "CalledProcessError",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "abc",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "abc",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Deque",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Coroutine",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Deque",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Coroutine",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "ENOENT",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "EPERM",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "ENOENT",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "EPERM",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "count",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "Handler",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "LogRecord",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "Handler",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "LogRecord",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "rmtree",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "copyfileobj",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "TemporaryDirectory",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "NamedTemporaryFile",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "NamedTemporaryFile",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "TemporaryDirectory",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "NamedTemporaryFile",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "NamedTemporaryFile",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "TemporaryDirectory",
        "importPath": "tempfile",
        "description": "tempfile",
        "isExtraImport": true,
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "Runstate",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "Runstate",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "importPath": "qemu.qmp",
        "description": "qemu.qmp",
        "isExtraImport": true,
        "detail": "qemu.qmp",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPMessage",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPReturnValue",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPBadPortError",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPMessage",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPObject",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPMessage",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPReturnValue",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPBadPortError",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPMessage",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPObject",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPMessage",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPReturnValue",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "importPath": "qemu.qmp.legacy",
        "description": "qemu.qmp.legacy",
        "isExtraImport": true,
        "detail": "qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "importPath": "asyncio",
        "description": "asyncio",
        "isExtraImport": true,
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "importPath": "asyncio",
        "description": "asyncio",
        "isExtraImport": true,
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "StreamReader",
        "importPath": "asyncio",
        "description": "asyncio",
        "isExtraImport": true,
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "StreamWriter",
        "importPath": "asyncio",
        "description": "asyncio",
        "isExtraImport": true,
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "ExitStack",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "ExitStack",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "SSLContext",
        "importPath": "ssl",
        "description": "ssl",
        "isExtraImport": true,
        "detail": "ssl",
        "documentation": {}
    },
    {
        "label": "SSLContext",
        "importPath": "ssl",
        "description": "ssl",
        "isExtraImport": true,
        "detail": "ssl",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawTextHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "RawTextHelpFormatter",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "search",
        "importPath": "re",
        "description": "re",
        "isExtraImport": true,
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "readline",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "readline",
        "description": "readline",
        "detail": "readline",
        "documentation": {}
    },
    {
        "label": "lexers",
        "importPath": "pygments",
        "description": "pygments",
        "isExtraImport": true,
        "detail": "pygments",
        "documentation": {}
    },
    {
        "label": "token",
        "importPath": "pygments",
        "description": "pygments",
        "isExtraImport": true,
        "detail": "pygments",
        "documentation": {}
    },
    {
        "label": "token",
        "importPath": "pygments",
        "description": "pygments",
        "isExtraImport": true,
        "detail": "pygments",
        "documentation": {}
    },
    {
        "label": "lexers",
        "importPath": "pygments",
        "description": "pygments",
        "isExtraImport": true,
        "detail": "pygments",
        "documentation": {}
    },
    {
        "label": "token",
        "importPath": "pygments",
        "description": "pygments",
        "isExtraImport": true,
        "detail": "pygments",
        "documentation": {}
    },
    {
        "label": "urwid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urwid",
        "description": "urwid",
        "detail": "urwid",
        "documentation": {}
    },
    {
        "label": "urwid_readline",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urwid_readline",
        "description": "urwid_readline",
        "detail": "urwid_readline",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "fuse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fuse",
        "description": "fuse",
        "detail": "fuse",
        "documentation": {}
    },
    {
        "label": "FUSE",
        "importPath": "fuse",
        "description": "fuse",
        "isExtraImport": true,
        "detail": "fuse",
        "documentation": {}
    },
    {
        "label": "FuseOSError",
        "importPath": "fuse",
        "description": "fuse",
        "isExtraImport": true,
        "detail": "fuse",
        "documentation": {}
    },
    {
        "label": "Operations",
        "importPath": "fuse",
        "description": "fuse",
        "isExtraImport": true,
        "detail": "fuse",
        "documentation": {}
    },
    {
        "label": "FUSE",
        "importPath": "fuse",
        "description": "fuse",
        "isExtraImport": true,
        "detail": "fuse",
        "documentation": {}
    },
    {
        "label": "FuseOSError",
        "importPath": "fuse",
        "description": "fuse",
        "isExtraImport": true,
        "detail": "fuse",
        "documentation": {}
    },
    {
        "label": "Operations",
        "importPath": "fuse",
        "description": "fuse",
        "isExtraImport": true,
        "detail": "fuse",
        "documentation": {}
    },
    {
        "label": "Distribution",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "EntryPoint",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "PackageNotFoundError",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "distribution",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "version",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "Distribution",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "EntryPoint",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "PackageNotFoundError",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "distribution",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "version",
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "isExtraImport": true,
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "find_spec",
        "importPath": "importlib.util",
        "description": "importlib.util",
        "isExtraImport": true,
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "find_spec",
        "importPath": "importlib.util",
        "description": "importlib.util",
        "isExtraImport": true,
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "PurePath",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "PurePath",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "venv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "venv",
        "description": "venv",
        "detail": "venv",
        "documentation": {}
    },
    {
        "label": "avocado",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "avocado",
        "description": "avocado",
        "detail": "avocado",
        "documentation": {}
    },
    {
        "label": "AsyncProtocol",
        "importPath": "qemu.qmp.protocol",
        "description": "qemu.qmp.protocol",
        "isExtraImport": true,
        "detail": "qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "StateError",
        "importPath": "qemu.qmp.protocol",
        "description": "qemu.qmp.protocol",
        "isExtraImport": true,
        "detail": "qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "AsyncProtocol",
        "importPath": "qemu.qmp.protocol",
        "description": "qemu.qmp.protocol",
        "isExtraImport": true,
        "detail": "qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "StateError",
        "importPath": "qemu.qmp.protocol",
        "description": "qemu.qmp.protocol",
        "isExtraImport": true,
        "detail": "qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "asyncio_run",
        "importPath": "qemu.qmp.util",
        "description": "qemu.qmp.util",
        "isExtraImport": true,
        "detail": "qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "create_task",
        "importPath": "qemu.qmp.util",
        "description": "qemu.qmp.util",
        "isExtraImport": true,
        "detail": "qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "asyncio_run",
        "importPath": "qemu.qmp.util",
        "description": "qemu.qmp.util",
        "isExtraImport": true,
        "detail": "qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "create_task",
        "importPath": "qemu.qmp.util",
        "description": "qemu.qmp.util",
        "isExtraImport": true,
        "detail": "qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "setuptools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools",
        "description": "setuptools",
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "bdist_egg",
        "importPath": "setuptools.command",
        "description": "setuptools.command",
        "isExtraImport": true,
        "detail": "setuptools.command",
        "documentation": {}
    },
    {
        "label": "bdist_egg",
        "importPath": "setuptools.command",
        "description": "setuptools.command",
        "isExtraImport": true,
        "detail": "setuptools.command",
        "documentation": {}
    },
    {
        "label": "pkg_resources",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pkg_resources",
        "description": "pkg_resources",
        "detail": "pkg_resources",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "FileInfo",
        "importPath": "codeconverter.patching",
        "description": "codeconverter.patching",
        "isExtraImport": true,
        "detail": "codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "match_class_dict",
        "importPath": "codeconverter.patching",
        "description": "codeconverter.patching",
        "isExtraImport": true,
        "detail": "codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileList",
        "importPath": "codeconverter.patching",
        "description": "codeconverter.patching",
        "isExtraImport": true,
        "detail": "codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileInfo",
        "importPath": "codeconverter.patching",
        "description": "codeconverter.patching",
        "isExtraImport": true,
        "detail": "codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "match_class_dict",
        "importPath": "codeconverter.patching",
        "description": "codeconverter.patching",
        "isExtraImport": true,
        "detail": "codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileList",
        "importPath": "codeconverter.patching",
        "description": "codeconverter.patching",
        "isExtraImport": true,
        "detail": "codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "codeconverter.qom_macros",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codeconverter.qom_macros",
        "description": "codeconverter.qom_macros",
        "detail": "codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TI_FIELDS",
        "importPath": "codeconverter.qom_type_info",
        "description": "codeconverter.qom_type_info",
        "isExtraImport": true,
        "detail": "codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "type_infos",
        "importPath": "codeconverter.qom_type_info",
        "description": "codeconverter.qom_type_info",
        "isExtraImport": true,
        "detail": "codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoVar",
        "importPath": "codeconverter.qom_type_info",
        "description": "codeconverter.qom_type_info",
        "isExtraImport": true,
        "detail": "codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TI_FIELDS",
        "importPath": "codeconverter.qom_type_info",
        "description": "codeconverter.qom_type_info",
        "isExtraImport": true,
        "detail": "codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "type_infos",
        "importPath": "codeconverter.qom_type_info",
        "description": "codeconverter.qom_type_info",
        "isExtraImport": true,
        "detail": "codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoVar",
        "importPath": "codeconverter.qom_type_info",
        "description": "codeconverter.qom_type_info",
        "isExtraImport": true,
        "detail": "codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "import_module",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "import_module",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "gdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gdb",
        "description": "gdb",
        "detail": "gdb",
        "documentation": {}
    },
    {
        "label": "coroutine",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "aio",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "mtree",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "coroutine",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "tcg",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "timers",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "coroutine",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "aio",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "mtree",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "coroutine",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "tcg",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "timers",
        "importPath": "qemugdb",
        "description": "qemugdb",
        "isExtraImport": true,
        "detail": "qemugdb",
        "documentation": {}
    },
    {
        "label": "simplebench",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "simplebench",
        "description": "simplebench",
        "detail": "simplebench",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "importPath": "results_to_text",
        "description": "results_to_text",
        "isExtraImport": true,
        "detail": "results_to_text",
        "documentation": {}
    },
    {
        "label": "bench_block_copy",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_file",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_nbd",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_qcow2",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "bench_block_copy",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_file",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_nbd",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "bench_block_copy",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_file",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_nbd",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_qcow2",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "bench_block_copy",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_file",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_nbd",
        "importPath": "bench_block_job",
        "description": "bench_block_job",
        "isExtraImport": true,
        "detail": "bench_block_job",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "machine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "qtest",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "importPath": "qemu.machine",
        "description": "qemu.machine",
        "isExtraImport": true,
        "detail": "qemu.machine",
        "documentation": {}
    },
    {
        "label": "Templater",
        "importPath": "table_templater",
        "description": "table_templater",
        "isExtraImport": true,
        "detail": "table_templater",
        "documentation": {}
    },
    {
        "label": "Templater",
        "importPath": "table_templater",
        "description": "table_templater",
        "isExtraImport": true,
        "detail": "table_templater",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tabulate",
        "description": "tabulate",
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "Lark",
        "importPath": "lark",
        "description": "lark",
        "isExtraImport": true,
        "detail": "lark",
        "documentation": {}
    },
    {
        "label": "Lark",
        "importPath": "lark",
        "description": "lark",
        "isExtraImport": true,
        "detail": "lark",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "read_events",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "error_write",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out_open",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "read_events",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "error_write",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "out_open",
        "importPath": "tracetool",
        "description": "tracetool",
        "isExtraImport": true,
        "detail": "tracetool",
        "documentation": {}
    },
    {
        "label": "binary",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "binary",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "binary",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "binary",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "importPath": "tracetool.backend.dtrace",
        "description": "tracetool.backend.dtrace",
        "isExtraImport": true,
        "detail": "tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "is_string",
        "importPath": "tracetool.backend.simple",
        "description": "tracetool.backend.simple",
        "isExtraImport": true,
        "detail": "tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "is_string",
        "importPath": "tracetool.backend.simple",
        "description": "tracetool.backend.simple",
        "isExtraImport": true,
        "detail": "tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "is_string",
        "importPath": "tracetool.backend.simple",
        "description": "tracetool.backend.simple",
        "isExtraImport": true,
        "detail": "tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "is_string",
        "importPath": "tracetool.backend.simple",
        "description": "tracetool.backend.simple",
        "isExtraImport": true,
        "detail": "tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "is_string",
        "importPath": "tracetool.backend.simple",
        "description": "tracetool.backend.simple",
        "isExtraImport": true,
        "detail": "tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "is_string",
        "importPath": "tracetool.backend.simple",
        "description": "tracetool.backend.simple",
        "isExtraImport": true,
        "detail": "tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "stap_escape",
        "importPath": "tracetool.format.stap",
        "description": "tracetool.format.stap",
        "isExtraImport": true,
        "detail": "tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "stap_escape",
        "importPath": "tracetool.format.stap",
        "description": "tracetool.format.stap",
        "isExtraImport": true,
        "detail": "tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "stap_escape",
        "importPath": "tracetool.format.stap",
        "description": "tracetool.format.stap",
        "isExtraImport": true,
        "detail": "tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "stap_escape",
        "importPath": "tracetool.format.stap",
        "description": "tracetool.format.stap",
        "isExtraImport": true,
        "detail": "tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "simpletrace",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "simpletrace",
        "description": "simpletrace",
        "detail": "simpletrace",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "getopt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "getopt",
        "description": "getopt",
        "detail": "getopt",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_ushort",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_int",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_ulonglong",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_ushort",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_int",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_ulonglong",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "qapi",
        "description": "qapi",
        "isExtraImport": true,
        "detail": "qapi",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "qapi",
        "description": "qapi",
        "isExtraImport": true,
        "detail": "qapi",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "Digraph",
        "importPath": "graphviz",
        "description": "graphviz",
        "isExtraImport": true,
        "detail": "graphviz",
        "documentation": {}
    },
    {
        "label": "Digraph",
        "importPath": "graphviz",
        "description": "graphviz",
        "isExtraImport": true,
        "detail": "graphviz",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "tracetool.backend",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tracetool.backend",
        "description": "tracetool.backend",
        "detail": "tracetool.backend",
        "documentation": {}
    },
    {
        "label": "tracetool.format",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tracetool.format",
        "description": "tracetool.format",
        "detail": "tracetool.format",
        "documentation": {}
    },
    {
        "label": "default_backend",
        "importPath": "cryptography.hazmat.backends",
        "description": "cryptography.hazmat.backends",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.backends",
        "documentation": {}
    },
    {
        "label": "default_backend",
        "importPath": "cryptography.hazmat.backends",
        "description": "cryptography.hazmat.backends",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.backends",
        "documentation": {}
    },
    {
        "label": "ec",
        "importPath": "cryptography.hazmat.primitives.asymmetric",
        "description": "cryptography.hazmat.primitives.asymmetric",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric",
        "documentation": {}
    },
    {
        "label": "ec",
        "importPath": "cryptography.hazmat.primitives.asymmetric",
        "description": "cryptography.hazmat.primitives.asymmetric",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric",
        "documentation": {}
    },
    {
        "label": "Encoding",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "Encoding",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "crypto",
        "importPath": "OpenSSL",
        "description": "OpenSSL",
        "isExtraImport": true,
        "detail": "OpenSSL",
        "documentation": {}
    },
    {
        "label": "crypto",
        "importPath": "OpenSSL",
        "description": "OpenSSL",
        "isExtraImport": true,
        "detail": "OpenSSL",
        "documentation": {}
    },
    {
        "label": "BPF",
        "importPath": "bcc",
        "description": "bcc",
        "isExtraImport": true,
        "detail": "bcc",
        "documentation": {}
    },
    {
        "label": "BPF",
        "importPath": "bcc",
        "description": "bcc",
        "isExtraImport": true,
        "detail": "bcc",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "skipIf",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "skipUnless",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "skipUnless",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "skip",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "statemachine",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "docutils",
        "description": "docutils",
        "isExtraImport": true,
        "detail": "docutils",
        "documentation": {}
    },
    {
        "label": "Element",
        "importPath": "docutils.nodes",
        "description": "docutils.nodes",
        "isExtraImport": true,
        "detail": "docutils.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "docutils.nodes",
        "description": "docutils.nodes",
        "isExtraImport": true,
        "detail": "docutils.nodes",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "docutils.nodes",
        "description": "docutils.nodes",
        "isExtraImport": true,
        "detail": "docutils.nodes",
        "documentation": {}
    },
    {
        "label": "Element",
        "importPath": "docutils.nodes",
        "description": "docutils.nodes",
        "isExtraImport": true,
        "detail": "docutils.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "docutils.nodes",
        "description": "docutils.nodes",
        "isExtraImport": true,
        "detail": "docutils.nodes",
        "documentation": {}
    },
    {
        "label": "Element",
        "importPath": "docutils.nodes",
        "description": "docutils.nodes",
        "isExtraImport": true,
        "detail": "docutils.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "docutils.nodes",
        "description": "docutils.nodes",
        "isExtraImport": true,
        "detail": "docutils.nodes",
        "documentation": {}
    },
    {
        "label": "StringList",
        "importPath": "docutils.statemachine",
        "description": "docutils.statemachine",
        "isExtraImport": true,
        "detail": "docutils.statemachine",
        "documentation": {}
    },
    {
        "label": "StringList",
        "importPath": "docutils.statemachine",
        "description": "docutils.statemachine",
        "isExtraImport": true,
        "detail": "docutils.statemachine",
        "documentation": {}
    },
    {
        "label": "ViewList",
        "importPath": "docutils.statemachine",
        "description": "docutils.statemachine",
        "isExtraImport": true,
        "detail": "docutils.statemachine",
        "documentation": {}
    },
    {
        "label": "ViewList",
        "importPath": "docutils.statemachine",
        "description": "docutils.statemachine",
        "isExtraImport": true,
        "detail": "docutils.statemachine",
        "documentation": {}
    },
    {
        "label": "ViewList",
        "importPath": "docutils.statemachine",
        "description": "docutils.statemachine",
        "isExtraImport": true,
        "detail": "docutils.statemachine",
        "documentation": {}
    },
    {
        "label": "StringList",
        "importPath": "docutils.statemachine",
        "description": "docutils.statemachine",
        "isExtraImport": true,
        "detail": "docutils.statemachine",
        "documentation": {}
    },
    {
        "label": "ViewList",
        "importPath": "docutils.statemachine",
        "description": "docutils.statemachine",
        "isExtraImport": true,
        "detail": "docutils.statemachine",
        "documentation": {}
    },
    {
        "label": "sphinx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sphinx",
        "description": "sphinx",
        "detail": "sphinx",
        "documentation": {}
    },
    {
        "label": "addnodes",
        "importPath": "sphinx",
        "description": "sphinx",
        "isExtraImport": true,
        "detail": "sphinx",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "sphinx",
        "description": "sphinx",
        "isExtraImport": true,
        "detail": "sphinx",
        "documentation": {}
    },
    {
        "label": "addnodes",
        "importPath": "sphinx",
        "description": "sphinx",
        "isExtraImport": true,
        "detail": "sphinx",
        "documentation": {}
    },
    {
        "label": "addnodes",
        "importPath": "sphinx",
        "description": "sphinx",
        "isExtraImport": true,
        "detail": "sphinx",
        "documentation": {}
    },
    {
        "label": "addnodes",
        "importPath": "sphinx",
        "description": "sphinx",
        "isExtraImport": true,
        "detail": "sphinx",
        "documentation": {}
    },
    {
        "label": "errors",
        "importPath": "sphinx",
        "description": "sphinx",
        "isExtraImport": true,
        "detail": "sphinx",
        "documentation": {}
    },
    {
        "label": "ObjectDescription",
        "importPath": "sphinx.directives",
        "description": "sphinx.directives",
        "isExtraImport": true,
        "detail": "sphinx.directives",
        "documentation": {}
    },
    {
        "label": "ObjectDescription",
        "importPath": "sphinx.directives",
        "description": "sphinx.directives",
        "isExtraImport": true,
        "detail": "sphinx.directives",
        "documentation": {}
    },
    {
        "label": "ObjectDescription",
        "importPath": "sphinx.directives",
        "description": "sphinx.directives",
        "isExtraImport": true,
        "detail": "sphinx.directives",
        "documentation": {}
    },
    {
        "label": "BuildEnvironment",
        "importPath": "sphinx.environment",
        "description": "sphinx.environment",
        "isExtraImport": true,
        "detail": "sphinx.environment",
        "documentation": {}
    },
    {
        "label": "XRefRole",
        "importPath": "sphinx.roles",
        "description": "sphinx.roles",
        "isExtraImport": true,
        "detail": "sphinx.roles",
        "documentation": {}
    },
    {
        "label": "XRefRole",
        "importPath": "sphinx.roles",
        "description": "sphinx.roles",
        "isExtraImport": true,
        "detail": "sphinx.roles",
        "documentation": {}
    },
    {
        "label": "XRefRole",
        "importPath": "sphinx.roles",
        "description": "sphinx.roles",
        "isExtraImport": true,
        "detail": "sphinx.roles",
        "documentation": {}
    },
    {
        "label": "docfields",
        "importPath": "sphinx.util",
        "description": "sphinx.util",
        "isExtraImport": true,
        "detail": "sphinx.util",
        "documentation": {}
    },
    {
        "label": "logging",
        "importPath": "sphinx.util",
        "description": "sphinx.util",
        "isExtraImport": true,
        "detail": "sphinx.util",
        "documentation": {}
    },
    {
        "label": "nodes",
        "importPath": "sphinx.util",
        "description": "sphinx.util",
        "isExtraImport": true,
        "detail": "sphinx.util",
        "documentation": {}
    },
    {
        "label": "logging",
        "importPath": "sphinx.util",
        "description": "sphinx.util",
        "isExtraImport": true,
        "detail": "sphinx.util",
        "documentation": {}
    },
    {
        "label": "logging",
        "importPath": "sphinx.util",
        "description": "sphinx.util",
        "isExtraImport": true,
        "detail": "sphinx.util",
        "documentation": {}
    },
    {
        "label": "logging",
        "importPath": "sphinx.util",
        "description": "sphinx.util",
        "isExtraImport": true,
        "detail": "sphinx.util",
        "documentation": {}
    },
    {
        "label": "ReferenceRole",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "SphinxDirective",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "switch_source_input",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "SphinxDirective",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "switch_source_input",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "switch_source_input",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "switch_source_input",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "SphinxDirective",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "SphinxDirective",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "switch_source_input",
        "importPath": "sphinx.util.docutils",
        "description": "sphinx.util.docutils",
        "isExtraImport": true,
        "detail": "sphinx.util.docutils",
        "documentation": {}
    },
    {
        "label": "TextlikeNode",
        "importPath": "sphinx.util.typing",
        "description": "sphinx.util.typing",
        "isExtraImport": true,
        "detail": "sphinx.util.typing",
        "documentation": {}
    },
    {
        "label": "OptionSpec",
        "importPath": "sphinx.util.typing",
        "description": "sphinx.util.typing",
        "isExtraImport": true,
        "detail": "sphinx.util.typing",
        "documentation": {}
    },
    {
        "label": "Directive",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "directives",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "directives",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "Directive",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "directives",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "Directive",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "directives",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "Directive",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "directives",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "directives",
        "importPath": "docutils.parsers.rst",
        "description": "docutils.parsers.rst",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst",
        "documentation": {}
    },
    {
        "label": "RSTState",
        "importPath": "docutils.parsers.rst.states",
        "description": "docutils.parsers.rst.states",
        "isExtraImport": true,
        "detail": "docutils.parsers.rst.states",
        "documentation": {}
    },
    {
        "label": "Sphinx",
        "importPath": "sphinx.application",
        "description": "sphinx.application",
        "isExtraImport": true,
        "detail": "sphinx.application",
        "documentation": {}
    },
    {
        "label": "Sphinx",
        "importPath": "sphinx.application",
        "description": "sphinx.application",
        "isExtraImport": true,
        "detail": "sphinx.application",
        "documentation": {}
    },
    {
        "label": "ExtensionError",
        "importPath": "sphinx.errors",
        "description": "sphinx.errors",
        "isExtraImport": true,
        "detail": "sphinx.errors",
        "documentation": {}
    },
    {
        "label": "ExtensionError",
        "importPath": "sphinx.errors",
        "description": "sphinx.errors",
        "isExtraImport": true,
        "detail": "sphinx.errors",
        "documentation": {}
    },
    {
        "label": "ExtensionError",
        "importPath": "sphinx.errors",
        "description": "sphinx.errors",
        "isExtraImport": true,
        "detail": "sphinx.errors",
        "documentation": {}
    },
    {
        "label": "ConfigError",
        "importPath": "sphinx.errors",
        "description": "sphinx.errors",
        "isExtraImport": true,
        "detail": "sphinx.errors",
        "documentation": {}
    },
    {
        "label": "prepare_docstring",
        "importPath": "sphinx.util.docstrings",
        "description": "sphinx.util.docstrings",
        "isExtraImport": true,
        "detail": "sphinx.util.docstrings",
        "documentation": {}
    },
    {
        "label": "nested_parse_with_titles",
        "importPath": "sphinx.util.nodes",
        "description": "sphinx.util.nodes",
        "isExtraImport": true,
        "detail": "sphinx.util.nodes",
        "documentation": {}
    },
    {
        "label": "nested_parse_with_titles",
        "importPath": "sphinx.util.nodes",
        "description": "sphinx.util.nodes",
        "isExtraImport": true,
        "detail": "sphinx.util.nodes",
        "documentation": {}
    },
    {
        "label": "make_id",
        "importPath": "sphinx.util.nodes",
        "description": "sphinx.util.nodes",
        "isExtraImport": true,
        "detail": "sphinx.util.nodes",
        "documentation": {}
    },
    {
        "label": "make_refnode",
        "importPath": "sphinx.util.nodes",
        "description": "sphinx.util.nodes",
        "isExtraImport": true,
        "detail": "sphinx.util.nodes",
        "documentation": {}
    },
    {
        "label": "nested_parse_with_titles",
        "importPath": "sphinx.util.nodes",
        "description": "sphinx.util.nodes",
        "isExtraImport": true,
        "detail": "sphinx.util.nodes",
        "documentation": {}
    },
    {
        "label": "dbusdomain",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dbusdomain",
        "description": "dbusdomain",
        "detail": "dbusdomain",
        "documentation": {}
    },
    {
        "label": "parse_dbus_xml",
        "importPath": "dbusparser",
        "description": "dbusparser",
        "isExtraImport": true,
        "detail": "dbusparser",
        "documentation": {}
    },
    {
        "label": "desc_signature",
        "importPath": "sphinx.addnodes",
        "description": "sphinx.addnodes",
        "isExtraImport": true,
        "detail": "sphinx.addnodes",
        "documentation": {}
    },
    {
        "label": "pending_xref",
        "importPath": "sphinx.addnodes",
        "description": "sphinx.addnodes",
        "isExtraImport": true,
        "detail": "sphinx.addnodes",
        "documentation": {}
    },
    {
        "label": "Domain",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "Index",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "IndexEntry",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "ObjType",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "Domain",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "Index",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "IndexEntry",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "ObjType",
        "importPath": "sphinx.domains",
        "description": "sphinx.domains",
        "isExtraImport": true,
        "detail": "sphinx.domains",
        "documentation": {}
    },
    {
        "label": "_",
        "importPath": "sphinx.locale",
        "description": "sphinx.locale",
        "isExtraImport": true,
        "detail": "sphinx.locale",
        "documentation": {}
    },
    {
        "label": "_",
        "importPath": "sphinx.locale",
        "description": "sphinx.locale",
        "isExtraImport": true,
        "detail": "sphinx.locale",
        "documentation": {}
    },
    {
        "label": "__",
        "importPath": "sphinx.locale",
        "description": "sphinx.locale",
        "isExtraImport": true,
        "detail": "sphinx.locale",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "sphinx.util.docfields",
        "description": "sphinx.util.docfields",
        "isExtraImport": true,
        "detail": "sphinx.util.docfields",
        "documentation": {}
    },
    {
        "label": "TypedField",
        "importPath": "sphinx.util.docfields",
        "description": "sphinx.util.docfields",
        "isExtraImport": true,
        "detail": "sphinx.util.docfields",
        "documentation": {}
    },
    {
        "label": "xml.parsers.expat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.parsers.expat",
        "description": "xml.parsers.expat",
        "detail": "xml.parsers.expat",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "CompatField",
        "importPath": "compat",
        "description": "compat",
        "isExtraImport": true,
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "CompatGroupedField",
        "importPath": "compat",
        "description": "compat",
        "isExtraImport": true,
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "CompatTypedField",
        "importPath": "compat",
        "description": "compat",
        "isExtraImport": true,
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "KeywordNode",
        "importPath": "compat",
        "description": "compat",
        "isExtraImport": true,
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "ParserFix",
        "importPath": "compat",
        "description": "compat",
        "isExtraImport": true,
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "Signature",
        "importPath": "compat",
        "description": "compat",
        "isExtraImport": true,
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "SpaceNode",
        "importPath": "compat",
        "description": "compat",
        "isExtraImport": true,
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "QAPIError",
        "importPath": "qapi.error",
        "description": "qapi.error",
        "isExtraImport": true,
        "detail": "qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPISemError",
        "importPath": "qapi.error",
        "description": "qapi.error",
        "isExtraImport": true,
        "detail": "qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPIError",
        "importPath": "qapi.error",
        "description": "qapi.error",
        "isExtraImport": true,
        "detail": "qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPIDoc",
        "importPath": "qapi.parser",
        "description": "qapi.parser",
        "isExtraImport": true,
        "detail": "qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPIDoc",
        "importPath": "qapi.parser",
        "description": "qapi.parser",
        "isExtraImport": true,
        "detail": "qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPISchema",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaArrayType",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaCommand",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaDefinition",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEnumMember",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEvent",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaFeature",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaMember",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaObjectType",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaObjectTypeMember",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaType",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVisitor",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchema",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVisitor",
        "importPath": "qapi.schema",
        "description": "qapi.schema",
        "isExtraImport": true,
        "detail": "qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISourceInfo",
        "importPath": "qapi.source",
        "description": "qapi.source",
        "isExtraImport": true,
        "detail": "qapi.source",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenRSTVisitor",
        "importPath": "qapidoc_legacy",
        "description": "qapidoc_legacy",
        "isExtraImport": true,
        "detail": "qapidoc_legacy",
        "documentation": {}
    },
    {
        "label": "CodeBlock",
        "importPath": "sphinx.directives.code",
        "description": "sphinx.directives.code",
        "isExtraImport": true,
        "detail": "sphinx.directives.code",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVisitor",
        "importPath": "qapi.gen",
        "description": "qapi.gen",
        "isExtraImport": true,
        "detail": "qapi.gen",
        "documentation": {}
    },
    {
        "label": "RegexLexer",
        "importPath": "pygments.lexer",
        "description": "pygments.lexer",
        "isExtraImport": true,
        "detail": "pygments.lexer",
        "documentation": {}
    },
    {
        "label": "DelegatingLexer",
        "importPath": "pygments.lexer",
        "description": "pygments.lexer",
        "isExtraImport": true,
        "detail": "pygments.lexer",
        "documentation": {}
    },
    {
        "label": "JsonLexer",
        "importPath": "pygments.lexers.data",
        "description": "pygments.lexers.data",
        "isExtraImport": true,
        "detail": "pygments.lexers.data",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "osx2win32",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "osx2win32",
        "description": "osx2win32",
        "detail": "osx2win32",
        "documentation": {}
    },
    {
        "label": "osx2win32_name",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "osx2win32_name",
        "description": "osx2win32_name",
        "detail": "osx2win32_name",
        "documentation": {}
    },
    {
        "label": "osx2xkb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "osx2xkb",
        "description": "osx2xkb",
        "detail": "osx2xkb",
        "documentation": {}
    },
    {
        "label": "osx2xkb_name",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "osx2xkb_name",
        "description": "osx2xkb_name",
        "detail": "osx2xkb_name",
        "documentation": {}
    },
    {
        "label": "html2win32",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html2win32",
        "description": "html2win32",
        "detail": "html2win32",
        "documentation": {}
    },
    {
        "label": "html2win32_name",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html2win32_name",
        "description": "html2win32_name",
        "detail": "html2win32_name",
        "documentation": {}
    },
    {
        "label": "osx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "osx",
        "description": "osx",
        "detail": "osx",
        "documentation": {}
    },
    {
        "label": "osx_name",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "osx_name",
        "description": "osx_name",
        "detail": "osx_name",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "hex_common",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hex_common",
        "description": "hex_common",
        "detail": "hex_common",
        "documentation": {}
    },
    {
        "label": "iset",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "iset",
        "description": "iset",
        "detail": "iset",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "getpass",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "getpass",
        "description": "getpass",
        "detail": "getpass",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "TarFile",
        "importPath": "tarfile",
        "description": "tarfile",
        "isExtraImport": true,
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "TarInfo",
        "importPath": "tarfile",
        "description": "tarfile",
        "isExtraImport": true,
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib.error",
        "description": "urllib.error",
        "isExtraImport": true,
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "fcntl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fcntl",
        "description": "fcntl",
        "detail": "fcntl",
        "documentation": {}
    },
    {
        "label": "pycotap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pycotap",
        "description": "pycotap",
        "detail": "pycotap",
        "documentation": {}
    },
    {
        "label": "kvm_available",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "tcg_available",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "get_info_usernet_hostfwd_port",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "kvm_available",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "VerboseProcessError",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "kvm_available",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "get_info_usernet_hostfwd_port",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "kvm_available",
        "importPath": "qemu.utils",
        "description": "qemu.utils",
        "isExtraImport": true,
        "detail": "qemu.utils",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "which",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "get_qemu_img",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "get_qemu_img",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfOperatingSystem",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "get_qemu_img",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingImports",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "interrupt_interactive_console_until_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipSlowTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipSlowTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "BUILD_DIR",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "get_qemu_img",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfNotMachine",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuUserTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "interrupt_interactive_console_until_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipBigDataTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "interrupt_interactive_console_until_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipBigDataTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingImports",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "interrupt_interactive_console_until_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipBigDataTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "interrupt_interactive_console_until_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipSlowTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingImports",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingImports",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipSlowTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "interrupt_interactive_console_until_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipSlowTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipBigDataTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingImports",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "is_readable_executable_file",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "get_qemu_img",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipIfMissingImports",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "Asset",
        "importPath": "qemu_test",
        "description": "qemu_test",
        "isExtraImport": true,
        "detail": "qemu_test",
        "documentation": {}
    },
    {
        "label": "gzip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gzip",
        "description": "gzip",
        "detail": "gzip",
        "documentation": {}
    },
    {
        "label": "lzma",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lzma",
        "description": "lzma",
        "detail": "lzma",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test.linuxkernel",
        "description": "qemu_test.linuxkernel",
        "isExtraImport": true,
        "detail": "qemu_test.linuxkernel",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "importPath": "qemu_test.linuxkernel",
        "description": "qemu_test.linuxkernel",
        "isExtraImport": true,
        "detail": "qemu_test.linuxkernel",
        "documentation": {}
    },
    {
        "label": "Ports",
        "importPath": "qemu_test.ports",
        "description": "qemu_test.ports",
        "isExtraImport": true,
        "detail": "qemu_test.ports",
        "documentation": {}
    },
    {
        "label": "Ports",
        "importPath": "qemu_test.ports",
        "description": "qemu_test.ports",
        "isExtraImport": true,
        "detail": "qemu_test.ports",
        "documentation": {}
    },
    {
        "label": "Ports",
        "importPath": "qemu_test.ports",
        "description": "qemu_test.ports",
        "isExtraImport": true,
        "detail": "qemu_test.ports",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "importPath": "replay_kernel",
        "description": "replay_kernel",
        "isExtraImport": true,
        "detail": "replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReverseDebugging",
        "importPath": "reverse_debugging",
        "description": "reverse_debugging",
        "isExtraImport": true,
        "detail": "reverse_debugging",
        "documentation": {}
    },
    {
        "label": "ReverseDebugging",
        "importPath": "reverse_debugging",
        "description": "reverse_debugging",
        "isExtraImport": true,
        "detail": "reverse_debugging",
        "documentation": {}
    },
    {
        "label": "ReverseDebugging",
        "importPath": "reverse_debugging",
        "description": "reverse_debugging",
        "isExtraImport": true,
        "detail": "reverse_debugging",
        "documentation": {}
    },
    {
        "label": "test_realms_guest",
        "importPath": "test_aarch64_rme_virt",
        "description": "test_aarch64_rme_virt",
        "isExtraImport": true,
        "detail": "test_aarch64_rme_virt",
        "documentation": {}
    },
    {
        "label": "fetch_firmware",
        "importPath": "test_aarch64_sbsaref",
        "description": "test_aarch64_sbsaref",
        "isExtraImport": true,
        "detail": "test_aarch64_sbsaref",
        "documentation": {}
    },
    {
        "label": "fetch_firmware",
        "importPath": "test_aarch64_sbsaref",
        "description": "test_aarch64_sbsaref",
        "isExtraImport": true,
        "detail": "test_aarch64_sbsaref",
        "documentation": {}
    },
    {
        "label": "mmap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mmap",
        "description": "mmap",
        "detail": "mmap",
        "documentation": {}
    },
    {
        "label": "VMLaunchFailure",
        "importPath": "qemu.machine.machine",
        "description": "qemu.machine.machine",
        "isExtraImport": true,
        "detail": "qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "VMLaunchFailure",
        "importPath": "qemu.machine.machine",
        "description": "qemu.machine.machine",
        "isExtraImport": true,
        "detail": "qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "VMLaunchFailure",
        "importPath": "qemu.machine.machine",
        "description": "qemu.machine.machine",
        "isExtraImport": true,
        "detail": "qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "importPath": "qemu_test.tuxruntest",
        "description": "qemu_test.tuxruntest",
        "isExtraImport": true,
        "detail": "qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "importPath": "aspeed",
        "description": "aspeed",
        "isExtraImport": true,
        "detail": "aspeed",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "importPath": "aspeed",
        "description": "aspeed",
        "isExtraImport": true,
        "detail": "aspeed",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "importPath": "aspeed",
        "description": "aspeed",
        "isExtraImport": true,
        "detail": "aspeed",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "importPath": "aspeed",
        "description": "aspeed",
        "isExtraImport": true,
        "detail": "aspeed",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "importPath": "aspeed",
        "description": "aspeed",
        "isExtraImport": true,
        "detail": "aspeed",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "importPath": "aspeed",
        "description": "aspeed",
        "isExtraImport": true,
        "detail": "aspeed",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "importPath": "aspeed",
        "description": "aspeed",
        "isExtraImport": true,
        "detail": "aspeed",
        "documentation": {}
    },
    {
        "label": "bz2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bz2",
        "description": "bz2",
        "detail": "bz2",
        "documentation": {}
    },
    {
        "label": "image_pow2ceil_expand",
        "importPath": "qemu_test.utils",
        "description": "qemu_test.utils",
        "isExtraImport": true,
        "detail": "qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "image_pow2ceil_expand",
        "importPath": "qemu_test.utils",
        "description": "qemu_test.utils",
        "isExtraImport": true,
        "detail": "qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "file_truncate",
        "importPath": "qemu_test.utils",
        "description": "qemu_test.utils",
        "isExtraImport": true,
        "detail": "qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "image_pow2ceil_expand",
        "importPath": "qemu_test.utils",
        "description": "qemu_test.utils",
        "isExtraImport": true,
        "detail": "qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "get_usernet_hostfwd_port",
        "importPath": "qemu_test.utils",
        "description": "qemu_test.utils",
        "isExtraImport": true,
        "detail": "qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "tesseract_ocr",
        "importPath": "qemu_test.tesseract",
        "description": "qemu_test.tesseract",
        "isExtraImport": true,
        "detail": "qemu_test.tesseract",
        "documentation": {}
    },
    {
        "label": "MicroblazeMachine",
        "importPath": "test_microblaze_s3adsp1800",
        "description": "test_microblaze_s3adsp1800",
        "isExtraImport": true,
        "detail": "test_microblaze_s3adsp1800",
        "documentation": {}
    },
    {
        "label": "mips_check_wheezy",
        "importPath": "test_mips_malta",
        "description": "test_mips_malta",
        "isExtraImport": true,
        "detail": "test_mips_malta",
        "documentation": {}
    },
    {
        "label": "mips_check_wheezy",
        "importPath": "test_mips_malta",
        "description": "test_mips_malta",
        "isExtraImport": true,
        "detail": "test_mips_malta",
        "documentation": {}
    },
    {
        "label": "mips_check_wheezy",
        "importPath": "test_mips_malta",
        "description": "test_mips_malta",
        "isExtraImport": true,
        "detail": "test_mips_malta",
        "documentation": {}
    },
    {
        "label": "MaltaMachineYAMON",
        "importPath": "test_mipsel_malta",
        "description": "test_mipsel_malta",
        "isExtraImport": true,
        "detail": "test_mipsel_malta",
        "documentation": {}
    },
    {
        "label": "resource",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "resource",
        "description": "resource",
        "detail": "resource",
        "documentation": {}
    },
    {
        "label": "Scenario",
        "importPath": "guestperf.scenario",
        "description": "guestperf.scenario",
        "isExtraImport": true,
        "detail": "guestperf.scenario",
        "documentation": {}
    },
    {
        "label": "Scenario",
        "importPath": "guestperf.scenario",
        "description": "guestperf.scenario",
        "isExtraImport": true,
        "detail": "guestperf.scenario",
        "documentation": {}
    },
    {
        "label": "Scenario",
        "importPath": "guestperf.scenario",
        "description": "guestperf.scenario",
        "isExtraImport": true,
        "detail": "guestperf.scenario",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "guestperf.progress",
        "description": "guestperf.progress",
        "isExtraImport": true,
        "detail": "guestperf.progress",
        "documentation": {}
    },
    {
        "label": "ProgressStats",
        "importPath": "guestperf.progress",
        "description": "guestperf.progress",
        "isExtraImport": true,
        "detail": "guestperf.progress",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "guestperf.progress",
        "description": "guestperf.progress",
        "isExtraImport": true,
        "detail": "guestperf.progress",
        "documentation": {}
    },
    {
        "label": "Report",
        "importPath": "guestperf.report",
        "description": "guestperf.report",
        "isExtraImport": true,
        "detail": "guestperf.report",
        "documentation": {}
    },
    {
        "label": "ReportResult",
        "importPath": "guestperf.report",
        "description": "guestperf.report",
        "isExtraImport": true,
        "detail": "guestperf.report",
        "documentation": {}
    },
    {
        "label": "Report",
        "importPath": "guestperf.report",
        "description": "guestperf.report",
        "isExtraImport": true,
        "detail": "guestperf.report",
        "documentation": {}
    },
    {
        "label": "TimingRecord",
        "importPath": "guestperf.timings",
        "description": "guestperf.timings",
        "isExtraImport": true,
        "detail": "guestperf.timings",
        "documentation": {}
    },
    {
        "label": "Timings",
        "importPath": "guestperf.timings",
        "description": "guestperf.timings",
        "isExtraImport": true,
        "detail": "guestperf.timings",
        "documentation": {}
    },
    {
        "label": "Timings",
        "importPath": "guestperf.timings",
        "description": "guestperf.timings",
        "isExtraImport": true,
        "detail": "guestperf.timings",
        "documentation": {}
    },
    {
        "label": "Hardware",
        "importPath": "guestperf.hardware",
        "description": "guestperf.hardware",
        "isExtraImport": true,
        "detail": "guestperf.hardware",
        "documentation": {}
    },
    {
        "label": "Hardware",
        "importPath": "guestperf.hardware",
        "description": "guestperf.hardware",
        "isExtraImport": true,
        "detail": "guestperf.hardware",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "importPath": "fnmatch",
        "description": "fnmatch",
        "isExtraImport": true,
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "importPath": "fnmatch",
        "description": "fnmatch",
        "isExtraImport": true,
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "Engine",
        "importPath": "guestperf.engine",
        "description": "guestperf.engine",
        "isExtraImport": true,
        "detail": "guestperf.engine",
        "documentation": {}
    },
    {
        "label": "COMPARISONS",
        "importPath": "guestperf.comparison",
        "description": "guestperf.comparison",
        "isExtraImport": true,
        "detail": "guestperf.comparison",
        "documentation": {}
    },
    {
        "label": "Plot",
        "importPath": "guestperf.plot",
        "description": "guestperf.plot",
        "isExtraImport": true,
        "detail": "guestperf.plot",
        "documentation": {}
    },
    {
        "label": "BatchShell",
        "importPath": "guestperf.shell",
        "description": "guestperf.shell",
        "isExtraImport": true,
        "detail": "guestperf.shell",
        "documentation": {}
    },
    {
        "label": "PlotShell",
        "importPath": "guestperf.shell",
        "description": "guestperf.shell",
        "isExtraImport": true,
        "detail": "guestperf.shell",
        "documentation": {}
    },
    {
        "label": "Shell",
        "importPath": "guestperf.shell",
        "description": "guestperf.shell",
        "isExtraImport": true,
        "detail": "guestperf.shell",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "faulthandler",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "faulthandler",
        "description": "faulthandler",
        "detail": "faulthandler",
        "documentation": {}
    },
    {
        "label": "QcowHeader",
        "importPath": "qcow2_format",
        "description": "qcow2_format",
        "isExtraImport": true,
        "detail": "qcow2_format",
        "documentation": {}
    },
    {
        "label": "QcowHeaderExtension",
        "importPath": "qcow2_format",
        "description": "qcow2_format",
        "isExtraImport": true,
        "detail": "qcow2_format",
        "documentation": {}
    },
    {
        "label": "optparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optparse",
        "description": "optparse",
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "TestEnv",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "arg_parser",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "gdb_exit",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "gdb_exit",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "gdb_exit",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "importPath": "test_gdbstub",
        "description": "test_gdbstub",
        "isExtraImport": true,
        "detail": "test_gdbstub",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "basevm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "basevm",
        "description": "basevm",
        "detail": "basevm",
        "documentation": {}
    },
    {
        "label": "namespace",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "namespace = \"qemu-project\"\nif len(sys.argv) >= 2:\n    namespace = sys.argv[1]\ncwd = os.getcwd()\nreponame = os.path.basename(cwd)\nrepourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\nsubprocess.check_call([\"git\", \"remote\", \"add\", \"check-dco\", repourl])\nsubprocess.check_call([\"git\", \"fetch\", \"--refetch\", \"check-dco\", \"master\"])\nancestor = subprocess.check_output([\"git\", \"merge-base\",",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "cwd",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "cwd = os.getcwd()\nreponame = os.path.basename(cwd)\nrepourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\nsubprocess.check_call([\"git\", \"remote\", \"add\", \"check-dco\", repourl])\nsubprocess.check_call([\"git\", \"fetch\", \"--refetch\", \"check-dco\", \"master\"])\nancestor = subprocess.check_output([\"git\", \"merge-base\",\n                                    \"check-dco/master\", \"HEAD\"],\n                                   universal_newlines=True)\nancestor = ancestor.strip()",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "reponame",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "reponame = os.path.basename(cwd)\nrepourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\nsubprocess.check_call([\"git\", \"remote\", \"add\", \"check-dco\", repourl])\nsubprocess.check_call([\"git\", \"fetch\", \"--refetch\", \"check-dco\", \"master\"])\nancestor = subprocess.check_output([\"git\", \"merge-base\",\n                                    \"check-dco/master\", \"HEAD\"],\n                                   universal_newlines=True)\nancestor = ancestor.strip()\nsubprocess.check_call([\"git\", \"remote\", \"rm\", \"check-dco\"])",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "repourl",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "repourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\nsubprocess.check_call([\"git\", \"remote\", \"add\", \"check-dco\", repourl])\nsubprocess.check_call([\"git\", \"fetch\", \"--refetch\", \"check-dco\", \"master\"])\nancestor = subprocess.check_output([\"git\", \"merge-base\",\n                                    \"check-dco/master\", \"HEAD\"],\n                                   universal_newlines=True)\nancestor = ancestor.strip()\nsubprocess.check_call([\"git\", \"remote\", \"rm\", \"check-dco\"])\nerrors = False",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "ancestor",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "ancestor = subprocess.check_output([\"git\", \"merge-base\",\n                                    \"check-dco/master\", \"HEAD\"],\n                                   universal_newlines=True)\nancestor = ancestor.strip()\nsubprocess.check_call([\"git\", \"remote\", \"rm\", \"check-dco\"])\nerrors = False\nprint(\"\\nChecking for 'Signed-off-by: NAME <EMAIL>' \" +\n      \"on all commits since %s...\\n\" % ancestor)\nlog = subprocess.check_output([\"git\", \"log\", \"--format=%H %s\",\n                               ancestor + \"...\"],",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "ancestor",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "ancestor = ancestor.strip()\nsubprocess.check_call([\"git\", \"remote\", \"rm\", \"check-dco\"])\nerrors = False\nprint(\"\\nChecking for 'Signed-off-by: NAME <EMAIL>' \" +\n      \"on all commits since %s...\\n\" % ancestor)\nlog = subprocess.check_output([\"git\", \"log\", \"--format=%H %s\",\n                               ancestor + \"...\"],\n                              universal_newlines=True)\nif log == \"\":\n    commits = []",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "errors",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "errors = False\nprint(\"\\nChecking for 'Signed-off-by: NAME <EMAIL>' \" +\n      \"on all commits since %s...\\n\" % ancestor)\nlog = subprocess.check_output([\"git\", \"log\", \"--format=%H %s\",\n                               ancestor + \"...\"],\n                              universal_newlines=True)\nif log == \"\":\n    commits = []\nelse:\n    commits = [[c[0:40], c[41:]] for c in log.strip().split(\"\\n\")]",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-dco",
        "description": "qemu..gitlab-ci.d.check-dco",
        "peekOfCode": "log = subprocess.check_output([\"git\", \"log\", \"--format=%H %s\",\n                               ancestor + \"...\"],\n                              universal_newlines=True)\nif log == \"\":\n    commits = []\nelse:\n    commits = [[c[0:40], c[41:]] for c in log.strip().split(\"\\n\")]\nfor sha, subject in commits:\n    msg = subprocess.check_output([\"git\", \"show\", \"-s\", sha],\n                                  universal_newlines=True)",
        "detail": "qemu..gitlab-ci.d.check-dco",
        "documentation": {}
    },
    {
        "label": "namespace",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "namespace = \"qemu-project\"\nif len(sys.argv) >= 2:\n    namespace = sys.argv[1]\ncwd = os.getcwd()\nreponame = os.path.basename(cwd)\nrepourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\n# GitLab CI environment does not give us any direct info about the\n# base for the user's branch. We thus need to figure out a common\n# ancestor between the user's branch and current git master.",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "cwd",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "cwd = os.getcwd()\nreponame = os.path.basename(cwd)\nrepourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\n# GitLab CI environment does not give us any direct info about the\n# base for the user's branch. We thus need to figure out a common\n# ancestor between the user's branch and current git master.\nsubprocess.check_call([\"git\", \"remote\", \"add\", \"check-patch\", repourl])\nsubprocess.check_call([\"git\", \"fetch\", \"--refetch\", \"check-patch\", \"master\"])\nancestor = subprocess.check_output([\"git\", \"merge-base\",",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "reponame",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "reponame = os.path.basename(cwd)\nrepourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\n# GitLab CI environment does not give us any direct info about the\n# base for the user's branch. We thus need to figure out a common\n# ancestor between the user's branch and current git master.\nsubprocess.check_call([\"git\", \"remote\", \"add\", \"check-patch\", repourl])\nsubprocess.check_call([\"git\", \"fetch\", \"--refetch\", \"check-patch\", \"master\"])\nancestor = subprocess.check_output([\"git\", \"merge-base\",\n                                    \"check-patch/master\", \"HEAD\"],",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "repourl",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "repourl = \"https://gitlab.com/%s/%s.git\" % (namespace, reponame)\nprint(f\"adding upstream git repo @ {repourl}\")\n# GitLab CI environment does not give us any direct info about the\n# base for the user's branch. We thus need to figure out a common\n# ancestor between the user's branch and current git master.\nsubprocess.check_call([\"git\", \"remote\", \"add\", \"check-patch\", repourl])\nsubprocess.check_call([\"git\", \"fetch\", \"--refetch\", \"check-patch\", \"master\"])\nancestor = subprocess.check_output([\"git\", \"merge-base\",\n                                    \"check-patch/master\", \"HEAD\"],\n                                   universal_newlines=True)",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "ancestor",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "ancestor = subprocess.check_output([\"git\", \"merge-base\",\n                                    \"check-patch/master\", \"HEAD\"],\n                                   universal_newlines=True)\nancestor = ancestor.strip()\nlog = subprocess.check_output([\"git\", \"log\", \"--format=%H %s\",\n                               ancestor + \"...\"],\n                              universal_newlines=True)\nsubprocess.check_call([\"git\", \"remote\", \"rm\", \"check-patch\"])\nif log == \"\":\n    print(\"\\nNo commits since %s, skipping checks\\n\" % ancestor)",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "ancestor",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "ancestor = ancestor.strip()\nlog = subprocess.check_output([\"git\", \"log\", \"--format=%H %s\",\n                               ancestor + \"...\"],\n                              universal_newlines=True)\nsubprocess.check_call([\"git\", \"remote\", \"rm\", \"check-patch\"])\nif log == \"\":\n    print(\"\\nNo commits since %s, skipping checks\\n\" % ancestor)\n    sys.exit(0)\nerrors = False\nprint(\"\\nChecking all commits since %s...\\n\" % ancestor, flush=True)",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "log = subprocess.check_output([\"git\", \"log\", \"--format=%H %s\",\n                               ancestor + \"...\"],\n                              universal_newlines=True)\nsubprocess.check_call([\"git\", \"remote\", \"rm\", \"check-patch\"])\nif log == \"\":\n    print(\"\\nNo commits since %s, skipping checks\\n\" % ancestor)\n    sys.exit(0)\nerrors = False\nprint(\"\\nChecking all commits since %s...\\n\" % ancestor, flush=True)\nret = subprocess.run([\"scripts/checkpatch.pl\", \"--terse\", ancestor + \"...\"])",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "errors",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "errors = False\nprint(\"\\nChecking all commits since %s...\\n\" % ancestor, flush=True)\nret = subprocess.run([\"scripts/checkpatch.pl\", \"--terse\", ancestor + \"...\"])\nif ret.returncode != 0:\n    print(\"     FAIL one or more commits failed scripts/checkpatch.pl\")\n    sys.exit(1)\nsys.exit(0)",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "ret",
        "kind": 5,
        "importPath": "qemu..gitlab-ci.d.check-patch",
        "description": "qemu..gitlab-ci.d.check-patch",
        "peekOfCode": "ret = subprocess.run([\"scripts/checkpatch.pl\", \"--terse\", ancestor + \"...\"])\nif ret.returncode != 0:\n    print(\"     FAIL one or more commits failed scripts/checkpatch.pl\")\n    sys.exit(1)\nsys.exit(0)",
        "detail": "qemu..gitlab-ci.d.check-patch",
        "documentation": {}
    },
    {
        "label": "extract_build_units",
        "kind": 2,
        "importPath": "qemu..gitlab-ci.d.check-units",
        "description": "qemu..gitlab-ci.d.check-units",
        "peekOfCode": "def extract_build_units(cc_path):\n    \"\"\"\n    Extract the build units and their counds from compile_commands.json file.\n    Returns:\n        Hash table of [\"unit\"] = count\n    \"\"\"\n    j = json.load(open(cc_path, 'r'))\n    files = [f['file'] for f in j]\n    build_units = Counter(files)\n    return build_units",
        "detail": "qemu..gitlab-ci.d.check-units",
        "documentation": {}
    },
    {
        "label": "analyse_units",
        "kind": 2,
        "importPath": "qemu..gitlab-ci.d.check-units",
        "description": "qemu..gitlab-ci.d.check-units",
        "peekOfCode": "def analyse_units(build_units):\n    \"\"\"\n    Analyse the build units and report stats and the top 10 rebuilds\n    \"\"\"\n    print(f\"Total source files: {len(build_units.keys())}\")\n    print(f\"Total build units: {sum(units.values())}\")\n    # Create a sorted list by number of rebuilds\n    sorted_build_units = sorted(build_units.items(),\n                                key=lambda item: item[1],\n                                reverse=True)",
        "detail": "qemu..gitlab-ci.d.check-units",
        "documentation": {}
    },
    {
        "label": "ConsoleSocket",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.console_socket",
        "description": "qemu.build.python.qemu.machine.console_socket",
        "peekOfCode": "class ConsoleSocket(socket.socket):\n    \"\"\"\n    ConsoleSocket represents a socket attached to a char device.\n    :param address: An AF_UNIX path or address.\n    :param sock_fd: Optionally, an existing socket file descriptor.\n                    One of address or sock_fd must be specified.\n    :param file: Optionally, a filename to log to.\n    :param drain: Optionally, drains the socket and places the bytes\n                  into an in memory buffer for later processing.\n    \"\"\"",
        "detail": "qemu.build.python.qemu.machine.console_socket",
        "documentation": {}
    },
    {
        "label": "QEMUMachineError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.machine",
        "description": "qemu.build.python.qemu.machine.machine",
        "peekOfCode": "class QEMUMachineError(Exception):\n    \"\"\"\n    Exception called when an error in QEMUMachine happens.\n    \"\"\"\nclass QEMUMachineAddDeviceError(QEMUMachineError):\n    \"\"\"\n    Exception raised when a request to add a device can not be fulfilled\n    The failures are caused by limitations, lack of information or conflicting\n    requests on the QEMUMachine methods.  This exception does not represent\n    failures reported by the QEMU binary itself.",
        "detail": "qemu.build.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachineAddDeviceError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.machine",
        "description": "qemu.build.python.qemu.machine.machine",
        "peekOfCode": "class QEMUMachineAddDeviceError(QEMUMachineError):\n    \"\"\"\n    Exception raised when a request to add a device can not be fulfilled\n    The failures are caused by limitations, lack of information or conflicting\n    requests on the QEMUMachine methods.  This exception does not represent\n    failures reported by the QEMU binary itself.\n    \"\"\"\nclass VMLaunchFailure(QEMUMachineError):\n    \"\"\"\n    Exception raised when a VM launch was attempted, but failed.",
        "detail": "qemu.build.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "VMLaunchFailure",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.machine",
        "description": "qemu.build.python.qemu.machine.machine",
        "peekOfCode": "class VMLaunchFailure(QEMUMachineError):\n    \"\"\"\n    Exception raised when a VM launch was attempted, but failed.\n    \"\"\"\n    def __init__(self, exitcode: Optional[int],\n                 command: str, output: Optional[str]):\n        super().__init__(exitcode, command, output)\n        self.exitcode = exitcode\n        self.command = command\n        self.output = output",
        "detail": "qemu.build.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "AbnormalShutdown",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.machine",
        "description": "qemu.build.python.qemu.machine.machine",
        "peekOfCode": "class AbnormalShutdown(QEMUMachineError):\n    \"\"\"\n    Exception raised when a graceful shutdown was requested, but not performed.\n    \"\"\"\n_T = TypeVar('_T', bound='QEMUMachine')\nclass QEMUMachine:\n    \"\"\"\n    A QEMU VM.\n    Use this object as a context manager to ensure\n    the QEMU process terminates::",
        "detail": "qemu.build.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.machine",
        "description": "qemu.build.python.qemu.machine.machine",
        "peekOfCode": "class QEMUMachine:\n    \"\"\"\n    A QEMU VM.\n    Use this object as a context manager to ensure\n    the QEMU process terminates::\n        with VM(binary) as vm:\n            ...\n        # vm is guaranteed to be shut down here\n    \"\"\"\n    # pylint: disable=too-many-instance-attributes, too-many-public-methods",
        "detail": "qemu.build.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.machine.machine",
        "description": "qemu.build.python.qemu.machine.machine",
        "peekOfCode": "LOG = logging.getLogger(__name__)\nclass QEMUMachineError(Exception):\n    \"\"\"\n    Exception called when an error in QEMUMachine happens.\n    \"\"\"\nclass QEMUMachineAddDeviceError(QEMUMachineError):\n    \"\"\"\n    Exception raised when a request to add a device can not be fulfilled\n    The failures are caused by limitations, lack of information or conflicting\n    requests on the QEMUMachine methods.  This exception does not represent",
        "detail": "qemu.build.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.machine.machine",
        "description": "qemu.build.python.qemu.machine.machine",
        "peekOfCode": "_T = TypeVar('_T', bound='QEMUMachine')\nclass QEMUMachine:\n    \"\"\"\n    A QEMU VM.\n    Use this object as a context manager to ensure\n    the QEMU process terminates::\n        with VM(binary) as vm:\n            ...\n        # vm is guaranteed to be shut down here\n    \"\"\"",
        "detail": "qemu.build.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "QEMUQtestProtocol",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.qtest",
        "description": "qemu.build.python.qemu.machine.qtest",
        "peekOfCode": "class QEMUQtestProtocol:\n    \"\"\"\n    QEMUQtestProtocol implements a connection to a qtest socket.\n    :param address: QEMU address, can be either a unix socket path (string)\n                    or a tuple in the form ( address, port ) for a TCP\n                    connection\n    :param sock: An existing socket can be provided as an alternative to\n                 an address. One of address or sock must be provided.\n    :param server: server mode, listens on the socket. Only meaningful\n                   in conjunction with an address and not an existing",
        "detail": "qemu.build.python.qemu.machine.qtest",
        "documentation": {}
    },
    {
        "label": "QEMUQtestMachine",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.machine.qtest",
        "description": "qemu.build.python.qemu.machine.qtest",
        "peekOfCode": "class QEMUQtestMachine(QEMUMachine):\n    \"\"\"\n    A QEMU VM, with a qtest socket available.\n    \"\"\"\n    def __init__(self,\n                 binary: str,\n                 args: Sequence[str] = (),\n                 wrapper: Sequence[str] = (),\n                 name: Optional[str] = None,\n                 base_temp_dir: str = \"/var/tmp\",",
        "detail": "qemu.build.python.qemu.machine.qtest",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.error",
        "description": "qemu.build.python.qemu.qmp.error",
        "peekOfCode": "class QMPError(Exception):\n    \"\"\"Abstract error class for all errors originating from this package.\"\"\"\nclass ProtocolError(QMPError):\n    \"\"\"\n    Abstract error class for protocol failures.\n    Semantically, these errors are generally the fault of either the\n    protocol server or as a result of a bug in this library.\n    :param error_message: Human-readable string describing the error.\n    \"\"\"\n    def __init__(self, error_message: str):",
        "detail": "qemu.build.python.qemu.qmp.error",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.error",
        "description": "qemu.build.python.qemu.qmp.error",
        "peekOfCode": "class ProtocolError(QMPError):\n    \"\"\"\n    Abstract error class for protocol failures.\n    Semantically, these errors are generally the fault of either the\n    protocol server or as a result of a bug in this library.\n    :param error_message: Human-readable string describing the error.\n    \"\"\"\n    def __init__(self, error_message: str):\n        super().__init__(error_message)\n        #: Human-readable error message, without any prefix.",
        "detail": "qemu.build.python.qemu.qmp.error",
        "documentation": {}
    },
    {
        "label": "ListenerError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.events",
        "description": "qemu.build.python.qemu.qmp.events",
        "peekOfCode": "class ListenerError(QMPError):\n    \"\"\"\n    Generic error class for `EventListener`-related problems.\n    \"\"\"\nclass EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,\n    but it can be extended to provide more rigorous control.\n    :param names:",
        "detail": "qemu.build.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "EventListener",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.events",
        "description": "qemu.build.python.qemu.qmp.events",
        "peekOfCode": "class EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,\n    but it can be extended to provide more rigorous control.\n    :param names:\n        One or more names of events to listen for.\n        When not provided, listen for ALL events.\n    :param event_filter:\n        An optional event filtering function.",
        "detail": "qemu.build.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "Events",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.events",
        "description": "qemu.build.python.qemu.qmp.events",
        "peekOfCode": "class Events:\n    \"\"\"\n    Events is a mix-in class that adds event functionality to the QMP class.\n    It's designed specifically as a mix-in for `QMPClient`, and it\n    relies upon the class it is being mixed into having a 'logger'\n    property.\n    \"\"\"\n    def __init__(self) -> None:\n        self._listeners: List[EventListener] = []\n        #: Default, all-events `EventListener`.",
        "detail": "qemu.build.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "EventNames",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.events",
        "description": "qemu.build.python.qemu.qmp.events",
        "peekOfCode": "EventNames = Union[str, Iterable[str], None]\nEventFilter = Callable[[Message], bool]\nclass ListenerError(QMPError):\n    \"\"\"\n    Generic error class for `EventListener`-related problems.\n    \"\"\"\nclass EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,",
        "detail": "qemu.build.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "EventFilter",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.events",
        "description": "qemu.build.python.qemu.qmp.events",
        "peekOfCode": "EventFilter = Callable[[Message], bool]\nclass ListenerError(QMPError):\n    \"\"\"\n    Generic error class for `EventListener`-related problems.\n    \"\"\"\nclass EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,\n    but it can be extended to provide more rigorous control.",
        "detail": "qemu.build.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "QMPBadPortError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.legacy",
        "description": "qemu.build.python.qemu.qmp.legacy",
        "peekOfCode": "class QMPBadPortError(QMPError):\n    \"\"\"\n    Unable to parse socket address: Port was non-numerical.\n    \"\"\"\nclass QEMUMonitorProtocol:\n    \"\"\"\n    Provide an API to connect to QEMU via QEMU Monitor Protocol (QMP)\n    and then allow to handle commands and events.\n    :param address:  QEMU address, can be a unix socket path (string), a tuple\n                     in the form ( address, port ) for a TCP connection, or an",
        "detail": "qemu.build.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.legacy",
        "description": "qemu.build.python.qemu.qmp.legacy",
        "peekOfCode": "class QEMUMonitorProtocol:\n    \"\"\"\n    Provide an API to connect to QEMU via QEMU Monitor Protocol (QMP)\n    and then allow to handle commands and events.\n    :param address:  QEMU address, can be a unix socket path (string), a tuple\n                     in the form ( address, port ) for a TCP connection, or an\n                     existing `socket.socket` object.\n    :param server:   Act as the socket server. (See 'accept')\n                     Not applicable when passing a socket directly.\n    :param nickname: Optional nickname used for logging.",
        "detail": "qemu.build.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPMessage",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.legacy",
        "description": "qemu.build.python.qemu.qmp.legacy",
        "peekOfCode": "QMPMessage = Dict[str, Any]\n#: QMPReturnValue is the 'return' value of a command.\nQMPReturnValue = object\n#: QMPObject is any object in a QMP message.\nQMPObject = Dict[str, object]\n# QMPMessage can be outgoing commands or incoming events/returns.\n# QMPReturnValue is usually a dict/json object, but due to QAPI's\n# 'command-returns-exceptions', it can actually be anything.\n#\n# {'return': {}} is a QMPMessage,",
        "detail": "qemu.build.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPReturnValue",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.legacy",
        "description": "qemu.build.python.qemu.qmp.legacy",
        "peekOfCode": "QMPReturnValue = object\n#: QMPObject is any object in a QMP message.\nQMPObject = Dict[str, object]\n# QMPMessage can be outgoing commands or incoming events/returns.\n# QMPReturnValue is usually a dict/json object, but due to QAPI's\n# 'command-returns-exceptions', it can actually be anything.\n#\n# {'return': {}} is a QMPMessage,\n# {} is the QMPReturnValue.\nclass QMPBadPortError(QMPError):",
        "detail": "qemu.build.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPObject",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.legacy",
        "description": "qemu.build.python.qemu.qmp.legacy",
        "peekOfCode": "QMPObject = Dict[str, object]\n# QMPMessage can be outgoing commands or incoming events/returns.\n# QMPReturnValue is usually a dict/json object, but due to QAPI's\n# 'command-returns-exceptions', it can actually be anything.\n#\n# {'return': {}} is a QMPMessage,\n# {} is the QMPReturnValue.\nclass QMPBadPortError(QMPError):\n    \"\"\"\n    Unable to parse socket address: Port was non-numerical.",
        "detail": "qemu.build.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "Message",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.message",
        "description": "qemu.build.python.qemu.qmp.message",
        "peekOfCode": "class Message(MutableMapping[str, object]):\n    \"\"\"\n    Represents a single QMP protocol message.\n    QMP uses JSON objects as its basic communicative unit; so this\n    Python object is a :py:obj:`~collections.abc.MutableMapping`. It may\n    be instantiated from either another mapping (like a `dict`), or from\n    raw `bytes` that still need to be deserialized.\n    Once instantiated, it may be treated like any other MutableMapping::\n        >>> msg = Message(b'{\"hello\": \"world\"}')\n        >>> assert msg['hello'] == 'world'",
        "detail": "qemu.build.python.qemu.qmp.message",
        "documentation": {}
    },
    {
        "label": "DeserializationError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.message",
        "description": "qemu.build.python.qemu.qmp.message",
        "peekOfCode": "class DeserializationError(ProtocolError):\n    \"\"\"\n    A QMP message was not understood as JSON.\n    When this Exception is raised, ``__cause__`` will be set to the\n    `json.JSONDecodeError` Exception, which can be interrogated for\n    further details.\n    :param error_message: Human-readable string describing the error.\n    :param raw: The raw `bytes` that prompted the failure.\n    \"\"\"\n    def __init__(self, error_message: str, raw: bytes):",
        "detail": "qemu.build.python.qemu.qmp.message",
        "documentation": {}
    },
    {
        "label": "UnexpectedTypeError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.message",
        "description": "qemu.build.python.qemu.qmp.message",
        "peekOfCode": "class UnexpectedTypeError(ProtocolError):\n    \"\"\"\n    A QMP message was JSON, but not a JSON object.\n    :param error_message: Human-readable string describing the error.\n    :param value: The deserialized JSON value that wasn't an object.\n    \"\"\"\n    def __init__(self, error_message: str, value: object):\n        super().__init__(error_message)\n        #: The JSON value that was expected to be an object.\n        self.value: object = value",
        "detail": "qemu.build.python.qemu.qmp.message",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.models",
        "description": "qemu.build.python.qemu.qmp.models",
        "peekOfCode": "class Model:\n    \"\"\"\n    Abstract data model, representing some QMP object of some kind.\n    :param raw: The raw object to be validated.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        self._raw = raw\n    def _check_key(self, key: str) -> None:",
        "detail": "qemu.build.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "Greeting",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.models",
        "description": "qemu.build.python.qemu.qmp.models",
        "peekOfCode": "class Greeting(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Server Greeting\".\n    :param raw: The raw Greeting object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'QMP' member",
        "detail": "qemu.build.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "QMPGreeting",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.models",
        "description": "qemu.build.python.qemu.qmp.models",
        "peekOfCode": "class QMPGreeting(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Server Greeting\".\n    :param raw: The raw QMPGreeting object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'version' member",
        "detail": "qemu.build.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "ErrorResponse",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.models",
        "description": "qemu.build.python.qemu.qmp.models",
        "peekOfCode": "class ErrorResponse(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Error\".\n    :param raw: The raw ErrorResponse object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'error' member",
        "detail": "qemu.build.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "ErrorInfo",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.models",
        "description": "qemu.build.python.qemu.qmp.models",
        "peekOfCode": "class ErrorInfo(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Error\".\n    :param raw: The raw ErrorInfo object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'class' member, with an underscore to avoid conflicts in Python.",
        "detail": "qemu.build.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "Runstate",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "class Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.\n    RUNNING = 2\n    #: In the process of disconnecting.\n    #: Runstate may be returned to `IDLE` by calling `disconnect()`.",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "class ConnectError(QMPError):\n    \"\"\"\n    Raised when the initial connection process has failed.\n    This Exception always wraps a \"root cause\" exception that can be\n    interrogated for additional information.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\n    def __init__(self, error_message: str, exc: Exception):\n        super().__init__(error_message)",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "StateError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "class StateError(QMPError):\n    \"\"\"\n    An API command (connect, execute, etc) was issued at an inappropriate time.\n    This error is raised when a command like\n    :py:meth:`~AsyncProtocol.connect()` is issued at an inappropriate\n    time.\n    :param error_message: Human-readable string describing the state violation.\n    :param state: The actual `Runstate` seen at the time of the violation.\n    :param required: The `Runstate` required to process this command.\n    \"\"\"",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "AsyncProtocol",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "class AsyncProtocol(Generic[T]):\n    \"\"\"\n    AsyncProtocol implements a generic async message-based protocol.\n    This protocol assumes the basic unit of information transfer between\n    client and server is a \"message\", the details of which are left up\n    to the implementation. It assumes the sending and receiving of these\n    messages is full-duplex and not necessarily correlated; i.e. it\n    supports asynchronous inbound messages.\n    It is designed to be extended by a specific protocol which provides\n    the implementations for how to read and send messages. These must be",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "require",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "def require(required_state: Runstate) -> Callable[[F], F]:\n    \"\"\"\n    Decorator: protect a method so it can only be run in a certain `Runstate`.\n    :param required_state: The `Runstate` required to invoke this method.\n    :raise StateError: When the required `Runstate` is not met.\n    \"\"\"\n    def _decorator(func: F) -> F:\n        # _decorator is the decorator that is built by calling the\n        # require() decorator factory; e.g.:\n        #",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "T = TypeVar('T')\n_U = TypeVar('_U')\n_TaskFN = Callable[[], Awaitable[None]]  # aka ``async def func() -> None``\nInternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "_U",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "_U = TypeVar('_U')\n_TaskFN = Callable[[], Awaitable[None]]  # aka ``async def func() -> None``\nInternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "_TaskFN",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "_TaskFN = Callable[[], Awaitable[None]]  # aka ``async def func() -> None``\nInternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "InternetAddrT",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "InternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "UnixAddrT",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "UnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.\n    RUNNING = 2",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "SocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.\n    RUNNING = 2\n    #: In the process of disconnecting.",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.protocol",
        "description": "qemu.build.python.qemu.qmp.protocol",
        "peekOfCode": "F = TypeVar('F', bound=Callable[..., Any])  # pylint: disable=invalid-name\n# Don't Panic.\ndef require(required_state: Runstate) -> Callable[[F], F]:\n    \"\"\"\n    Decorator: protect a method so it can only be run in a certain `Runstate`.\n    :param required_state: The `Runstate` required to invoke this method.\n    :raise StateError: When the required `Runstate` is not met.\n    \"\"\"\n    def _decorator(func: F) -> F:\n        # _decorator is the decorator that is built by calling the",
        "detail": "qemu.build.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "_WrappedProtocolError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class _WrappedProtocolError(ProtocolError):\n    \"\"\"\n    Abstract exception class for Protocol errors that wrap an Exception.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\n    def __init__(self, error_message: str, exc: Exception):\n        super().__init__(error_message)\n        self.exc = exc\n    def __str__(self) -> str:",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "GreetingError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class GreetingError(_WrappedProtocolError):\n    \"\"\"\n    An exception occurred during the Greeting phase.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\nclass NegotiationError(_WrappedProtocolError):\n    \"\"\"\n    An exception occurred during the Negotiation phase.\n    :param error_message: Human-readable string describing the error.",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "NegotiationError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class NegotiationError(_WrappedProtocolError):\n    \"\"\"\n    An exception occurred during the Negotiation phase.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\nclass ExecuteError(QMPError):\n    \"\"\"\n    Exception raised by `QMPClient.execute()` on RPC failure.\n    :param error_response: The RPC error response object.",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class ExecuteError(QMPError):\n    \"\"\"\n    Exception raised by `QMPClient.execute()` on RPC failure.\n    :param error_response: The RPC error response object.\n    :param sent: The sent RPC message that caused the failure.\n    :param received: The raw RPC error reply received.\n    \"\"\"\n    def __init__(self, error_response: ErrorResponse,\n                 sent: Message, received: Message):\n        super().__init__(error_response.error.desc)",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "ExecInterruptedError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class ExecInterruptedError(QMPError):\n    \"\"\"\n    Exception raised by `execute()` (et al) when an RPC is interrupted.\n    This error is raised when an `execute()` statement could not be\n    completed.  This can occur because the connection itself was\n    terminated before a reply was received.\n    The true cause of the interruption will be available via `disconnect()`.\n    \"\"\"\nclass _MsgProtocolError(ProtocolError):\n    \"\"\"",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "_MsgProtocolError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class _MsgProtocolError(ProtocolError):\n    \"\"\"\n    Abstract error class for protocol errors that have a `Message` object.\n    This Exception class is used for protocol errors where the `Message`\n    was mechanically understood, but was found to be inappropriate or\n    malformed.\n    :param error_message: Human-readable string describing the error.\n    :param msg: The QMP `Message` that caused the error.\n    \"\"\"\n    def __init__(self, error_message: str, msg: Message):",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "ServerParseError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class ServerParseError(_MsgProtocolError):\n    \"\"\"\n    The Server sent a `Message` indicating parsing failure.\n    i.e. A reply has arrived from the server, but it is missing the \"ID\"\n    field, indicating a parsing error.\n    :param error_message: Human-readable string describing the error.\n    :param msg: The QMP `Message` that caused the error.\n    \"\"\"\nclass BadReplyError(_MsgProtocolError):\n    \"\"\"",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "BadReplyError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class BadReplyError(_MsgProtocolError):\n    \"\"\"\n    An execution reply was successfully routed, but not understood.\n    If a QMP message is received with an 'id' field to allow it to be\n    routed, but is otherwise malformed, this exception will be raised.\n    A reply message is malformed if it is missing either the 'return' or\n    'error' keys, or if the 'error' value has missing keys or members of\n    the wrong type.\n    :param error_message: Human-readable string describing the error.\n    :param msg: The malformed reply that was received.",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "QMPClient",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_client",
        "description": "qemu.build.python.qemu.qmp.qmp_client",
        "peekOfCode": "class QMPClient(AsyncProtocol[Message], Events):\n    \"\"\"\n    Implements a QMP client connection.\n    QMP can be used to establish a connection as either the transport\n    client or server, though this class always acts as the QMP client.\n    :param name: Optional nickname for the connection, used for logging.\n    Basic script-style usage looks like this::\n      qmp = QMPClient('my_virtual_machine_name')\n      await qmp.connect(('127.0.0.1', 1234))\n      ...",
        "detail": "qemu.build.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "QMPCompleter",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class QMPCompleter:\n    \"\"\"\n    QMPCompleter provides a readline library tab-complete behavior.\n    \"\"\"\n    # NB: Python 3.9+ will probably allow us to subclass list[str] directly,\n    # but pylint as of today does not know that List[str] is simply 'list'.\n    def __init__(self) -> None:\n        self._matches: List[str] = []\n    def append(self, value: str) -> None:\n        \"\"\"Append a new valid completion to the list of possibilities.\"\"\"",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "QMPShellError",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class QMPShellError(QMPError):\n    \"\"\"\n    QMP Shell Base error class.\n    \"\"\"\nclass FuzzyJSON(ast.NodeTransformer):\n    \"\"\"\n    This extension of ast.NodeTransformer filters literal \"true/false/null\"\n    values in a Python AST and replaces them by proper \"True/False/None\" values\n    that Python can properly evaluate.\n    \"\"\"",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "FuzzyJSON",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class FuzzyJSON(ast.NodeTransformer):\n    \"\"\"\n    This extension of ast.NodeTransformer filters literal \"true/false/null\"\n    values in a Python AST and replaces them by proper \"True/False/None\" values\n    that Python can properly evaluate.\n    \"\"\"\n    @classmethod\n    def visit_Name(cls,  # pylint: disable=invalid-name\n                   node: ast.Name) -> ast.AST:\n        \"\"\"",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "QMPShell",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class QMPShell(QEMUMonitorProtocol):\n    \"\"\"\n    QMPShell provides a basic readline-based QMP shell.\n    :param address: Address of the QMP server.\n    :param pretty: Pretty-print QMP messages.\n    :param verbose: Echo outgoing QMP messages to console.\n    \"\"\"\n    def __init__(self, address: SocketAddrT,\n                 pretty: bool = False,\n                 verbose: bool = False,",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "HMPShell",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class HMPShell(QMPShell):\n    \"\"\"\n    HMPShell provides a basic readline-based HMP shell, tunnelled via QMP.\n    :param address: Address of the QMP server.\n    :param pretty: Pretty-print QMP messages.\n    :param verbose: Echo outgoing QMP messages to console.\n    \"\"\"\n    def __init__(self, address: SocketAddrT,\n                 pretty: bool = False,\n                 verbose: bool = False,",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "die",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "def die(msg: str) -> NoReturn:\n    \"\"\"Write an error to stderr, then exit with a return code of 1.\"\"\"\n    sys.stderr.write('ERROR: %s\\n' % msg)\n    sys.exit(1)\ndef main() -> None:\n    \"\"\"\n    qmp-shell entry point: parse command line arguments and start the REPL.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-H', '--hmp', action='store_true',",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    qmp-shell entry point: parse command line arguments and start the REPL.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-H', '--hmp', action='store_true',\n                        help='Use HMP interface')\n    parser.add_argument('-N', '--skip-negotiation', action='store_true',\n                        help='Skip negotiate (for qemu-ga)')\n    parser.add_argument('-v', '--verbose', action='store_true',",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "main_wrap",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "def main_wrap() -> None:\n    \"\"\"\n    qmp-shell-wrap entry point: parse command line arguments and\n    start the REPL.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-H', '--hmp', action='store_true',\n                        help='Use HMP interface')\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='Verbose (echo commands sent and received)')",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.qmp_shell",
        "description": "qemu.build.python.qemu.qmp.qmp_shell",
        "peekOfCode": "LOG = logging.getLogger(__name__)\nclass QMPCompleter:\n    \"\"\"\n    QMPCompleter provides a readline library tab-complete behavior.\n    \"\"\"\n    # NB: Python 3.9+ will probably allow us to subclass list[str] directly,\n    # but pylint as of today does not know that List[str] is simply 'list'.\n    def __init__(self) -> None:\n        self._matches: List[str] = []\n    def append(self, value: str) -> None:",
        "detail": "qemu.build.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "App",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class App(QMPClient):\n    \"\"\"\n    Implements the QMP TUI.\n    Initializes the widgets and starts the urwid event loop.\n    :param address:\n        Address of the server to connect to.\n    :param num_retries:\n        The number of times to retry before stopping to reconnect.\n    :param retry_delay:\n        The delay(sec) before each retry",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "StatusBar",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class StatusBar(urwid.Text):\n    \"\"\"\n    A simple statusbar modelled using the Text widget. The status can be\n    set using the set_text function. All text set is aligned to right.\n    :param text: Initial text to be displayed. Default is empty str.\n    \"\"\"\n    def __init__(self, text: str = ''):\n        super().__init__(text, align='right')\nclass Editor(urwid_readline.ReadlineEdit):\n    \"\"\"",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "Editor",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class Editor(urwid_readline.ReadlineEdit):\n    \"\"\"\n    A simple editor modelled using the urwid_readline.ReadlineEdit widget.\n    Mimcs GNU readline shortcuts and provides history support.\n    The readline shortcuts can be found below:\n    https://github.com/rr-/urwid_readline#features\n    Along with the readline features, this editor also has support for\n    history. Pressing the 'up'/'down' switches between the prev/next messages\n    available in the history.\n    Currently there is no support to save the history to a file. The history of",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "EditorWidget",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class EditorWidget(urwid.Filler):\n    \"\"\"\n    Wrapper around the editor widget.\n    The Editor is a flow widget and has to wrapped inside a box widget.\n    This class wraps the Editor inside filler widget.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        super().__init__(Editor(parent), valign='top')\nclass HistoryBox(urwid.ListBox):",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "HistoryBox",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class HistoryBox(urwid.ListBox):\n    \"\"\"\n    This widget is modelled using the ListBox widget, contains the list of\n    all messages both QMP messages and log messages to be shown in the TUI.\n    The messages are urwid.Text widgets. On every append of a message, the\n    focus is shifted to the last appended message.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        self.parent = parent",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "HistoryWindow",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class HistoryWindow(urwid.Frame):\n    \"\"\"\n    This window composes the HistoryBox and EditorWidget in a horizontal split.\n    By default the first focus is given to the history box.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        self.parent = parent\n        self.editor_widget = EditorWidget(parent)\n        self.editor = urwid.LineBox(self.editor_widget)",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "Window",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class Window(urwid.Frame):\n    \"\"\"\n    This window is the top most widget of the TUI and will contain other\n    windows. Each child of this widget is responsible for displaying a specific\n    functionality.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        self.parent = parent\n        footer = StatusBar()",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "TUILogHandler",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class TUILogHandler(Handler):\n    \"\"\"\n    This handler routes all the log messages to the TUI screen.\n    It is installed to the root logger to so that the log message from all\n    libraries begin used is routed to the screen.\n    :param tui: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, tui: App) -> None:\n        super().__init__()\n        self.tui = tui",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "format_json",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "def format_json(msg: str) -> str:\n    \"\"\"\n    Formats valid/invalid multi-line JSON message into a single-line message.\n    Formatting is first tried using the standard json module. If that fails\n    due to an decoding error then a simple string manipulation is done to\n    achieve a single line JSON string.\n    Converting into single line is more aesthetically pleasing when looking\n    along with error messages.\n    Eg:\n    Input:",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "has_handler_type",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "def has_handler_type(logger: logging.Logger,\n                     handler_type: Type[Handler]) -> bool:\n    \"\"\"\n    The Logger class has no interface to check if a certain type of handler is\n    installed or not. So we provide an interface to do so.\n    :param logger:\n        Logger object\n    :param handler_type:\n        The type of the handler to be checked.\n    :return: returns True if handler of type `handler_type`.",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    Driver of the whole script, parses arguments, initialize the TUI and\n    the logger.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='QMP TUI')\n    parser.add_argument('qmp_server', help='Address of the QMP server. '\n                        'Format <UNIX socket path | TCP addr:port>')\n    parser.add_argument('--num-retries', type=int, default=10,\n                        help='Number of times to reconnect before giving up.')",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "palette",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.qmp_tui",
        "description": "qemu.build.python.qemu.qmp.qmp_tui",
        "peekOfCode": "palette = [\n    (Token.Punctuation, '', '', '', 'h15,bold', 'g7'),\n    (Token.Text, '', '', '', '', 'g7'),\n    (Token.Name.Tag, '', '', '', 'bold,#f88', 'g7'),\n    (Token.Literal.Number.Integer, '', '', '', '#fa0', 'g7'),\n    (Token.Literal.String.Double, '', '', '', '#6f6', 'g7'),\n    (Token.Keyword.Constant, '', '', '', '#6af', 'g7'),\n    ('DEBUG', '', '', '', '#ddf', 'g7'),\n    ('INFO', '', '', '', 'g100', 'g7'),\n    ('WARNING', '', '', '', '#ff6', 'g7'),",
        "detail": "qemu.build.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "upper_half",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "def upper_half(func: T) -> T:\n    \"\"\"\n    Do-nothing decorator that annotates a method as an \"upper-half\" method.\n    These methods must not call bottom-half functions directly, but can\n    schedule them to run.\n    \"\"\"\n    return func\ndef bottom_half(func: T) -> T:\n    \"\"\"\n    Do-nothing decorator that annotates a method as a \"bottom-half\" method.",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "bottom_half",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "def bottom_half(func: T) -> T:\n    \"\"\"\n    Do-nothing decorator that annotates a method as a \"bottom-half\" method.\n    These methods must take great care to handle their own exceptions whenever\n    possible. If they go unhandled, they will cause termination of the loop.\n    These methods do not, in general, have the ability to directly\n    report information to a callers context and will usually be\n    collected as a Task result instead.\n    They must not call upper-half functions directly.\n    \"\"\"",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "create_task",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "def create_task(coro: Coroutine[Any, Any, T],\n                loop: Optional[asyncio.AbstractEventLoop] = None\n                ) -> 'asyncio.Future[T]':\n    \"\"\"\n    Python 3.6-compatible `asyncio.create_task` wrapper.\n    :param coro: The coroutine to execute in a task.\n    :param loop: Optionally, the loop to create the task in.\n    :return: An `asyncio.Future` object.\n    \"\"\"\n    if sys.version_info >= (3, 7):",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "is_closing",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "def is_closing(writer: asyncio.StreamWriter) -> bool:\n    \"\"\"\n    Python 3.6-compatible `asyncio.StreamWriter.is_closing` wrapper.\n    :param writer: The `asyncio.StreamWriter` object.\n    :return: `True` if the writer is closing, or closed.\n    \"\"\"\n    if sys.version_info >= (3, 7):\n        return writer.is_closing()\n    # Python 3.6:\n    transport = writer.transport",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "asyncio_run",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "def asyncio_run(coro: Coroutine[Any, Any, T], *, debug: bool = False) -> T:\n    \"\"\"\n    Python 3.6-compatible `asyncio.run` wrapper.\n    :param coro: A coroutine to execute now.\n    :return: The return value from the coroutine.\n    \"\"\"\n    if sys.version_info >= (3, 7):\n        return asyncio.run(coro, debug=debug)\n    # Python 3.6\n    loop = asyncio.get_event_loop()",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "exception_summary",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "def exception_summary(exc: BaseException) -> str:\n    \"\"\"\n    Return a summary string of an arbitrary exception.\n    It will be of the form \"ExceptionType: Error Message\", if the error\n    string is non-empty, and just \"ExceptionType\" otherwise.\n    \"\"\"\n    name = type(exc).__qualname__\n    smod = type(exc).__module__\n    if smod not in (\"__main__\", \"builtins\"):\n        name = smod + '.' + name",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "pretty_traceback",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "def pretty_traceback(prefix: str = \"  | \") -> str:\n    \"\"\"\n    Formats the current traceback, indented to provide visual distinction.\n    This is useful for printing a traceback within a traceback for\n    debugging purposes when encapsulating errors to deliver them up the\n    stack; when those errors are printed, this helps provide a nice\n    visual grouping to quickly identify the parts of the error that\n    belong to the inner exception.\n    :param prefix: The prefix to append to each line of the traceback.\n    :return: A string, formatted something like the following::",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.qmp.util",
        "description": "qemu.build.python.qemu.qmp.util",
        "peekOfCode": "T = TypeVar('T')\n# --------------------------\n# Section: Utility Functions\n# --------------------------\nasync def flush(writer: asyncio.StreamWriter) -> None:\n    \"\"\"\n    Utility function to ensure a StreamWriter is *fully* drained.\n    `asyncio.StreamWriter.drain` only promises we will return to below\n    the \"high-water mark\". This function ensures we flush the entire\n    buffer -- by setting the high water mark to 0 and then calling",
        "detail": "qemu.build.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "list_accel",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.utils.accel",
        "description": "qemu.build.python.qemu.utils.accel",
        "peekOfCode": "def list_accel(qemu_bin: str) -> List[str]:\n    \"\"\"\n    List accelerators enabled in the QEMU binary.\n    @param qemu_bin (str): path to the QEMU binary.\n    @raise Exception: if failed to run ``qemu -accel help``\n    @return a list of accelerator names.\n    \"\"\"\n    if not qemu_bin:\n        return []\n    try:",
        "detail": "qemu.build.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "kvm_available",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.utils.accel",
        "description": "qemu.build.python.qemu.utils.accel",
        "peekOfCode": "def kvm_available(target_arch: Optional[str] = None,\n                  qemu_bin: Optional[str] = None) -> bool:\n    \"\"\"\n    Check if KVM is available using the following heuristic:\n      - Kernel module is present in the host;\n      - Target and host arches don't mismatch;\n      - KVM is enabled in the QEMU binary.\n    @param target_arch (str): target architecture\n    @param qemu_bin (str): path to the QEMU binary\n    @return True if kvm is available, otherwise False.",
        "detail": "qemu.build.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "tcg_available",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.utils.accel",
        "description": "qemu.build.python.qemu.utils.accel",
        "peekOfCode": "def tcg_available(qemu_bin: str) -> bool:\n    \"\"\"\n    Check if TCG is available.\n    @param qemu_bin (str): path to the QEMU binary\n    \"\"\"\n    return 'tcg' in list_accel(qemu_bin)",
        "detail": "qemu.build.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.utils.accel",
        "description": "qemu.build.python.qemu.utils.accel",
        "peekOfCode": "LOG = logging.getLogger(__name__)\n# Mapping host architecture to any additional architectures it can\n# support which often includes its 32 bit cousin.\nADDITIONAL_ARCHES = {\n    \"x86_64\": \"i386\",\n    \"aarch64\": \"armhf\",\n    \"ppc64le\": \"ppc64\",\n}\ndef list_accel(qemu_bin: str) -> List[str]:\n    \"\"\"",
        "detail": "qemu.build.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "ADDITIONAL_ARCHES",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.utils.accel",
        "description": "qemu.build.python.qemu.utils.accel",
        "peekOfCode": "ADDITIONAL_ARCHES = {\n    \"x86_64\": \"i386\",\n    \"aarch64\": \"armhf\",\n    \"ppc64le\": \"ppc64\",\n}\ndef list_accel(qemu_bin: str) -> List[str]:\n    \"\"\"\n    List accelerators enabled in the QEMU binary.\n    @param qemu_bin (str): path to the QEMU binary.\n    @raise Exception: if failed to run ``qemu -accel help``",
        "detail": "qemu.build.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "QemuGuestAgent",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qemu_ga_client",
        "description": "qemu.build.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "class QemuGuestAgent(QEMUMonitorProtocol):\n    def __getattr__(self, name: str) -> Callable[..., Any]:\n        def wrapper(**kwds: object) -> object:\n            return self.cmd('guest-' + name.replace('_', '-'), **kwds)\n        return wrapper\nclass QemuGuestAgentClient:\n    def __init__(self, address: SocketAddrT):\n        self.qga = QemuGuestAgent(address)\n        self.qga.connect(negotiate=False)\n    def sync(self, timeout: Optional[float] = 3) -> None:",
        "detail": "qemu.build.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "QemuGuestAgentClient",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qemu_ga_client",
        "description": "qemu.build.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "class QemuGuestAgentClient:\n    def __init__(self, address: SocketAddrT):\n        self.qga = QemuGuestAgent(address)\n        self.qga.connect(negotiate=False)\n    def sync(self, timeout: Optional[float] = 3) -> None:\n        # Avoid being blocked forever\n        if not self.ping(timeout):\n            raise EnvironmentError('Agent seems not alive')\n        uid = random.randint(0, (1 << 32) - 1)\n        while True:",
        "detail": "qemu.build.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "send_command",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.utils.qemu_ga_client",
        "description": "qemu.build.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "def send_command(address: str, cmd: str, args: Sequence[str]) -> None:\n    if not os.path.exists(address):\n        print(f\"'{address}' not found. (Is QEMU running?)\")\n        sys.exit(1)\n    if cmd not in commands:\n        print('Invalid command: ' + cmd)\n        print('Available commands: ' + ', '.join(commands))\n        sys.exit(1)\n    try:\n        client = QemuGuestAgentClient(address)",
        "detail": "qemu.build.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.utils.qemu_ga_client",
        "description": "qemu.build.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "def main() -> None:\n    address = os.environ.get('QGA_CLIENT_ADDRESS')\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--address', action='store',\n                        default=address,\n                        help='Specify a ip:port pair or a unix socket path')\n    parser.add_argument('command', choices=commands)\n    parser.add_argument('args', nargs='*')\n    args = parser.parse_args()\n    if args.address is None:",
        "detail": "qemu.build.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "_cmd_powerdown",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.utils.qemu_ga_client",
        "description": "qemu.build.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "_cmd_powerdown = _cmd_shutdown\ndef _cmd_halt(client: QemuGuestAgentClient, args: Sequence[str]) -> None:\n    assert not args\n    client.shutdown('halt')\ndef _cmd_reboot(client: QemuGuestAgentClient, args: Sequence[str]) -> None:\n    assert not args\n    client.shutdown('reboot')\ncommands = [m.replace('_cmd_', '') for m in dir() if '_cmd_' in m]\ndef send_command(address: str, cmd: str, args: Sequence[str]) -> None:\n    if not os.path.exists(address):",
        "detail": "qemu.build.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "commands",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.utils.qemu_ga_client",
        "description": "qemu.build.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "commands = [m.replace('_cmd_', '') for m in dir() if '_cmd_' in m]\ndef send_command(address: str, cmd: str, args: Sequence[str]) -> None:\n    if not os.path.exists(address):\n        print(f\"'{address}' not found. (Is QEMU running?)\")\n        sys.exit(1)\n    if cmd not in commands:\n        print('Invalid command: ' + cmd)\n        print('Available commands: ' + ', '.join(commands))\n        sys.exit(1)\n    try:",
        "detail": "qemu.build.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "QOMSet",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qom",
        "description": "qemu.build.python.qemu.utils.qom",
        "peekOfCode": "class QOMSet(QOMCommand):\n    \"\"\"\n    QOM Command - Set a property to a given value.\n    usage: qom-set [-h] [--socket SOCKET] <path>.<property> <value>\n    Set a QOM property value\n    positional arguments:\n      <path>.<property>     QOM path and property, separated by a period '.'\n      <value>               new QOM property value\n    optional arguments:\n      -h, --help            show this help message and exit",
        "detail": "qemu.build.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "QOMGet",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qom",
        "description": "qemu.build.python.qemu.utils.qom",
        "peekOfCode": "class QOMGet(QOMCommand):\n    \"\"\"\n    QOM Command - Get a property's current value.\n    usage: qom-get [-h] [--socket SOCKET] <path>.<property>\n    Get a QOM property value\n    positional arguments:\n      <path>.<property>     QOM path and property, separated by a period '.'\n    optional arguments:\n      -h, --help            show this help message and exit\n      --socket SOCKET, -s SOCKET",
        "detail": "qemu.build.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "QOMList",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qom",
        "description": "qemu.build.python.qemu.utils.qom",
        "peekOfCode": "class QOMList(QOMCommand):\n    \"\"\"\n    QOM Command - List the properties at a given path.\n    usage: qom-list [-h] [--socket SOCKET] <path>\n    List QOM properties at a given path\n    positional arguments:\n      <path>                QOM path\n    optional arguments:\n      -h, --help            show this help message and exit\n      --socket SOCKET, -s SOCKET",
        "detail": "qemu.build.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "QOMTree",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qom",
        "description": "qemu.build.python.qemu.utils.qom",
        "peekOfCode": "class QOMTree(QOMCommand):\n    \"\"\"\n    QOM Command - Show the full tree below a given path.\n    usage: qom-tree [-h] [--socket SOCKET] [<path>]\n    Show QOM tree from a given path\n    positional arguments:\n      <path>                QOM path\n    optional arguments:\n      -h, --help            show this help message and exit\n      --socket SOCKET, -s SOCKET",
        "detail": "qemu.build.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.python.qemu.utils.qom",
        "description": "qemu.build.python.qemu.utils.qom",
        "peekOfCode": "def main() -> int:\n    \"\"\"QOM script main entry point.\"\"\"\n    parser = argparse.ArgumentParser(\n        description='Query and manipulate QOM data'\n    )\n    subparsers = parser.add_subparsers(\n        title='QOM commands',\n        dest='command'\n    )\n    for command in QOMCommand.__subclasses__():",
        "detail": "qemu.build.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "ObjectPropertyInfo",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qom_common",
        "description": "qemu.build.python.qemu.utils.qom_common",
        "peekOfCode": "class ObjectPropertyInfo:\n    \"\"\"\n    Represents the return type from e.g. qom-list.\n    \"\"\"\n    def __init__(self, name: str, type_: str,\n                 description: Optional[str] = None,\n                 default_value: Optional[object] = None):\n        self.name = name\n        self.type = type_\n        self.description = description",
        "detail": "qemu.build.python.qemu.utils.qom_common",
        "documentation": {}
    },
    {
        "label": "QOMCommand",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qom_common",
        "description": "qemu.build.python.qemu.utils.qom_common",
        "peekOfCode": "class QOMCommand:\n    \"\"\"\n    Represents a QOM sub-command.\n    :param args: Parsed arguments, as returned from parser.parse_args.\n    \"\"\"\n    name: str\n    help: str\n    def __init__(self, args: argparse.Namespace):\n        if args.socket is None:\n            raise QMPError(\"No QMP socket path or address given\")",
        "detail": "qemu.build.python.qemu.utils.qom_common",
        "documentation": {}
    },
    {
        "label": "CommandT",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.utils.qom_common",
        "description": "qemu.build.python.qemu.utils.qom_common",
        "peekOfCode": "CommandT = TypeVar('CommandT', bound='QOMCommand')\nclass QOMCommand:\n    \"\"\"\n    Represents a QOM sub-command.\n    :param args: Parsed arguments, as returned from parser.parse_args.\n    \"\"\"\n    name: str\n    help: str\n    def __init__(self, args: argparse.Namespace):\n        if args.socket is None:",
        "detail": "qemu.build.python.qemu.utils.qom_common",
        "documentation": {}
    },
    {
        "label": "QOMFuse",
        "kind": 6,
        "importPath": "qemu.build.python.qemu.utils.qom_fuse",
        "description": "qemu.build.python.qemu.utils.qom_fuse",
        "peekOfCode": "class QOMFuse(QOMCommand, Operations):\n    \"\"\"\n    QOMFuse implements both fuse.Operations and QOMCommand.\n    Operations implements the FS, and QOMCommand implements the CLI command.\n    \"\"\"\n    name = 'fuse'\n    help = 'Mount a QOM tree as a FUSE filesystem'\n    fuse: FUSE\n    @classmethod\n    def configure_parser(cls, parser: argparse.ArgumentParser) -> None:",
        "detail": "qemu.build.python.qemu.utils.qom_fuse",
        "documentation": {}
    },
    {
        "label": "fuse.fuse_python_api",
        "kind": 5,
        "importPath": "qemu.build.python.qemu.utils.qom_fuse",
        "description": "qemu.build.python.qemu.utils.qom_fuse",
        "peekOfCode": "fuse.fuse_python_api = (0, 2)\nclass QOMFuse(QOMCommand, Operations):\n    \"\"\"\n    QOMFuse implements both fuse.Operations and QOMCommand.\n    Operations implements the FS, and QOMCommand implements the CLI command.\n    \"\"\"\n    name = 'fuse'\n    help = 'Mount a QOM tree as a FUSE filesystem'\n    fuse: FUSE\n    @classmethod",
        "detail": "qemu.build.python.qemu.utils.qom_fuse",
        "documentation": {}
    },
    {
        "label": "Ouch",
        "kind": 6,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "class Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual\n    environment when invoked from inside of an existing virtual\n    environment by including packages from the parent.  Also,\n    \"ensurepip\" is replaced if possible with just recreating pip's\n    console_scripts inside the virtual environment.",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "QemuEnvBuilder",
        "kind": 6,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "class QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual\n    environment when invoked from inside of an existing virtual\n    environment by including packages from the parent.  Also,\n    \"ensurepip\" is replaced if possible with just recreating pip's\n    console_scripts inside the virtual environment.\n    Parameters for base class init:\n      - system_site_packages: bool = False",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "inside_a_venv",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def inside_a_venv() -> bool:\n    \"\"\"Returns True if it is executed inside of a virtual environment.\"\"\"\n    return sys.prefix != sys.base_prefix\nclass Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual\n    environment when invoked from inside of an existing virtual",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "need_ensurepip",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def need_ensurepip() -> bool:\n    \"\"\"\n    Tests for the presence of setuptools and pip.\n    :return: `True` if we do not detect both packages.\n    \"\"\"\n    # Don't try to actually import them, it's fraught with danger:\n    # https://github.com/pypa/setuptools/issues/2993\n    if find_spec(\"setuptools\") and find_spec(\"pip\"):\n        return False\n    return True",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "check_ensurepip",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def check_ensurepip() -> None:\n    \"\"\"\n    Check that we have ensurepip.\n    Raise a fatal exception with a helpful hint if it isn't available.\n    \"\"\"\n    if not find_spec(\"ensurepip\"):\n        msg = (\n            \"Python's ensurepip module is not found.\\n\"\n            \"It's normally part of the Python standard library, \"\n            \"maybe your distribution packages it separately?\\n\"",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "make_venv",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def make_venv(  # pylint: disable=too-many-arguments\n    env_dir: Union[str, Path],\n    system_site_packages: bool = False,\n    clear: bool = True,\n    symlinks: Optional[bool] = None,\n    with_pip: bool = True,\n) -> None:\n    \"\"\"\n    Create a venv using `QemuEnvBuilder`.\n    This is analogous to the `venv.create` module-level convenience",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "generate_console_scripts",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def generate_console_scripts(\n    packages: Sequence[str],\n    python_path: Optional[str] = None,\n    bin_path: Optional[str] = None,\n) -> None:\n    \"\"\"\n    Generate script shims for console_script entry points in @packages.\n    \"\"\"\n    if python_path is None:\n        python_path = sys.executable",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "pkgname_from_depspec",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def pkgname_from_depspec(dep_spec: str) -> str:\n    \"\"\"\n    Parse package name out of a PEP-508 depspec.\n    See https://peps.python.org/pep-0508/#names\n    \"\"\"\n    match = re.match(\n        r\"^([A-Z0-9]([A-Z0-9._-]*[A-Z0-9])?)\", dep_spec, re.IGNORECASE\n    )\n    if not match:\n        raise ValueError(",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "diagnose",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def diagnose(\n    dep_spec: str,\n    online: bool,\n    wheels_dir: Optional[Union[str, Path]],\n    prog: Optional[str],\n) -> Tuple[str, bool]:\n    \"\"\"\n    Offer a summary to the user as to why a package failed to be installed.\n    :param dep_spec: The package we tried to ensure, e.g. 'meson>=0.61.5'\n    :param online: Did we allow PyPI access?",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "pip_install",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def pip_install(\n    args: Sequence[str],\n    online: bool = False,\n    wheels_dir: Optional[Union[str, Path]] = None,\n) -> None:\n    \"\"\"\n    Use pip to install a package or package(s) as specified in @args.\n    \"\"\"\n    loud = bool(\n        os.environ.get(\"DEBUG\")",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "ensure_group",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def ensure_group(\n    file: str,\n    groups: Sequence[str],\n    online: bool = False,\n    wheels_dir: Optional[Union[str, Path]] = None,\n) -> None:\n    \"\"\"\n    Use pip to ensure we have the package specified by @dep_specs.\n    If the package is already installed, do nothing. If online and\n    wheels_dir are both provided, prefer packages found in wheels_dir",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "post_venv_setup",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def post_venv_setup() -> None:\n    \"\"\"\n    This is intended to be run *inside the venv* after it is created.\n    \"\"\"\n    logger.debug(\"post_venv_setup()\")\n    # Generate a 'pip' script so the venv is usable in a normal\n    # way from the CLI. This only happens when we inherited pip from a\n    # parent/system-site and haven't run ensurepip in some way.\n    generate_console_scripts([\"pip\"])\ndef _add_create_subcommand(subparsers: Any) -> None:",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "def main() -> int:\n    \"\"\"CLI interface to make_qemu_venv. See module docstring.\"\"\"\n    if os.environ.get(\"DEBUG\") or os.environ.get(\"GITLAB_CI\"):\n        # You're welcome.\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        if os.environ.get(\"V\"):\n            logging.basicConfig(level=logging.INFO)\n    parser = argparse.ArgumentParser(\n        prog=\"mkvenv\",",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "HAVE_DISTLIB",
        "kind": 5,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "HAVE_DISTLIB = True\ntry:\n    import distlib.scripts\n    import distlib.version\nexcept ImportError:\n    try:\n        # Reach into pip's cookie jar.  pylint and flake8 don't understand\n        # that these imports will be used via distlib.xxx.\n        from pip._vendor import distlib\n        import pip._vendor.distlib.scripts  # noqa, pylint: disable=unused-import",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "HAVE_TOMLLIB",
        "kind": 5,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "HAVE_TOMLLIB = True\ntry:\n    import tomllib\nexcept ImportError:\n    try:\n        import tomli as tomllib\n    except ImportError:\n        HAVE_TOMLLIB = False\n# Do not add any mandatory dependencies from outside the stdlib:\n# This script *must* be usable standalone!",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "DirType",
        "kind": 5,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "DirType = Union[str, bytes, \"os.PathLike[str]\", \"os.PathLike[bytes]\"]\nlogger = logging.getLogger(\"mkvenv\")\ndef inside_a_venv() -> bool:\n    \"\"\"Returns True if it is executed inside of a virtual environment.\"\"\"\n    return sys.prefix != sys.base_prefix\nclass Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.build.python.scripts.mkvenv",
        "description": "qemu.build.python.scripts.mkvenv",
        "peekOfCode": "logger = logging.getLogger(\"mkvenv\")\ndef inside_a_venv() -> bool:\n    \"\"\"Returns True if it is executed inside of a virtual environment.\"\"\"\n    return sys.prefix != sys.base_prefix\nclass Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual",
        "detail": "qemu.build.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.python.scripts.vendor",
        "description": "qemu.build.python.scripts.vendor",
        "peekOfCode": "def main() -> int:\n    \"\"\"Run the vendoring utility. See module-level docstring.\"\"\"\n    loud = False\n    if os.environ.get(\"DEBUG\") or os.environ.get(\"V\"):\n        loud = True\n    # No options or anything for now, but I guess\n    # you'll figure that out when you run --help.\n    parser = argparse.ArgumentParser(\n        prog=\"vendor\",\n        description=\"QEMU python vendoring utility\",",
        "detail": "qemu.build.python.scripts.vendor",
        "documentation": {}
    },
    {
        "label": "NullProtocol",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class NullProtocol(AsyncProtocol[None]):\n    \"\"\"\n    NullProtocol is a test mockup of an AsyncProtocol implementation.\n    It adds a fake_session instance variable that enables a code path\n    that bypasses the actual connection logic, but still allows the\n    reader/writers to start.\n    Because the message type is defined as None, an asyncio.Event named\n    'trigger_input' is created that prohibits the reader from\n    incessantly being able to yield None; this event can be poked to\n    simulate an incoming message.",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "LineProtocol",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class LineProtocol(AsyncProtocol[str]):\n    def __init__(self, name=None):\n        super().__init__(name)\n        self.rx_history = []\n    async def _do_recv(self) -> str:\n        raw = await self._readline()\n        msg = raw.decode()\n        self.rx_history.append(msg)\n        return msg\n    def _do_send(self, msg: str) -> None:",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "Smoke",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class Smoke(avocado.Test):\n    def setUp(self):\n        self.proto = NullProtocol()\n    def test__repr__(self):\n        self.assertEqual(\n            repr(self.proto),\n            \"<NullProtocol runstate=IDLE>\"\n        )\n    def testRunstate(self):\n        self.assertEqual(",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "TestBase",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class TestBase(avocado.Test):\n    def setUp(self):\n        self.proto = NullProtocol(type(self).__name__)\n        self.assertEqual(self.proto.runstate, Runstate.IDLE)\n        self.runstate_watcher = None\n    def tearDown(self):\n        self.assertEqual(self.proto.runstate, Runstate.IDLE)\n    async def _asyncSetUp(self):\n        pass\n    async def _asyncTearDown(self):",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class State(TestBase):\n    @TestBase.async_test\n    async def testSuperfluousDisconnect(self):\n        \"\"\"\n        Test calling disconnect() while already disconnected.\n        \"\"\"\n        await self._watch_runstates(\n            Runstate.DISCONNECTING,\n            Runstate.IDLE,\n        )",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "Connect",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class Connect(TestBase):\n    \"\"\"\n    Tests primarily related to calling Connect().\n    \"\"\"\n    async def _bad_connection(self, family: str):\n        assert family in ('INET', 'UNIX')\n        if family == 'INET':\n            await self.proto.connect(('127.0.0.1', 0))\n        elif family == 'UNIX':\n            await self.proto.connect('/dev/null')",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "Accept",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class Accept(Connect):\n    \"\"\"\n    All of the same tests as Connect, but using the accept() interface.\n    \"\"\"\n    async def _bad_connection(self, family: str):\n        assert family in ('INET', 'UNIX')\n        if family == 'INET':\n            await self.proto.start_server_and_accept(('example.com', 1))\n        elif family == 'UNIX':\n            await self.proto.start_server_and_accept('/dev/null')",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "FakeSession",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class FakeSession(TestBase):\n    def setUp(self):\n        super().setUp()\n        self.proto.fake_session = True\n    async def _asyncSetUp(self):\n        await super()._asyncSetUp()\n        await self._watch_runstates(*self.GOOD_CONNECTION_STATES)\n    async def _asyncTearDown(self):\n        await self.proto.disconnect()\n        await super()._asyncTearDown()",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "SimpleSession",
        "kind": 6,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "class SimpleSession(TestBase):\n    def setUp(self):\n        super().setUp()\n        self.server = LineProtocol(type(self).__name__ + '-server')\n    async def _asyncSetUp(self):\n        await super()._asyncSetUp()\n        await self._watch_runstates(*self.GOOD_CONNECTION_STATES)\n    async def _asyncTearDown(self):\n        await self.proto.disconnect()\n        try:",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "run_as_task",
        "kind": 2,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "def run_as_task(coro, allow_cancellation=False):\n    \"\"\"\n    Run a given coroutine as a task.\n    Optionally, wrap it in a try..except block that allows this\n    coroutine to be canceled gracefully.\n    \"\"\"\n    async def _runner():\n        try:\n            await coro\n        except asyncio.CancelledError:",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "jammed_socket",
        "kind": 2,
        "importPath": "qemu.build.python.tests.protocol",
        "description": "qemu.build.python.tests.protocol",
        "peekOfCode": "def jammed_socket():\n    \"\"\"\n    Opens up a random unused TCP port on localhost, then jams it.\n    \"\"\"\n    socks = []\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind(('127.0.0.1', 0))\n        sock.listen(1)",
        "detail": "qemu.build.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "bdist_egg_guard",
        "kind": 6,
        "importPath": "qemu.build.python.setup",
        "description": "qemu.build.python.setup",
        "peekOfCode": "class bdist_egg_guard(bdist_egg.bdist_egg):\n    \"\"\"\n    Protect against bdist_egg from being executed\n    This prevents calling 'setup.py install' directly, as the 'install'\n    CLI option will invoke the deprecated bdist_egg hook. \"pip install\"\n    calls the more modern bdist_wheel hook, which is what we want.\n    \"\"\"\n    def run(self):\n        sys.exit(\n            'Installation directly via setup.py is not supported.\\n'",
        "detail": "qemu.build.python.setup",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.python.setup",
        "description": "qemu.build.python.setup",
        "peekOfCode": "def main():\n    \"\"\"\n    QEMU tooling installer\n    \"\"\"\n    # https://medium.com/@daveshawley/safely-using-setup-cfg-for-metadata-1babbe54c108\n    pkg_resources.require('setuptools>=39.2')\n    setuptools.setup(cmdclass={'bdist_egg': bdist_egg_guard})\nif __name__ == '__main__':\n    main()",
        "detail": "qemu.build.python.setup",
        "documentation": {}
    },
    {
        "label": "Patch",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]\n    replacement: str\nIdentifierType = Literal['type', 'symbol', 'include', 'constant']\nclass RequiredIdentifier(NamedTuple):\n    type: IdentifierType",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "RequiredIdentifier",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class RequiredIdentifier(NamedTuple):\n    type: IdentifierType\n    name: str\nclass FileMatch:\n    \"\"\"Base class for regex matches\n    Subclasses just need to set the `regexp` class attribute\n    \"\"\"\n    regexp: Optional[str] = None\n    def __init__(self, f: 'FileInfo', m: Match) -> None:\n        self.file: 'FileInfo' = f",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileMatch",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FileMatch:\n    \"\"\"Base class for regex matches\n    Subclasses just need to set the `regexp` class attribute\n    \"\"\"\n    regexp: Optional[str] = None\n    def __init__(self, f: 'FileInfo', m: Match) -> None:\n        self.file: 'FileInfo' = f\n        self.match: Match[str] = m\n    @property\n    def name(self) -> str:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FullMatch",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FullMatch(FileMatch):\n    \"\"\"Regexp that will match all contents of string\n    Useful when used with group_match()\n    \"\"\"\n    regexp = r'(?s).*' # (?s) is re.DOTALL\ndef all_subclasses(c: Type[FileMatch]) -> Iterable[Type[FileMatch]]:\n    for sc in c.__subclasses__():\n        yield sc\n        yield from all_subclasses(sc)\ndef match_class_dict() -> Dict[str, Type[FileMatch]]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "PatchingError",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class PatchingError(Exception):\n    pass\nclass OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'\n    \"\"\"\n    r = StringIO()",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "OverLappingPatchesError",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'\n    \"\"\"\n    r = StringIO()\n    last = 0\n    def patch_sort_key(item: Tuple[int, Patch]) -> Tuple[int, int, int]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "RegexpScanner",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class RegexpScanner:\n    def __init__(self) -> None:\n        self.match_index: Dict[Type[Any], List[FileMatch]] = {}\n        self.match_name_index: Dict[Tuple[Type[Any], str, str], Optional[FileMatch]] = {}\n    def _matches_of_type(self, klass: Type[Any]) -> Iterable[FileMatch]:\n        raise NotImplementedError()\n    def matches_of_type(self, t: Type[T]) -> List[T]:\n        if t not in self.match_index:\n            self.match_index[t] = list(self._matches_of_type(t))\n        return self.match_index[t] # type: ignore",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileInfo",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FileInfo(RegexpScanner):\n    filename: Path\n    original_content: Optional[str] = None\n    def __init__(self, files: 'FileList', filename: os.PathLike, force:bool=False) -> None:\n        super().__init__()\n        self.allfiles = files\n        self.filename = Path(filename)\n        self.patches: List[Patch] = []\n        self.force = force\n    def __repr__(self) -> str:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileList",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FileList(RegexpScanner):\n    def __init__(self):\n        super().__init__()\n        self.files: List[FileInfo] = []\n    def extend(self, *args, **kwargs):\n        self.files.extend(*args, **kwargs)\n    def __iter__(self):\n        return iter(self.files)\n    def _matches_of_type(self, klass: Type[Any]) -> Iterable[FileMatch]:\n        return chain(*(f._matches_of_type(klass) for f in self.files))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "all_subclasses",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def all_subclasses(c: Type[FileMatch]) -> Iterable[Type[FileMatch]]:\n    for sc in c.__subclasses__():\n        yield sc\n        yield from all_subclasses(sc)\ndef match_class_dict() -> Dict[str, Type[FileMatch]]:\n    d = dict((t.__name__, t) for t in all_subclasses(FileMatch))\n    return d\ndef names(matches: Iterable[FileMatch]) -> Iterable[str]:\n    return [m.name for m in matches]\nclass PatchingError(Exception):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "match_class_dict",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def match_class_dict() -> Dict[str, Type[FileMatch]]:\n    d = dict((t.__name__, t) for t in all_subclasses(FileMatch))\n    return d\ndef names(matches: Iterable[FileMatch]) -> Iterable[str]:\n    return [m.name for m in matches]\nclass PatchingError(Exception):\n    pass\nclass OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def names(matches: Iterable[FileMatch]) -> Iterable[str]:\n    return [m.name for m in matches]\nclass PatchingError(Exception):\n    pass\nclass OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "apply_patches",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'\n    \"\"\"\n    r = StringIO()\n    last = 0\n    def patch_sort_key(item: Tuple[int, Patch]) -> Tuple[int, int, int]:\n        \"\"\"Patches are sorted by byte position,\n        patches at the same byte position are applied in the order",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "WARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "ERROR",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "ERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]\n    replacement: str",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "T = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]\n    replacement: str\nIdentifierType = Literal['type', 'symbol', 'include', 'constant']\nclass RequiredIdentifier(NamedTuple):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "IdentifierType",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "IdentifierType = Literal['type', 'symbol', 'include', 'constant']\nclass RequiredIdentifier(NamedTuple):\n    type: IdentifierType\n    name: str\nclass FileMatch:\n    \"\"\"Base class for regex matches\n    Subclasses just need to set the `regexp` class attribute\n    \"\"\"\n    regexp: Optional[str] = None\n    def __init__(self, f: 'FileInfo', m: Match) -> None:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "DefineDirective",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('constant', self.group('name'))\nclass ConstantDefine(ExpressionDefine):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ExpressionDefine",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('constant', self.group('name'))\nclass ConstantDefine(ExpressionDefine):\n    \"\"\"Simple #define preprocessor directive for a number or string constant\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_CONSTANT), r'[ \\t]*\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ConstantDefine",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ConstantDefine(ExpressionDefine):\n    \"\"\"Simple #define preprocessor directive for a number or string constant\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_CONSTANT), r'[ \\t]*\\n')\nclass TypeIdentifiers(NamedTuple):\n    \"\"\"Type names found in type declarations\"\"\"\n    # TYPE_MYDEVICE\n    typename: Optional[str]\n    # MYDEVICE\n    uppercase: Optional[str] = None",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeIdentifiers",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeIdentifiers(NamedTuple):\n    \"\"\"Type names found in type declarations\"\"\"\n    # TYPE_MYDEVICE\n    typename: Optional[str]\n    # MYDEVICE\n    uppercase: Optional[str] = None\n    # MyDevice\n    instancetype: Optional[str] = None\n    # MyDeviceClass\n    classtype: Optional[str] = None",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypedefMatch",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypedefMatch(FileMatch):\n    \"\"\"typedef declaration\"\"\"\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('type', self.group('name'))\nclass SimpleTypedefMatch(TypedefMatch):\n    \"\"\"Simple typedef declaration\n    (no replacement rules)\"\"\"\n    regexp = S(r'^[ \\t]*typedef', SP,\n               NAMED('typedef_type', RE_TYPE), SP,\n               NAMED('name', RE_IDENTIFIER), r'\\s*;[ \\t]*\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "SimpleTypedefMatch",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class SimpleTypedefMatch(TypedefMatch):\n    \"\"\"Simple typedef declaration\n    (no replacement rules)\"\"\"\n    regexp = S(r'^[ \\t]*typedef', SP,\n               NAMED('typedef_type', RE_TYPE), SP,\n               NAMED('name', RE_IDENTIFIER), r'\\s*;[ \\t]*\\n')\nRE_MACRO_DEFINE = S(r'^[ \\t]*#\\s*define\\s+', NAMED('name', RE_IDENTIFIER),\n                    r'\\s*\\(\\s*', RE_IDENTIFIER, r'\\s*\\)', CPP_SPACE)\nRE_STRUCT_ATTRIBUTE = r'QEMU_PACKED'\n# This doesn't parse the struct definitions completely, it just assumes",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "FullStructTypedefMatch",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class FullStructTypedefMatch(TypedefMatch):\n    \"\"\"typedef struct [SomeStruct] { ...} SomeType\n    Will be replaced by separate struct declaration + typedef\n    \"\"\"\n    regexp = RE_STRUCT_TYPEDEF\n    def make_structname(self) -> str:\n        \"\"\"Make struct name for struct+typedef split\"\"\"\n        name = self.group('structname')\n        if not name:\n            name = self.name",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "StructTypedefSplit",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class StructTypedefSplit(FullStructTypedefMatch):\n    \"\"\"split struct+typedef declaration\"\"\"\n    def gen_patches(self) -> Iterator[Patch]:\n        if self.group('structname'):\n            yield from self.split_typedef()\nclass DuplicatedTypedefs(SimpleTypedefMatch):\n    \"\"\"Delete ALL duplicate typedefs (unsafe)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        other_td = [td for td in chain(self.file.matches_of_type(SimpleTypedefMatch),\n                                       self.file.matches_of_type(FullStructTypedefMatch))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DuplicatedTypedefs",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DuplicatedTypedefs(SimpleTypedefMatch):\n    \"\"\"Delete ALL duplicate typedefs (unsafe)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        other_td = [td for td in chain(self.file.matches_of_type(SimpleTypedefMatch),\n                                       self.file.matches_of_type(FullStructTypedefMatch))\n                    if td.name == self.name]\n        DBG(\"other_td: %r\", other_td)\n        if any(td.start() < self.start() for td in other_td):\n            # patch only if handling the first typedef\n            return",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "QOMDuplicatedTypedefs",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class QOMDuplicatedTypedefs(DuplicatedTypedefs):\n    \"\"\"Delete duplicate typedefs if used by QOM type\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        qom_macros = [TypeCheckMacro, DeclareInstanceChecker, DeclareClassCheckers, DeclareObjCheckers]\n        qom_matches = chain(*(self.file.matches_of_type(t) for t in qom_macros))\n        in_use = any(RequiredIdentifier('type', self.name) in m.required_identifiers()\n                     for m in qom_matches)\n        if in_use:\n            yield from DuplicatedTypedefs.gen_patches(self)\nclass QOMStructTypedefSplit(FullStructTypedefMatch):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "QOMStructTypedefSplit",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class QOMStructTypedefSplit(FullStructTypedefMatch):\n    \"\"\"split struct+typedef declaration if used by QOM type\"\"\"\n    def gen_patches(self) -> Iterator[Patch]:\n        qom_macros = [TypeCheckMacro, DeclareInstanceChecker, DeclareClassCheckers, DeclareObjCheckers]\n        qom_matches = chain(*(self.file.matches_of_type(t) for t in qom_macros))\n        in_use = any(RequiredIdentifier('type', self.name) in m.required_identifiers()\n                     for m in qom_matches)\n        if in_use:\n            yield from self.split_typedef()\ndef typedefs(file: FileInfo) -> Iterable[TypedefMatch]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeCheckMacro",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeCheckMacro(FileMatch):\n    \"\"\"OBJECT_CHECK/OBJECT_CLASS_CHECK/OBJECT_GET_CLASS macro definitions\n    Will be replaced by DECLARE_*_CHECKERS macro\n    \"\"\"\n    regexp = RE_CHECK_MACRO\n    @property\n    def checker(self) -> CheckerMacroName:\n        \"\"\"Name of checker macro being used\"\"\"\n        return self.group('checker') # type: ignore\n    @property",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "InterfaceCheckMacro",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class InterfaceCheckMacro(FileMatch):\n    \"\"\"Type checking macro using INTERFACE_CHECK\n    Will be replaced by DECLARE_INTERFACE_CHECKER\n    \"\"\"\n    regexp = S(RE_MACRO_DEFINE,\n               'INTERFACE_CHECK',\n               r'\\s*\\(\\s*', OR(NAMED('instancetype', RE_IDENTIFIER), RE_TYPE, name='c_type'),\n               r'\\s*,', CPP_SPACE,\n               OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n               NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeDeclaration",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeDeclaration(FileMatch):\n    \"\"\"Parent class to all type declarations\"\"\"\n    @property\n    def instancetype(self) -> Optional[str]:\n        return self.getgroup('instancetype')\n    @property\n    def classtype(self) -> Optional[str]:\n        return self.getgroup('classtype')\n    @property\n    def typename(self) -> Optional[str]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeCheckerDeclaration",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeCheckerDeclaration(TypeDeclaration):\n    \"\"\"Parent class to all type checker declarations\"\"\"\n    @property\n    def typename(self) -> str:\n        return self.group('typename')\n    @property\n    def uppercase(self) -> str:\n        return self.group('uppercase')\nclass DeclareInstanceChecker(TypeCheckerDeclaration):\n    \"\"\"DECLARE_INSTANCE_CHECKER use\"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareInstanceChecker",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareInstanceChecker(TypeCheckerDeclaration):\n    \"\"\"DECLARE_INSTANCE_CHECKER use\"\"\"\n    #TODO: replace lonely DECLARE_INSTANCE_CHECKER with DECLARE_OBJ_CHECKERS\n    #      if all types are found.\n    #      This will require looking up the correct class type in the TypeInfo\n    #      structs in another file\n    regexp = S(r'^[ \\t]*DECLARE_INSTANCE_CHECKER\\s*\\(\\s*',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareInterfaceChecker",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareInterfaceChecker(TypeCheckerDeclaration):\n    \"\"\"DECLARE_INTERFACE_CHECKER use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_INTERFACE_CHECKER\\s*\\(\\s*',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('constant', self.group('typename'))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareInstanceType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareInstanceType(TypeDeclaration):\n    \"\"\"DECLARE_INSTANCE_TYPE use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_INSTANCE_TYPE\\s*\\(\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('instancetype', RE_TYPE), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('type', self.group('instancetype'))\nclass DeclareClassType(TypeDeclaration):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareClassType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareClassType(TypeDeclaration):\n    \"\"\"DECLARE_CLASS_TYPE use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_CLASS_TYPE\\s*\\(\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('classtype', RE_TYPE), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('type', self.group('classtype'))\nclass DeclareClassCheckers(TypeCheckerDeclaration):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareClassCheckers",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareClassCheckers(TypeCheckerDeclaration):\n    \"\"\"DECLARE_CLASS_CHECKER use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_CLASS_CHECKERS\\s*\\(\\s*',\n               NAMED('classtype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('constant', self.group('typename'))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareObjCheckers",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareObjCheckers(TypeCheckerDeclaration):\n    \"\"\"DECLARE_OBJ_CHECKERS use\"\"\"\n    #TODO: detect when OBJECT_DECLARE_SIMPLE_TYPE can be used\n    regexp = S(r'^[ \\t]*DECLARE_OBJ_CHECKERS\\s*\\(\\s*',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('classtype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeDeclarationFixup",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeDeclarationFixup(FileMatch):\n    \"\"\"Common base class for code that will look at a set of type declarations\"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches(self) -> Iterable[Patch]:\n        if self.file.filename_matches('qom/object.h'):\n            self.debug(\"skipping object.h\")\n            return\n        # group checkers by uppercase name:\n        decl_types: List[Type[TypeDeclaration]] = [DeclareInstanceChecker, DeclareInstanceType,\n                                                   DeclareClassCheckers, DeclareClassType,",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareVoidTypes",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareVoidTypes(TypeDeclarationFixup):\n    \"\"\"Add DECLARE_*_TYPE(..., void) when there's no declared type\"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches_for_type(self, uppercase: str,\n                             checkers: List[TypeDeclaration],\n                             fields: Dict[str, Optional[str]]) -> Iterable[Patch]:\n        if self.find_conflicts(uppercase, checkers):\n            return\n        #_,last_checker = max((m.start(), m) for m in checkers)\n        _,first_checker = min((m.start(), m) for m in checkers)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "AddDeclareTypeName",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class AddDeclareTypeName(TypeDeclarationFixup):\n    \"\"\"Add DECLARE_TYPE_NAME declarations if necessary\"\"\"\n    def gen_patches_for_type(self, uppercase: str,\n                             checkers: List[TypeDeclaration],\n                             fields: Dict[str, Optional[str]]) -> Iterable[Patch]:\n        typename = fields.get('typename')\n        if typename is None:\n            self.warn(\"typename unavailable\")\n            return\n        if typename == f'TYPE_{uppercase}':",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TrivialClassStruct",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TrivialClassStruct(FileMatch):\n    \"\"\"Trivial class struct\"\"\"\n    regexp = S(r'^[ \\t]*struct\\s*', NAMED('name', RE_IDENTIFIER),\n               r'\\s*{\\s*', NAMED('parent_struct', RE_IDENTIFIER), r'\\s*parent(_class)?\\s*;\\s*};\\n')\nclass DeclareTypeName(FileMatch):\n    \"\"\"DECLARE_TYPE_NAME usage\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_TYPE_NAME\\s*\\(',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'),\n               r'\\s*\\);?[ \\t]*\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareTypeName",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareTypeName(FileMatch):\n    \"\"\"DECLARE_TYPE_NAME usage\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_TYPE_NAME\\s*\\(',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'),\n               r'\\s*\\);?[ \\t]*\\n')\nclass ObjectDeclareType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_TYPE usage\n    Will be replaced with OBJECT_DECLARE_SIMPLE_TYPE if possible\n    \"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ObjectDeclareType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ObjectDeclareType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_TYPE usage\n    Will be replaced with OBJECT_DECLARE_SIMPLE_TYPE if possible\n    \"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('classtype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def gen_patches(self):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ObjectDeclareSimpleType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ObjectDeclareSimpleType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_SIMPLE_TYPE usage\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_SIMPLE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\nclass OldStyleObjectDeclareSimpleType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_SIMPLE_TYPE usage (old API)\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_SIMPLE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "OldStyleObjectDeclareSimpleType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class OldStyleObjectDeclareSimpleType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_SIMPLE_TYPE usage (old API)\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_SIMPLE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('lowercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('parent_classtype', RE_TYPE), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    @property\n    def classtype(self) -> Optional[str]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "Include",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class Include(FileMatch):\n    \"\"\"#include directive\"\"\"\n    regexp = RE_INCLUDE\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', self.group('includepath'))\nclass InitialIncludes(FileMatch):\n    \"\"\"Initial #include block\"\"\"\n    regexp = S(RE_FILE_BEGIN,\n               M(SP, RE_COMMENTS,\n                 r'^[ \\t]*#[ \\t]*ifndef[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n',",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "InitialIncludes",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class InitialIncludes(FileMatch):\n    \"\"\"Initial #include block\"\"\"\n    regexp = S(RE_FILE_BEGIN,\n               M(SP, RE_COMMENTS,\n                 r'^[ \\t]*#[ \\t]*ifndef[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n',\n                 n='?', name='ifndef_block'),\n               M(SP, RE_COMMENTS,\n                 OR(RE_INCLUDE, RE_SIMPLEDEFINE),\n                 n='*', name='includes'))\nclass SymbolUserList(NamedTuple):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "SymbolUserList",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class SymbolUserList(NamedTuple):\n    definitions: List[FileMatch]\n    users: List[FileMatch]\nclass MoveSymbols(FileMatch):\n    \"\"\"Handle missing symbols\n    - Move typedefs and defines when necessary\n    - Add missing #include lines when necessary\n    \"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches(self) -> Iterator[Patch]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "MoveSymbols",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class MoveSymbols(FileMatch):\n    \"\"\"Handle missing symbols\n    - Move typedefs and defines when necessary\n    - Add missing #include lines when necessary\n    \"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches(self) -> Iterator[Patch]:\n        if self.file.filename_matches('qom/object.h'):\n            self.debug(\"skipping object.h\")\n            return",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "EmptyPreprocessorConditional",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class EmptyPreprocessorConditional(FileMatch):\n    \"\"\"Delete empty preprocessor conditionals\"\"\"\n    regexp = r'^[ \\t]*#(if|ifdef)[ \\t].*\\n+[ \\t]*#endif[ \\t]*\\n'\n    def gen_patches(self) -> Iterable[Patch]:\n        yield self.make_removal_patch()",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "typedefs",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def typedefs(file: FileInfo) -> Iterable[TypedefMatch]:\n    return (cast(TypedefMatch, m)\n            for m in chain(file.matches_of_type(SimpleTypedefMatch),\n                           file.matches_of_type(FullStructTypedefMatch)))\ndef find_typedef(f: FileInfo, name: Optional[str]) -> Optional[TypedefMatch]:\n    if not name:\n        return None\n    for td in typedefs(f):\n        if td.name == name:\n            return td",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "find_typedef",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def find_typedef(f: FileInfo, name: Optional[str]) -> Optional[TypedefMatch]:\n    if not name:\n        return None\n    for td in typedefs(f):\n        if td.name == name:\n            return td\n    return None\nCHECKER_MACROS = ['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nCheckerMacroName = Literal['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nRE_CHECK_MACRO = \\",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "find_typename_uppercase",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def find_typename_uppercase(files: FileList, typename: str) -> Optional[str]:\n    \"\"\"Try to find what's the right MODULE_OBJ_NAME for a given type name\"\"\"\n    decl = files.find_match(DeclareTypeName, name=typename, group='typename')\n    if decl:\n        return decl.group('uppercase')\n    if typename.startswith('TYPE_'):\n        return typename[len('TYPE_'):]\n    return None\ndef find_type_checkers(files:FileList, name:str, group:str='uppercase') -> Iterable[TypeCheckerDeclaration]:\n    \"\"\"Find usage of DECLARE*CHECKER macro\"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "find_type_checkers",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def find_type_checkers(files:FileList, name:str, group:str='uppercase') -> Iterable[TypeCheckerDeclaration]:\n    \"\"\"Find usage of DECLARE*CHECKER macro\"\"\"\n    c: Type[TypeCheckerDeclaration]\n    for c in (DeclareInstanceChecker, DeclareClassCheckers, DeclareObjCheckers, ObjectDeclareType, ObjectDeclareSimpleType):\n        yield from files.find_matches(c, name=name, group=group)\nclass Include(FileMatch):\n    \"\"\"#include directive\"\"\"\n    regexp = RE_INCLUDE\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', self.group('includepath'))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "WARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_CONSTANT",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('constant', self.group('name'))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_MACRO_DEFINE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_MACRO_DEFINE = S(r'^[ \\t]*#\\s*define\\s+', NAMED('name', RE_IDENTIFIER),\n                    r'\\s*\\(\\s*', RE_IDENTIFIER, r'\\s*\\)', CPP_SPACE)\nRE_STRUCT_ATTRIBUTE = r'QEMU_PACKED'\n# This doesn't parse the struct definitions completely, it just assumes\n# the closing brackets are going to be in an unindented line:\nRE_FULL_STRUCT = S('struct', SP, M(RE_IDENTIFIER, n='?', name='structname'), SP,\n                   NAMED('body', r'{\\n',\n                         # acceptable inside the struct body:\n                         # - lines starting with space or tab\n                         # - empty lines",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_STRUCT_ATTRIBUTE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_STRUCT_ATTRIBUTE = r'QEMU_PACKED'\n# This doesn't parse the struct definitions completely, it just assumes\n# the closing brackets are going to be in an unindented line:\nRE_FULL_STRUCT = S('struct', SP, M(RE_IDENTIFIER, n='?', name='structname'), SP,\n                   NAMED('body', r'{\\n',\n                         # acceptable inside the struct body:\n                         # - lines starting with space or tab\n                         # - empty lines\n                         # - preprocessor directives\n                         # - comments",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_FULL_STRUCT",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_FULL_STRUCT = S('struct', SP, M(RE_IDENTIFIER, n='?', name='structname'), SP,\n                   NAMED('body', r'{\\n',\n                         # acceptable inside the struct body:\n                         # - lines starting with space or tab\n                         # - empty lines\n                         # - preprocessor directives\n                         # - comments\n                         OR(r'[ \\t][^\\n]*\\n',\n                            r'#[^\\n]*\\n',\n                            r'\\n',",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_STRUCT_TYPEDEF",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_STRUCT_TYPEDEF = S(r'^[ \\t]*typedef', SP, RE_FULL_STRUCT, SP,\n                      NAMED('name', RE_IDENTIFIER), r'\\s*;[ \\t]*\\n')\nclass FullStructTypedefMatch(TypedefMatch):\n    \"\"\"typedef struct [SomeStruct] { ...} SomeType\n    Will be replaced by separate struct declaration + typedef\n    \"\"\"\n    regexp = RE_STRUCT_TYPEDEF\n    def make_structname(self) -> str:\n        \"\"\"Make struct name for struct+typedef split\"\"\"\n        name = self.group('structname')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "CHECKER_MACROS",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "CHECKER_MACROS = ['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nCheckerMacroName = Literal['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nRE_CHECK_MACRO = \\\n    S(RE_MACRO_DEFINE,\n      OR(*CHECKER_MACROS, name='checker'),\n      M(r'\\s*\\(\\s*', OR(NAMED('typedefname', RE_IDENTIFIER), RE_TYPE, name='c_type'), r'\\s*,', CPP_SPACE,\n        OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n        NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n',\n        n='?', name='check_args'))\nEXPECTED_CHECKER_SUFFIXES: List[Tuple[CheckerMacroName, str]] = [",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "CheckerMacroName",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "CheckerMacroName = Literal['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nRE_CHECK_MACRO = \\\n    S(RE_MACRO_DEFINE,\n      OR(*CHECKER_MACROS, name='checker'),\n      M(r'\\s*\\(\\s*', OR(NAMED('typedefname', RE_IDENTIFIER), RE_TYPE, name='c_type'), r'\\s*,', CPP_SPACE,\n        OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n        NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n',\n        n='?', name='check_args'))\nEXPECTED_CHECKER_SUFFIXES: List[Tuple[CheckerMacroName, str]] = [\n    ('OBJECT_GET_CLASS', '_GET_CLASS'),",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_CHECK_MACRO",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_CHECK_MACRO = \\\n    S(RE_MACRO_DEFINE,\n      OR(*CHECKER_MACROS, name='checker'),\n      M(r'\\s*\\(\\s*', OR(NAMED('typedefname', RE_IDENTIFIER), RE_TYPE, name='c_type'), r'\\s*,', CPP_SPACE,\n        OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n        NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n',\n        n='?', name='check_args'))\nEXPECTED_CHECKER_SUFFIXES: List[Tuple[CheckerMacroName, str]] = [\n    ('OBJECT_GET_CLASS', '_GET_CLASS'),\n    ('OBJECT_CLASS_CHECK', '_CLASS'),",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "InitializerValue",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:\n        #DBG('parse_array: %r', m.group(0))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ArrayItem",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:\n        #DBG('parse_array: %r', m.group(0))\n        return [m.group('arrayitem') for m in self.group_finditer(ArrayItem, 'arrayitems')]\nclass FieldInitializer(FileMatch):\n    regexp = RE_TI_FIELD_INIT\n    @property",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ArrayInitializer",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:\n        #DBG('parse_array: %r', m.group(0))\n        return [m.group('arrayitem') for m in self.group_finditer(ArrayItem, 'arrayitems')]\nclass FieldInitializer(FileMatch):\n    regexp = RE_TI_FIELD_INIT\n    @property\n    def raw(self) -> str:\n        return self.group('value')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "FieldInitializer",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class FieldInitializer(FileMatch):\n    regexp = RE_TI_FIELD_INIT\n    @property\n    def raw(self) -> str:\n        return self.group('value')\n    @property\n    def parsed(self) -> ParsedInitializerValue:\n        parsed: ParsedInitializerValue = self.raw\n        #DBG(\"parse_initializer_value: %r\", s)\n        array = self.try_group_match(ArrayInitializer, 'value')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeDefinition",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeDefinition(FileMatch):\n    \"\"\"\n    Common base class for type definitions (TypeInfo variables or OBJECT_DEFINE* macros)\n    \"\"\"\n    @property\n    def instancetype(self) -> Optional[str]:\n        return self.group('instancetype')\n    @property\n    def classtype(self) -> Optional[str]:\n        return self.group('classtype')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoVar",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInfoVar(TypeDefinition):\n    \"\"\"TypeInfo variable declaration with initializer\"\"\"\n    regexp = S(NAMED('begin', RE_TYPEINFO_START),\n               M(NAMED('fields', RE_TI_FIELDS),\n                 NAMED('endcomments', SP, RE_COMMENTS),\n                 NAMED('end', r'};?\\n'),\n                 n='?', name='fullspec'))\n    def is_static(self) -> bool:\n        return 'static' in self.group('modifiers')\n    def is_const(self) -> bool:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RemoveRedundantClassSize",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class RemoveRedundantClassSize(TypeInfoVar):\n    \"\"\"Remove class_size when using OBJECT_DECLARE_SIMPLE_TYPE\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        initializers = self.initializers\n        if initializers is None:\n            return\n        if 'class_size' not in initializers:\n            return\n        self.debug(\"Handling %s\", self.name)\n        m = re.fullmatch(RE_SIZEOF, initializers['class_size'].raw)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RemoveDeclareSimpleTypeArg",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class RemoveDeclareSimpleTypeArg(OldStyleObjectDeclareSimpleType):\n    \"\"\"Remove class_size when using OBJECT_DECLARE_SIMPLE_TYPE\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        c = (f'OBJECT_DECLARE_SIMPLE_TYPE({self.group(\"instancetype\")}, {self.group(\"lowercase\")},\\n'\n             f'                           {self.group(\"uppercase\")})\\n')\n        yield self.make_patch(c)\nclass UseDeclareTypeExtended(TypeInfoVar):\n    \"\"\"Replace TypeInfo variable with OBJECT_DEFINE_TYPE_EXTENDED\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        # this will just ensure the caches for find_match() and matches_for_type()",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "UseDeclareTypeExtended",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class UseDeclareTypeExtended(TypeInfoVar):\n    \"\"\"Replace TypeInfo variable with OBJECT_DEFINE_TYPE_EXTENDED\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        # this will just ensure the caches for find_match() and matches_for_type()\n        # will be loaded in advance:\n        find_type_checkers(self.allfiles, 'xxxxxxxxxxxxxxxxx')\n        if not self.is_static():\n            self.info(\"Skipping non-static TypeInfo variable\")\n            return\n        type_info_macro = self.file.find_match(TypeInfoMacro, self.name)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ObjectDefineTypeExtended",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ObjectDefineTypeExtended(TypeDefinition):\n    \"\"\"OBJECT_DEFINE_TYPE_EXTENDED usage\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DEFINE_TYPE_EXTENDED\\s*\\(\\s*',\n               NAMED('name', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('instancetype', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('classtype', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('parent_uppercase', RE_IDENTIFIER),\n               M(r',\\s*\\n',\n                 NAMED('fields', RE_TI_FIELDS),",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ObjectDefineType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ObjectDefineType(TypeDefinition):\n    \"\"\"OBJECT_DEFINE_TYPE usage\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DEFINE_TYPE\\s*\\(\\s*',\n               NAMED('lowercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('parent_uppercase', RE_IDENTIFIER),\n               M(r',\\s*\\n',\n                 NAMED('fields', RE_TI_FIELDS),\n                 n='?'),\n               r'\\s*\\);?\\n?')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddDeclareVoidClassType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddDeclareVoidClassType(TypeDeclarationFixup):\n    \"\"\"Will add DECLARE_CLASS_TYPE(..., void) if possible\"\"\"\n    def gen_patches_for_type(self, uppercase: str,\n                             checkers: List[TypeDeclaration],\n                             fields: Dict[str, Optional[str]]) -> Iterable[Patch]:\n        defs = list(find_type_definitions(self.allfiles, uppercase))\n        if len(defs) > 1:\n            self.warn(\"multiple definitions for %s\", uppercase)\n            for d in defs:\n                d.warn(\"definition found here\")",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddDeclareVoidInstanceType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddDeclareVoidInstanceType(FileMatch):\n    \"\"\"Will add DECLARE_INSTANCE_TYPE(..., void) if possible\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE,\n               NAMED('name', r'TYPE_[a-zA-Z0-9_]+\\b'),\n               CPP_SPACE, r'.*\\n')\n    def gen_patches(self) -> Iterable[Patch]:\n        assert self.name.startswith('TYPE_')\n        uppercase = self.name[len('TYPE_'):]\n        defs = list(find_type_definitions(self.allfiles, uppercase))\n        if len(defs) > 1:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddObjectDeclareType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddObjectDeclareType(DeclareObjCheckers):\n    \"\"\"Will add OBJECT_DECLARE_TYPE(...) if possible\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        uppercase = self.uppercase\n        typename = self.group('typename')\n        instancetype = self.group('instancetype')\n        classtype = self.group('classtype')\n        if typename != f'TYPE_{uppercase}':\n            self.warn(\"type name mismatch: %s vs %s\", typename, uppercase)\n            return",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddObjectDeclareSimpleType",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddObjectDeclareSimpleType(DeclareInstanceChecker):\n    \"\"\"Will add OBJECT_DECLARE_SIMPLE_TYPE(...) if possible\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        uppercase = self.uppercase\n        typename = self.group('typename')\n        instancetype = self.group('instancetype')\n        if typename != f'TYPE_{uppercase}':\n            self.warn(\"type name mismatch: %s vs %s\", typename, uppercase)\n            return\n        typedefs = [(t,self.allfiles.find_matches(SimpleTypedefMatch, t))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoStringName",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInfoStringName(TypeInfoVar):\n    \"\"\"Replace hardcoded type names with TYPE_ constant\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        values = self.initializers\n        if values is None:\n            return\n        if 'name' not in values:\n            self.warn(\"name not set in TypeInfo variable %s\", self.name)\n            return\n        typename = values['name'].raw",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RedundantTypeSizes",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class RedundantTypeSizes(TypeInfoVar):\n    \"\"\"Remove redundant instance_size/class_size from TypeInfo vars\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        values = self.initializers\n        if values is None:\n            return\n        if 'name' not in values:\n            self.warn(\"name not set in TypeInfo variable %s\", self.name)\n            return\n        typename = values['name'].raw",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInitMacro",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInitMacro(FileMatch):\n    \"\"\"Use of type_init(...) macro\"\"\"\n    regexp = S(r'^[ \\t]*type_init\\s*\\(\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\);?[ \\t]*\\n')\nclass DeleteEmptyTypeInitFunc(TypeInitMacro):\n    \"\"\"Delete empty function declared using type_init(...)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = self.file.find_match(StaticVoidFunction, self.name)\n        DBG(\"function for %s: %s\", self.name, fn)\n        if fn and fn.body == '':\n            yield fn.make_patch('')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "DeleteEmptyTypeInitFunc",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class DeleteEmptyTypeInitFunc(TypeInitMacro):\n    \"\"\"Delete empty function declared using type_init(...)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = self.file.find_match(StaticVoidFunction, self.name)\n        DBG(\"function for %s: %s\", self.name, fn)\n        if fn and fn.body == '':\n            yield fn.make_patch('')\n            yield self.make_patch('')\nclass StaticVoidFunction(FileMatch):\n    \"\"\"simple static void function",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "StaticVoidFunction",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class StaticVoidFunction(FileMatch):\n    \"\"\"simple static void function\n    (no replacement rules)\n    \"\"\"\n    #NOTE: just like RE_FULL_STRUCT, this doesn't parse any of the body contents\n    #      of the function.  Tt will just look for \"}\" in the beginning of a line\n    regexp = S(r'static\\s+void\\s+', NAMED('name', RE_IDENTIFIER), r'\\s*\\(\\s*void\\s*\\)\\n',\n               r'{\\n',\n               NAMED('body',\n                     # acceptable inside the function body:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeRegisterStaticCall",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeRegisterStaticCall(FileMatch):\n    \"\"\"type_register_static() call\n    Will be replaced by TYPE_INFO() macro\n    \"\"\"\n    regexp = S(r'^[ \\t]*', NAMED('func_name', 'type_register_static'),\n               r'\\s*\\(&\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\);[ \\t]*\\n')\nclass UseTypeInfo(TypeRegisterStaticCall):\n    \"\"\"Replace type_register_static() call with TYPE_INFO declaration\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = find_containing_func(self)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "UseTypeInfo",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class UseTypeInfo(TypeRegisterStaticCall):\n    \"\"\"Replace type_register_static() call with TYPE_INFO declaration\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = find_containing_func(self)\n        if fn:\n            DBG(\"%r is inside %r\", self, fn)\n            type_init = self.file.find_match(TypeInitMacro, fn.name)\n            if type_init is None:\n                self.warn(\"can't find type_init(%s) line\", fn.name)\n                if not self.file.force:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeRegisterCall",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeRegisterCall(FileMatch):\n    \"\"\"type_register_static() call\"\"\"\n    regexp = S(r'^[ \\t]*', NAMED('func_name', 'type_register'),\n               r'\\s*\\(&\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\);[ \\t]*\\n')\nclass TypeInfoMacro(FileMatch):\n    \"\"\"TYPE_INFO macro usage\"\"\"\n    regexp = S(r'^[ \\t]*TYPE_INFO\\s*\\(\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\)[ \\t]*;?[ \\t]*\\n')\ndef find_type_info(files: RegexpScanner, name: str) -> Optional[TypeInfoVar]:\n    ti = [ti for ti in files.matches_of_type(TypeInfoVar)\n            if ti.get_raw_initializer_value('name') == name]",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoMacro",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInfoMacro(FileMatch):\n    \"\"\"TYPE_INFO macro usage\"\"\"\n    regexp = S(r'^[ \\t]*TYPE_INFO\\s*\\(\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\)[ \\t]*;?[ \\t]*\\n')\ndef find_type_info(files: RegexpScanner, name: str) -> Optional[TypeInfoVar]:\n    ti = [ti for ti in files.matches_of_type(TypeInfoVar)\n            if ti.get_raw_initializer_value('name') == name]\n    DBG(\"type info vars: %r\", ti)\n    if len(ti) > 1:\n        DBG(\"multiple TypeInfo vars found for %s\", name)\n        return None",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "CreateClassStruct",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class CreateClassStruct(DeclareInstanceChecker):\n    \"\"\"Replace DECLARE_INSTANCE_CHECKER with OBJECT_DECLARE_SIMPLE_TYPE\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        typename = self.group('typename')\n        DBG(\"looking for TypeInfo variable for %s\", typename)\n        var = find_type_info(self.allfiles, typename)\n        if var is None:\n            self.warn(\"no TypeInfo var found for %s\", typename)\n            return\n        assert var.initializers",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "find_type_definitions",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def find_type_definitions(files: FileList, uppercase: str) -> Iterable[TypeDefinition]:\n    types: List[Type[TypeDefinition]] = [TypeInfoVar, ObjectDefineType, ObjectDefineTypeExtended]\n    for t in types:\n        for m in files.matches_of_type(t):\n            m.debug(\"uppercase: %s\", m.uppercase)\n    yield from (m for t in types\n                  for m in files.matches_of_type(t)\n                if m.uppercase == uppercase)\nclass AddDeclareVoidClassType(TypeDeclarationFixup):\n    \"\"\"Will add DECLARE_CLASS_TYPE(..., void) if possible\"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "find_containing_func",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def find_containing_func(m: FileMatch) -> Optional['StaticVoidFunction']:\n    \"\"\"Return function containing this match\"\"\"\n    for fn in m.file.matches_of_type(StaticVoidFunction):\n        if fn.contains(m):\n            return fn\n    return None\nclass TypeRegisterStaticCall(FileMatch):\n    \"\"\"type_register_static() call\n    Will be replaced by TYPE_INFO() macro\n    \"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "find_type_info",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def find_type_info(files: RegexpScanner, name: str) -> Optional[TypeInfoVar]:\n    ti = [ti for ti in files.matches_of_type(TypeInfoVar)\n            if ti.get_raw_initializer_value('name') == name]\n    DBG(\"type info vars: %r\", ti)\n    if len(ti) > 1:\n        DBG(\"multiple TypeInfo vars found for %s\", name)\n        return None\n    if len(ti) == 0:\n        DBG(\"no TypeInfo var found for %s\", name)\n        return None",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "type_infos",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def type_infos(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return file.matches_of_type(TypeInfoVar)\ndef full_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if t.is_full()]\ndef partial_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if not t.is_full()]",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "full_types",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def full_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if t.is_full()]\ndef partial_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if not t.is_full()]",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "partial_types",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def partial_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if not t.is_full()]",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TI_FIELDS",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "TI_FIELDS = [ 'name', 'parent', 'abstract', 'interfaces',\n    'instance_size', 'instance_init', 'instance_post_init', 'instance_finalize',\n    'class_size', 'class_init', 'class_base_init', 'class_data']\nRE_TI_FIELD_NAME = OR(*TI_FIELDS)\nRE_TI_FIELD_INIT = S(r'[ \\t]*', NAMED('comments', RE_COMMENTS),\n                     r'\\.', NAMED('field', RE_TI_FIELD_NAME), r'\\s*=\\s*',\n                     NAMED('value', RE_EXPRESSION), r'[ \\t]*,?[ \\t]*\\n')\nRE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TI_FIELD_NAME",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TI_FIELD_NAME = OR(*TI_FIELDS)\nRE_TI_FIELD_INIT = S(r'[ \\t]*', NAMED('comments', RE_COMMENTS),\n                     r'\\.', NAMED('field', RE_TI_FIELD_NAME), r'\\s*=\\s*',\n                     NAMED('value', RE_EXPRESSION), r'[ \\t]*,?[ \\t]*\\n')\nRE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TI_FIELD_INIT",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TI_FIELD_INIT = S(r'[ \\t]*', NAMED('comments', RE_COMMENTS),\n                     r'\\.', NAMED('field', RE_TI_FIELD_NAME), r'\\s*=\\s*',\n                     NAMED('value', RE_EXPRESSION), r'[ \\t]*,?[ \\t]*\\n')\nRE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TI_FIELDS",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TYPEINFO_START",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ParsedArray",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "ParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ParsedInitializerValue",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "ParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoInitializers",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "TypeInfoInitializers = Dict[str, FieldInitializer]\nclass TypeDefinition(FileMatch):\n    \"\"\"\n    Common base class for type definitions (TypeInfo variables or OBJECT_DEFINE* macros)\n    \"\"\"\n    @property\n    def instancetype(self) -> Optional[str]:\n        return self.group('instancetype')\n    @property\n    def classtype(self) -> Optional[str]:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'\n    elif capture:\n        return f'({s}){repeat}'",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'\n    elif capture:\n        return f'({s}){repeat}'\n    else:\n        return f'(?:{s}){repeat}'\ndef NAMED(name, *regexps) -> str:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "NAMED",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def NAMED(name, *regexps) -> str:\n    \"\"\"Make named group using <P<name>...) syntax\n    >>> NAMED('mygroup', 'xyz', 'abc')\n    '(?P<mygroup>xyzabc)'\n    \"\"\"\n    return P(*regexps, name=name)\ndef OR(*regexps, **kwargs) -> str:\n    \"\"\"Build (a|b|c) regexp\"\"\"\n    return P('|'.join(regexps), **kwargs)\ndef M(*regexps, n='*', name=None) -> str:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "OR",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def OR(*regexps, **kwargs) -> str:\n    \"\"\"Build (a|b|c) regexp\"\"\"\n    return P('|'.join(regexps), **kwargs)\ndef M(*regexps, n='*', name=None) -> str:\n    \"\"\"Add repetition qualifier to regexp(s)\n    >>> M('a', 'b')\n    '(?:ab)*'\n    >>> M('a' , 'b', n='+')\n    '(?:ab)+'\n    >>> M('a' , 'b', n='{2,3}', name='name')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def M(*regexps, n='*', name=None) -> str:\n    \"\"\"Add repetition qualifier to regexp(s)\n    >>> M('a', 'b')\n    '(?:ab)*'\n    >>> M('a' , 'b', n='+')\n    '(?:ab)+'\n    >>> M('a' , 'b', n='{2,3}', name='name')\n    '(?P<name>(?:ab){2,3})'\n    \"\"\"\n    r = P(*regexps, repeat=n)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "test_optional_pars",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def test_optional_pars():\n    r = OPTIONAL_PARS('abc')+'$'\n    assert re.match(r, 'abc')\n    assert re.match(r, '(abc)')\n    assert not re.match(r, '(abcd)')\n    assert not re.match(r, '(abc')\n    assert not re.match(r, 'abc)')\n# this disables the MULTILINE flag, so it will match at the\n# beginning of the file:\nRE_FILE_BEGIN = r'(?-m:^)'",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "WARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'\n    elif capture:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "OPTIONAL_PARS",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "OPTIONAL_PARS = lambda R: OR(S(r'\\(\\s*', R, r'\\s*\\)'), R)\ndef test_optional_pars():\n    r = OPTIONAL_PARS('abc')+'$'\n    assert re.match(r, 'abc')\n    assert re.match(r, '(abc)')\n    assert not re.match(r, '(abcd)')\n    assert not re.match(r, '(abc')\n    assert not re.match(r, 'abc)')\n# this disables the MULTILINE flag, so it will match at the\n# beginning of the file:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_FILE_BEGIN",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_FILE_BEGIN = r'(?-m:^)'\n# C primitives:\nSP = r'\\s*'\nRE_COMMENT = r'//[^\\n]*$|/\\*([^*]|\\*[^/])*\\*/'\nRE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "SP",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "SP = r'\\s*'\nRE_COMMENT = r'//[^\\n]*$|/\\*([^*]|\\*[^/])*\\*/'\nRE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_COMMENT",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_COMMENT = r'//[^\\n]*$|/\\*([^*]|\\*[^/])*\\*/'\nRE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_COMMENTS",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_IDENTIFIER",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_STRING",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_NUMBER",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "CPP_SPACE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "CPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_PATH",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_INCLUDEPATH",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_INCLUDE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_SIMPLEDEFINE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_STRUCT_TYPE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_TYPE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_MACRO_CONCAT",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_SIMPLE_VALUE",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_FUN_CALL",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_SIZEOF",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ADDRESS",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY_ITEM",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY_CAST",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY_ITEMS",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_EXPRESSION",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "BasicPattern",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "class BasicPattern(FileMatch):\n    regexp = '[abc]{3}'\n    @property\n    def name(self):\n        return self.group(0)\n    def replacement(self) -> str:\n        # replace match with the middle character repeated 5 times\n        return self.group(0)[1].upper()*5\ndef test_pattern_patching():\n    of = NamedTemporaryFile('wt')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "Function",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "class Function(FileMatch):\n    regexp = S(r'BEGIN\\s+', NAMED('name', RE_IDENTIFIER), r'\\n',\n               r'(.*\\n)*?END\\n')\nclass Statement(FileMatch):\n    regexp = S(r'^\\s*', NAMED('name', RE_IDENTIFIER), r'\\(\\)\\n')\ndef test_container_match():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['statement1()\\n',\n                   'statement2()\\n',\n                   'BEGIN function1\\n',",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "Statement",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "class Statement(FileMatch):\n    regexp = S(r'^\\s*', NAMED('name', RE_IDENTIFIER), r'\\(\\)\\n')\ndef test_container_match():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['statement1()\\n',\n                   'statement2()\\n',\n                   'BEGIN function1\\n',\n                   '  statement3()\\n',\n                   '  statement4()\\n',\n                   'END\\n',",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "test_pattern_patching",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "def test_pattern_patching():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['one line\\n',\n                  'this pattern will be patched: defbbahij\\n',\n                  'third line\\n',\n                  'another pattern: jihaabfed'])\n    of.flush()\n    files = FileList()\n    f = FileInfo(files, of.name)\n    f.load()",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "test_container_match",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "def test_container_match():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['statement1()\\n',\n                   'statement2()\\n',\n                   'BEGIN function1\\n',\n                   '  statement3()\\n',\n                   '  statement4()\\n',\n                   'END\\n',\n                   'BEGIN function2\\n',\n                   '  statement5()\\n',",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "test_res",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "peekOfCode": "def test_res() -> None:\n    def fullmatch(regexp, s):\n        return re.fullmatch(regexp, s, re.MULTILINE)\n    assert fullmatch(RE_IDENTIFIER, 'sizeof')\n    assert fullmatch(RE_IDENTIFIER, 'X86CPU')\n    assert fullmatch(RE_FUN_CALL, 'sizeof(X86CPU)')\n    assert fullmatch(RE_IDENTIFIER, 'X86_CPU_TYPE_NAME')\n    assert fullmatch(RE_SIMPLE_VALUE, '\"base\"')\n    print(RE_FUN_CALL)\n    assert fullmatch(RE_FUN_CALL, 'X86_CPU_TYPE_NAME(\"base\")')",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "documentation": {}
    },
    {
        "label": "test_struct_re",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "peekOfCode": "def test_struct_re():\n    print('---')\n    print(RE_STRUCT_TYPEDEF)\n    assert re.search(RE_STRUCT_TYPEDEF, r'''\ntypedef struct TCGState {\n    AccelState parent_obj;\n    bool mttcg_enabled;\n    unsigned long tb_size;\n} TCGState;\n''', re.MULTILINE)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "documentation": {}
    },
    {
        "label": "test_initial_includes",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "description": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "peekOfCode": "def test_initial_includes():\n    print(InitialIncludes.regexp)\n    c = '''\n#ifndef HW_FLASH_H\n#define HW_FLASH_H\n/* NOR flash devices */\n#include \"qom/object.h\"\n#include \"exec/hwaddr.h\"\n/* pflash_cfi01.c */\n'''",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.test_regexps",
        "documentation": {}
    },
    {
        "label": "LineAndColumn",
        "kind": 6,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "class LineAndColumn(NamedTuple):\n    line: int\n    col: int\n    def __str__(self):\n        return '%d:%d' % (self.line, self.col)\ndef line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.\n    \"\"\"\n    before = s[:position]",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "opt_compare",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b\n    else:\n        return a",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b\n    else:\n        return a\ndef test_comp_merge():\n    assert opt_compare(None, 1) == True\n    assert opt_compare(2, None) == True",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "test_comp_merge",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def test_comp_merge():\n    assert opt_compare(None, 1) == True\n    assert opt_compare(2, None) == True\n    assert opt_compare(1, 1) == True\n    assert opt_compare(1, 2) == False\n    assert merge(None, None) is None\n    assert merge(None, 10) == 10\n    assert merge(10, None) == 10\n    assert merge(10, 10) == 10\nLineNumber = NewType('LineNumber', int)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "line_col",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.\n    \"\"\"\n    before = s[:position]\n    lines = before.split('\\n')\n    line = len(lines)\n    col = len(lines[-1]) + 1\n    return LineAndColumn(line, col)\ndef test_line_col():",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "test_line_col",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def test_line_col():\n    assert line_col('abc\\ndefg\\nhijkl', 0) == (1, 1)\n    assert line_col('abc\\ndefg\\nhijkl', 2) == (1, 3)\n    assert line_col('abc\\ndefg\\nhijkl', 3) == (1, 4)\n    assert line_col('abc\\ndefg\\nhijkl', 4) == (2, 1)\n    assert line_col('abc\\ndefg\\nhijkl', 10) == (3, 2)\ndef not_optional(arg: Optional[T]) -> T:\n    assert arg is not None\n    return arg\n__all__ = ['not_optional', 'opt_compare', 'merge', 'line_col', 'LineAndColumn']",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "not_optional",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def not_optional(arg: Optional[T]) -> T:\n    assert arg is not None\n    return arg\n__all__ = ['not_optional', 'opt_compare', 'merge', 'line_col', 'LineAndColumn']",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "WARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "T = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b\n    else:",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "LineNumber",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "LineNumber = NewType('LineNumber', int)\nColumnNumber = NewType('ColumnNumber', int)\nclass LineAndColumn(NamedTuple):\n    line: int\n    col: int\n    def __str__(self):\n        return '%d:%d' % (self.line, self.col)\ndef line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "ColumnNumber",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "ColumnNumber = NewType('ColumnNumber', int)\nclass LineAndColumn(NamedTuple):\n    line: int\n    col: int\n    def __str__(self):\n        return '%d:%d' % (self.line, self.col)\ndef line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.\n    \"\"\"",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "__all__ = ['not_optional', 'opt_compare', 'merge', 'line_col', 'LineAndColumn']",
        "detail": "qemu.build.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "process_all_files",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.converter",
        "description": "qemu.build.scripts.codeconverter.converter",
        "peekOfCode": "def process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()\n    if args.table:\n        fields = ['filename', 'variable_name'] + TI_FIELDS\n        print('\\t'.join(fields))",
        "detail": "qemu.build.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.codeconverter.converter",
        "description": "qemu.build.scripts.codeconverter.converter",
        "peekOfCode": "def main() -> None:\n    p = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)\n    p.add_argument('filenames', nargs='+')\n    p.add_argument('--passes', type=int, default=1,\n                   help=\"Number of passes (0 means unlimited)\")\n    p.add_argument('--pattern', required=True, action='append',\n                   default=[], dest='patterns',\n                   help=\"Pattern to scan for\")\n    p.add_argument('--inplace', '-i', action='store_true',\n                   help=\"Patch file in place\")",
        "detail": "qemu.build.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.converter",
        "description": "qemu.build.scripts.codeconverter.converter",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)",
        "detail": "qemu.build.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.converter",
        "description": "qemu.build.scripts.codeconverter.converter",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()",
        "detail": "qemu.build.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.converter",
        "description": "qemu.build.scripts.codeconverter.converter",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()\n    if args.table:",
        "detail": "qemu.build.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.converter",
        "description": "qemu.build.scripts.codeconverter.converter",
        "peekOfCode": "WARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()\n    if args.table:\n        fields = ['filename', 'variable_name'] + TI_FIELDS",
        "detail": "qemu.build.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "PATTERN_HELP",
        "kind": 5,
        "importPath": "qemu.build.scripts.codeconverter.converter",
        "description": "qemu.build.scripts.codeconverter.converter",
        "peekOfCode": "PATTERN_HELP = ('\\n'.join(\"  %s: %s\" % (n, str(c.__doc__).strip())\n                for (n,c) in sorted(match_class_dict().items())\n                if c.has_replacement_rule()))\ndef main() -> None:\n    p = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)\n    p.add_argument('filenames', nargs='+')\n    p.add_argument('--passes', type=int, default=1,\n                   help=\"Number of passes (0 means unlimited)\")\n    p.add_argument('--pattern', required=True, action='append',\n                   default=[], dest='patterns',",
        "detail": "qemu.build.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "create_parser",
        "kind": 2,
        "importPath": "qemu.build.scripts.coverage.compare_gcov_json",
        "description": "qemu.build.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def create_parser():\n    parser = argparse.ArgumentParser(\n        prog='compare_gcov_json',\n        description='analyse the differences in coverage between two runs')\n    parser.add_argument('-a', type=Path, default=None,\n                        help=('First file to check'))\n    parser.add_argument('-b', type=Path, default=None,\n                        help=('Second file to check'))\n    parser.add_argument('--verbose', action='store_true', default=False,\n                        help=('A minimal verbosity level that prints the '",
        "detail": "qemu.build.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "load_json",
        "kind": 2,
        "importPath": "qemu.build.scripts.coverage.compare_gcov_json",
        "description": "qemu.build.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def load_json(json_file_path: Path, verbose = False) -> dict[str, set[int]]:\n    with open(json_file_path) as f:\n        data = json.load(f)\n    root_dir = json_file_path.absolute().parent\n    covered_lines = dict()\n    for filecov in data[\"files\"]:\n        file_path = Path(filecov[\"file\"])\n        # account for generated files - map into src tree\n        resolved_path = Path(file_path).absolute()\n        if resolved_path.is_relative_to(root_dir):",
        "detail": "qemu.build.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "find_missing_files",
        "kind": 2,
        "importPath": "qemu.build.scripts.coverage.compare_gcov_json",
        "description": "qemu.build.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def find_missing_files(first, second):\n    \"\"\"\n    Return a list of files not covered in the second set\n    \"\"\"\n    missing_files = []\n    for f in sorted(first):\n        file_a = first[f]\n        try:\n            file_b = second[f]\n        except KeyError:",
        "detail": "qemu.build.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.coverage.compare_gcov_json",
        "description": "qemu.build.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def main():\n    \"\"\"\n    Script entry point\n    \"\"\"\n    parser = create_parser()\n    args = parser.parse_args()\n    if not args.a or not args.b:\n        print(\"We need two files to compare\")\n        sys.exit(1)\n    first_coverage = load_json(args.a, args.verbose)",
        "detail": "qemu.build.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "get_string_struct",
        "kind": 2,
        "importPath": "qemu.build.scripts.modules.module_block",
        "description": "qemu.build.scripts.modules.module_block",
        "peekOfCode": "def get_string_struct(line):\n    data = line.split()\n    # data[0] -> struct element name\n    # data[1] -> =\n    # data[2] -> value\n    return data[2].replace('\"', '')[:-1]\ndef add_module(fheader, library, format_name, protocol_name):\n    lines = []\n    lines.append('.library_name = \"' + library + '\",')\n    if format_name != \"\":",
        "detail": "qemu.build.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "add_module",
        "kind": 2,
        "importPath": "qemu.build.scripts.modules.module_block",
        "description": "qemu.build.scripts.modules.module_block",
        "peekOfCode": "def add_module(fheader, library, format_name, protocol_name):\n    lines = []\n    lines.append('.library_name = \"' + library + '\",')\n    if format_name != \"\":\n        lines.append('.format_name = \"' + format_name + '\",')\n    if protocol_name != \"\":\n        lines.append('.protocol_name = \"' + protocol_name + '\",')\n    text = '\\n        '.join(lines)\n    fheader.write('\\n    {\\n        ' + text + '\\n    },')\ndef process_file(fheader, filename):",
        "detail": "qemu.build.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "process_file",
        "kind": 2,
        "importPath": "qemu.build.scripts.modules.module_block",
        "description": "qemu.build.scripts.modules.module_block",
        "peekOfCode": "def process_file(fheader, filename):\n    # This parser assumes the coding style rules are being followed\n    with open(filename, \"r\") as cfile:\n        found_start = False\n        library, _ = os.path.splitext(os.path.basename(filename))\n        for line in cfile:\n            if found_start:\n                line = line.replace('\\n', '')\n                if line.find(\".format_name\") != -1:\n                    format_name = get_string_struct(line)",
        "detail": "qemu.build.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "print_top",
        "kind": 2,
        "importPath": "qemu.build.scripts.modules.module_block",
        "description": "qemu.build.scripts.modules.module_block",
        "peekOfCode": "def print_top(fheader):\n    fheader.write('''/* AUTOMATICALLY GENERATED, DO NOT MODIFY */\n/*\n * QEMU Block Module Infrastructure\n *\n * Authors:\n *  Marc Mari       <markmb@redhat.com>\n */\n''')\n    fheader.write('''#ifndef QEMU_MODULE_BLOCK_H",
        "detail": "qemu.build.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "print_bottom",
        "kind": 2,
        "importPath": "qemu.build.scripts.modules.module_block",
        "description": "qemu.build.scripts.modules.module_block",
        "peekOfCode": "def print_bottom(fheader):\n    fheader.write('''\n};\n#endif\n''')\nif __name__ == '__main__':\n    # First argument: output file\n    # All other arguments: modules source files (.c)\n    output_file = sys.argv[1]\n    with open(output_file, 'w') as fheader:",
        "detail": "qemu.build.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace\nBy default, will try to use the second-to-last line in the output to identify\nwhether the crash occred. Optionally, manually set a string that idenitifes the\ncrash by setting CRASH_TOKEN=\nOptions:\n-M1: enable a loop around the remove minimizer, which may help decrease some\n     timing dependent instructions. Off by default.",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "check_if_trace_crashes",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def check_if_trace_crashes(trace, path):\n    with open(path, \"w\") as tracefile:\n        tracefile.write(\"\".join(trace))\n    rc = subprocess.Popen(\"timeout -s 9 {timeout}s {qemu_path} {qemu_args} 2>&1\\\n    < {trace_path}\".format(timeout=TIMEOUT,\n                           qemu_path=QEMU_PATH,\n                           qemu_args=QEMU_ARGS,\n                           trace_path=path),\n                          shell=True,\n                          stdin=subprocess.PIPE,",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "split_write_hint",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def split_write_hint(newtrace, i):\n    HINT_LEN = 3 # > 2\n    if i <=(HINT_LEN-1):\n        return None\n    #find previous continuous write traces\n    k = 0\n    l = i-1\n    writes = []\n    while (k != HINT_LEN and l >= 0):\n        if newtrace[l].startswith(\"write \"):",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "remove_lines",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def remove_lines(newtrace, outpath):\n    remove_step = 1\n    i = 0\n    while i < len(newtrace):\n        # 1.) Try to remove lines completely and reproduce the crash.\n        # If it works, we're done.\n        if (i+remove_step) >= len(newtrace):\n            remove_step = 1\n        prior = newtrace[i:i+remove_step]\n        for j in range(i, i+remove_step):",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "clear_bits",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def clear_bits(newtrace, outpath):\n    # try setting bits in operands of out/write to zero\n    i = 0\n    while i < len(newtrace):\n        if (not newtrace[i].startswith(\"write \") and not\n           newtrace[i].startswith(\"out\")):\n           i += 1\n           continue\n        # write ADDR SIZE DATA\n        # outx ADDR VALUE",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "minimize_trace",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def minimize_trace(inpath, outpath):\n    global TIMEOUT\n    with open(inpath) as f:\n        trace = f.readlines()\n    start = time.time()\n    if not check_if_trace_crashes(trace, outpath):\n        sys.exit(\"The input qtest trace didn't cause a crash...\")\n    end = time.time()\n    print(\"Crashed in {} seconds\".format(end-start))\n    TIMEOUT = (end-start)*5",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "QEMU_ARGS",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "QEMU_ARGS = None\nQEMU_PATH = None\nTIMEOUT = 5\nCRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "QEMU_PATH",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "QEMU_PATH = None\nTIMEOUT = 5\nCRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "TIMEOUT = 5\nCRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "CRASH_TOKEN",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "CRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "M1",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "M1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "M2",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "M2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace\nBy default, will try to use the second-to-last line in the output to identify",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "write_suffix_lookup",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "write_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace\nBy default, will try to use the second-to-last line in the output to identify\nwhether the crash occred. Optionally, manually set a string that idenitifes the",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "deduplication_note",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "deduplication_note = \"\"\"\\n\\\nNote: While trimming the input, sometimes the mutated trace triggers a different\ntype crash but indicates the same bug. Under this situation, our minimizer is\nincapable of recognizing and stopped from removing it. In the future, we may\nuse a more sophisticated crash case deduplication method.\n\\n\"\"\"\ndef check_if_trace_crashes(trace, path):\n    with open(path, \"w\") as tracefile:\n        tracefile.write(\"\".join(trace))\n    rc = subprocess.Popen(\"timeout -s 9 {timeout}s {qemu_path} {qemu_args} 2>&1\\",
        "detail": "qemu.build.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "c_header",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_header(owner):\n    return \"\"\"/*\n * Autogenerated Fuzzer Test Case\n *\n * Copyright (c) {date} {owner}\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n#include \"qemu/osdep.h\"",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "c_comment",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_comment(s):\n    \"\"\" Return a multi-line C comment. Assume the text is already wrapped \"\"\"\n    return \"/*\\n * \" + \"\\n * \".join(s.splitlines()) + \"\\n*/\"\ndef print_c_function(s):\n    print(\"/* \")\n    for l in s.splitlines():\n        print(\" * {}\".format(l))\ndef bash_reproducer(path, args, trace):\n    result = '\\\\\\n'.join(textwrap.wrap(\"cat << EOF | {} {}\".format(path, args),\n                                       72, break_on_hyphens=False,",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "print_c_function",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def print_c_function(s):\n    print(\"/* \")\n    for l in s.splitlines():\n        print(\" * {}\".format(l))\ndef bash_reproducer(path, args, trace):\n    result = '\\\\\\n'.join(textwrap.wrap(\"cat << EOF | {} {}\".format(path, args),\n                                       72, break_on_hyphens=False,\n                                       drop_whitespace=False))\n    for l in trace.splitlines():\n        result += \"\\n\" + '\\\\\\n'.join(textwrap.wrap(l,72,drop_whitespace=False))",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "bash_reproducer",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def bash_reproducer(path, args, trace):\n    result = '\\\\\\n'.join(textwrap.wrap(\"cat << EOF | {} {}\".format(path, args),\n                                       72, break_on_hyphens=False,\n                                       drop_whitespace=False))\n    for l in trace.splitlines():\n        result += \"\\n\" + '\\\\\\n'.join(textwrap.wrap(l,72,drop_whitespace=False))\n    result += \"\\nEOF\"\n    return result\ndef c_reproducer(name, args, trace):\n    result = []",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "c_reproducer",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_reproducer(name, args, trace):\n    result = []\n    result.append(\"\"\"static void {}(void)\\n{{\"\"\".format(name))\n    # libqtest will add its own qtest args, so get rid of them\n    args = args.replace(\"-accel qtest\",\"\")\n    args = args.replace(\",accel=qtest\",\"\")\n    args = args.replace(\"-machine accel=qtest\",\"\")\n    args = args.replace(\"-qtest stdio\",\"\")\n    result.append(\"\"\"QTestState *s = qtest_init(\"{}\");\"\"\".format(args))\n    for l in trace.splitlines():",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "c_main",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_main(name, arch):\n    return \"\"\"int main(int argc, char **argv)\n{{\n    const char *arch = qtest_get_arch();\n    g_test_init(&argc, &argv, NULL);\n   if (strcmp(arch, \"{arch}\") == 0) {{\n        qtest_add_func(\"fuzz/{name}\",{name});\n   }}\n   return g_test_run();\n}}\"\"\".format(name=name, arch=arch)",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument(\"-bash\", help=\"Only output a copy-pastable bash command\",\n                        action=\"store_true\")\n    group.add_argument(\"-c\", help=\"Only output a c function\",\n                        action=\"store_true\")\n    parser.add_argument('-owner', help=\"If generating complete C source code, \\\n                        this specifies the Copyright owner\",\n                        nargs='?', default=\"<name of author>\")",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "__maintainer__ = \"Alexander Bulekov\"\n__email__      = \"alxndr@bu.edu\"\ndef c_header(owner):\n    return \"\"\"/*\n * Autogenerated Fuzzer Test Case\n *\n * Copyright (c) {date} {owner}\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.",
        "detail": "qemu.build.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "peekOfCode": "def usage():\n    sys.exit(\"Usage: {} /path/to/qtest_log_output\".format((sys.argv[0])))\ndef main(filename):\n    with open(filename, \"r\") as f:\n        trace = f.readlines()\n    # Leave only lines that look like logged qtest commands\n    trace[:] = [x.strip() for x in trace if \"[R +\" in x\n                or \"[S +\" in x and \"CLOSED\" not in x]\n    for i in range(len(trace)):\n        if i+1 < len(trace):",
        "detail": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "peekOfCode": "def main(filename):\n    with open(filename, \"r\") as f:\n        trace = f.readlines()\n    # Leave only lines that look like logged qtest commands\n    trace[:] = [x.strip() for x in trace if \"[R +\" in x\n                or \"[S +\" in x and \"CLOSED\" not in x]\n    for i in range(len(trace)):\n        if i+1 < len(trace):\n            if \"[DMA]\" in trace[i+1]:\n                if \"[DOUBLE-FETCH]\" in trace[i+1]:",
        "detail": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "description": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "peekOfCode": "__maintainer__ = \"Alexander Bulekov\"\n__email__      = \"alxndr@bu.edu\"\ndef usage():\n    sys.exit(\"Usage: {} /path/to/qtest_log_output\".format((sys.argv[0])))\ndef main(filename):\n    with open(filename, \"r\") as f:\n        trace = f.readlines()\n    # Leave only lines that look like logged qtest commands\n    trace[:] = [x.strip() for x in trace if \"[R +\" in x\n                or \"[S +\" in x and \"CLOSED\" not in x]",
        "detail": "qemu.build.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "documentation": {}
    },
    {
        "label": "get_JIT_line",
        "kind": 2,
        "importPath": "qemu.build.scripts.performance.dissect",
        "description": "qemu.build.scripts.performance.dissect",
        "peekOfCode": "def get_JIT_line(callgrind_data):\n    \"\"\"\n    Search for the first instance of the JIT call in\n    the callgrind_annotate output when ran using --tree=caller\n    This is equivalent to the self number of instructions of JIT.\n    Parameters:\n    callgrind_data (list): callgrind_annotate output\n    Returns:\n    (int): Line number\n    \"\"\"",
        "detail": "qemu.build.scripts.performance.dissect",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.performance.dissect",
        "description": "qemu.build.scripts.performance.dissect",
        "peekOfCode": "def main():\n    # Parse the command line arguments\n    parser = argparse.ArgumentParser(\n        usage='dissect.py [-h] -- '\n        '<qemu executable> [<qemu executable options>] '\n        '<target executable> [<target executable options>]')\n    parser.add_argument('command', type=str, nargs='+', help=argparse.SUPPRESS)\n    args = parser.parse_args()\n    # Extract the needed variables from the args\n    command = args.command",
        "detail": "qemu.build.scripts.performance.dissect",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "parser = argparse.ArgumentParser(\n    usage='topN_callgrind.py [-h] [-n] <number of displayed top functions>  -- '\n          '<qemu executable> [<qemu executable options>] '\n          '<target executable> [<target executable options>]')\nparser.add_argument('-n', dest='top', type=int, default=25,\n                    help='Specify the number of top functions to print.')\nparser.add_argument('command', type=str, nargs='+', help=argparse.SUPPRESS)\nargs = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "args = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command\ntop = args.top\n# Insure that valgrind is installed\ncheck_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "command = args.command\ntop = args.top\n# Insure that valgrind is installed\ncheck_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind\ncallgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "top",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "top = args.top\n# Insure that valgrind is installed\ncheck_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind\ncallgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]\n    + command),",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "check_valgrind_presence",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "check_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind\ncallgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]\n    + command),\n    stdout=subprocess.DEVNULL,\n    stderr=subprocess.PIPE)",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "callgrind",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "callgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]\n    + command),\n    stdout=subprocess.DEVNULL,\n    stderr=subprocess.PIPE)\nif callgrind.returncode:\n    sys.exit(callgrind.stderr.decode(\"utf-8\"))\n# Save callgrind_annotate output to /tmp/callgrind_annotate.out\nwith open(\"/tmp/callgrind_annotate.out\", \"w\") as output:\n    callgrind_annotate = subprocess.run([\"callgrind_annotate\",",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "callgrind_data",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "callgrind_data = []\nwith open('/tmp/callgrind_annotate.out', 'r') as data:\n    callgrind_data = data.readlines()\n# Line number with the total number of instructions\ntotal_instructions_line_number = 20\n# Get the total number of instructions\ntotal_instructions_line_data = callgrind_data[total_instructions_line_number]\ntotal_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_instructions_line_number",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "total_instructions_line_number = 20\n# Get the total number of instructions\ntotal_instructions_line_data = callgrind_data[total_instructions_line_number]\ntotal_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_instructions_line_data",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "total_instructions_line_data = callgrind_data[total_instructions_line_number]\ntotal_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_number_of_instructions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "total_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_number_of_instructions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "total_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "first_func_line",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "first_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "number_of_functions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "number_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "number_of_top_functions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "number_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Function Name',\n                                                         'Source File',",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "top_functions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_callgrind",
        "description": "qemu.build.scripts.performance.topN_callgrind",
        "peekOfCode": "top_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Function Name',\n                                                         'Source File',\n                                                         '-' * 4,\n                                                         '-' * 10,\n                                                         '-' * 30,",
        "detail": "qemu.build.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "parser = argparse.ArgumentParser(\n    usage='topN_perf.py [-h] [-n] <number of displayed top functions >  -- '\n          '<qemu executable> [<qemu executable options>] '\n          '<target executable> [<target executable options>]')\nparser.add_argument('-n', dest='top', type=int, default=25,\n                    help='Specify the number of top functions to print.')\nparser.add_argument('command', type=str, nargs='+', help=argparse.SUPPRESS)\nargs = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "args = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command\ntop = args.top\n# Insure that perf is installed\ncheck_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "command = args.command\ntop = args.top\n# Insure that perf is installed\ncheck_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf\ncheck_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "top",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "top = args.top\n# Insure that perf is installed\ncheck_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf\ncheck_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,\n                                          stderr=subprocess.DEVNULL)",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "check_perf_presence",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "check_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf\ncheck_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,\n                                          stderr=subprocess.DEVNULL)\nif check_perf_executability.returncode:\n    sys.exit(",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "check_perf_executability",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "check_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,\n                                          stderr=subprocess.DEVNULL)\nif check_perf_executability.returncode:\n    sys.exit(\n\"\"\"\nError:\nYou may not have permission to collect stats.\nConsider tweaking /proc/sys/kernel/perf_event_paranoid,\nwhich controls use of the performance events system by",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "perf_record",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "perf_record = subprocess.run(([\"perf\", \"record\", \"--output=/tmp/perf.data\"] +\n                              command),\n                             stdout=subprocess.DEVNULL,\n                             stderr=subprocess.PIPE)\nif perf_record.returncode:\n    os.unlink('/tmp/perf.data')\n    sys.exit(perf_record.stderr.decode(\"utf-8\"))\n# Save perf report output to /tmp/perf_report.out\nwith open(\"/tmp/perf_report.out\", \"w\") as output:\n    perf_report = subprocess.run(",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "functions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "functions = []\nwith open(\"/tmp/perf_report.out\", \"r\") as data:\n    # Only read lines that are not comments (comments start with #)\n    # Only read lines that are not empty\n    functions = [line for line in data.readlines() if line and line[0]\n                 != '#' and line[0] != \"\\n\"]\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = top if len(functions) > top else len(functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = functions[:number_of_top_functions]",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "number_of_top_functions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "number_of_top_functions = top if len(functions) > top else len(functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = functions[:number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Name',\n                                                         'Invoked by',\n                                                         '-' * 4,\n                                                         '-' * 10,",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "top_functions",
        "kind": 5,
        "importPath": "qemu.build.scripts.performance.topN_perf",
        "description": "qemu.build.scripts.performance.topN_perf",
        "peekOfCode": "top_functions = functions[:number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Name',\n                                                         'Invoked by',\n                                                         '-' * 4,\n                                                         '-' * 10,\n                                                         '-' * 30,\n                                                         '-' * 25))",
        "detail": "qemu.build.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "QAPIBackend",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.backend",
        "description": "qemu.build.scripts.qapi.backend",
        "peekOfCode": "class QAPIBackend(ABC):\n    @abstractmethod\n    def generate(self,\n                 schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str,\n                 unmask: bool,\n                 builtins: bool,\n                 gen_tracing: bool) -> None:\n        \"\"\"",
        "detail": "qemu.build.scripts.qapi.backend",
        "documentation": {}
    },
    {
        "label": "QAPICBackend",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.backend",
        "description": "qemu.build.scripts.qapi.backend",
        "peekOfCode": "class QAPICBackend(QAPIBackend):\n    def generate(self,\n                 schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str,\n                 unmask: bool,\n                 builtins: bool,\n                 gen_tracing: bool) -> None:\n        \"\"\"\n        Generate C code for the given schema into the target directory.",
        "detail": "qemu.build.scripts.qapi.backend",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenCommandVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "class QAPISchemaGenCommandVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str, gen_tracing: bool):\n        super().__init__(\n            prefix, 'qapi-commands',\n            ' * Schema-defined QAPI/QMP commands', None, __doc__,\n            gen_tracing=gen_tracing)\n        self._visited_ret_types: Dict[QAPIGenC, Set[QAPISchemaType]] = {}\n        self._gen_tracing = gen_tracing\n    def _begin_user_module(self, name: str) -> None:\n        self._visited_ret_types[self._genc] = set()",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_command_decl",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_command_decl(name: str,\n                     arg_type: Optional[QAPISchemaObjectType],\n                     boxed: bool,\n                     ret_type: Optional[QAPISchemaType],\n                     coroutine: bool) -> str:\n    return mcgen('''\n%(c_type)s %(coroutine_fn)sqmp_%(c_name)s(%(params)s);\n''',\n                 c_type=(ret_type and ret_type.c_type()) or 'void',\n                 coroutine_fn='coroutine_fn ' if coroutine else '',",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_call",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_call(name: str,\n             arg_type: Optional[QAPISchemaObjectType],\n             boxed: bool,\n             ret_type: Optional[QAPISchemaType],\n             gen_tracing: bool) -> str:\n    ret = ''\n    argstr = ''\n    if boxed:\n        assert arg_type\n        argstr = '&arg, '",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_marshal_output",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_marshal_output(ret_type: QAPISchemaType) -> str:\n    return mcgen('''\nstatic void qmp_marshal_output_%(c_name)s(%(c_type)s ret_in,\n                                QObject **ret_out, Error **errp)\n{\n    Visitor *v;\n    v = qobject_output_visitor_new_qmp(ret_out);\n    if (visit_type_%(c_name)s(v, \"unused\", &ret_in, errp)) {\n        visit_complete(v, ret_out);\n    }",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "build_marshal_proto",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def build_marshal_proto(name: str,\n                        coroutine: bool) -> str:\n    return ('void %(coroutine_fn)sqmp_marshal_%(c_name)s(%(params)s)' % {\n        'coroutine_fn': 'coroutine_fn ' if coroutine else '',\n        'c_name': c_name(name),\n        'params': 'QDict *args, QObject **ret, Error **errp',\n    })\ndef gen_marshal_decl(name: str,\n                     coroutine: bool) -> str:\n    return mcgen('''",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_marshal_decl",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_marshal_decl(name: str,\n                     coroutine: bool) -> str:\n    return mcgen('''\n%(proto)s;\n''',\n                 proto=build_marshal_proto(name, coroutine))\ndef gen_trace(name: str) -> str:\n    return mcgen('''\nqmp_enter_%(name)s(const char *json) \"%%s\"\nqmp_exit_%(name)s(const char *result, bool succeeded) \"%%s %%d\"",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_trace",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_trace(name: str) -> str:\n    return mcgen('''\nqmp_enter_%(name)s(const char *json) \"%%s\"\nqmp_exit_%(name)s(const char *result, bool succeeded) \"%%s %%d\"\n''',\n                 name=c_name(name))\ndef gen_marshal(name: str,\n                arg_type: Optional[QAPISchemaObjectType],\n                boxed: bool,\n                ret_type: Optional[QAPISchemaType],",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_marshal",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_marshal(name: str,\n                arg_type: Optional[QAPISchemaObjectType],\n                boxed: bool,\n                ret_type: Optional[QAPISchemaType],\n                gen_tracing: bool,\n                coroutine: bool) -> str:\n    have_args = boxed or (arg_type and not arg_type.is_empty())\n    if have_args:\n        assert arg_type is not None\n        arg_type_c_name = arg_type.c_name()",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_register_command",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_register_command(name: str,\n                         features: List[QAPISchemaFeature],\n                         success_response: bool,\n                         allow_oob: bool,\n                         allow_preconfig: bool,\n                         coroutine: bool) -> str:\n    options = []\n    if not success_response:\n        options += ['QCO_NO_SUCCESS_RESP']\n    if allow_oob:",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_commands",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.commands",
        "description": "qemu.build.scripts.qapi.commands",
        "peekOfCode": "def gen_commands(schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str,\n                 gen_tracing: bool) -> None:\n    vis = QAPISchemaGenCommandVisitor(prefix, gen_tracing)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.build.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "Indentation",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "class Indentation:\n    \"\"\"\n    Indentation level management.\n    :param initial: Initial number of spaces, default 0.\n    \"\"\"\n    def __init__(self, initial: int = 0) -> None:\n        self._level = initial\n    def __repr__(self) -> str:\n        return \"{}({:d})\".format(type(self).__name__, self._level)\n    def __str__(self) -> str:",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "camel_to_upper",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def camel_to_upper(value: str) -> str:\n    \"\"\"\n    Converts CamelCase to CAMEL_CASE.\n    Examples::\n        ENUMName -> ENUM_NAME\n        EnumName1 -> ENUM_NAME1\n        ENUM_NAME -> ENUM_NAME\n        ENUM_NAME1 -> ENUM_NAME1\n        ENUM_Name2 -> ENUM_NAME2\n        ENUM24_Name -> ENUM24_NAME",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "c_enum_const",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def c_enum_const(type_name: str,\n                 const_name: str,\n                 prefix: Optional[str] = None) -> str:\n    \"\"\"\n    Generate a C enumeration constant name.\n    :param type_name: The name of the enumeration.\n    :param const_name: The name of this constant.\n    :param prefix: Optional, prefix that overrides the type_name.\n    \"\"\"\n    if prefix is None:",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "c_name",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def c_name(name: str, protect: bool = True) -> str:\n    \"\"\"\n    Map ``name`` to a valid C identifier.\n    Used for converting 'name' from a 'name':'type' qapi definition\n    into a generated struct member, as well as converting type names\n    into substrings of a generated C function name.\n    '__a.b_c' -> '__a_b_c', 'x-foo' -> 'x_foo'\n    protect=True: 'int' -> 'q_int'; protect=False: 'int' -> 'int'\n    :param name: The name to map.\n    :param protect: If true, avoid returning certain ticklish identifiers",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "cgen",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def cgen(code: str, **kwds: object) -> str:\n    \"\"\"\n    Generate ``code`` with ``kwds`` interpolated.\n    Obey `indent`, and strip `EATSPACE`.\n    \"\"\"\n    raw = code % kwds\n    pfx = str(indent)\n    if pfx:\n        raw = re.sub(r'^(?!(#|$))', pfx, raw, flags=re.MULTILINE)\n    return re.sub(re.escape(EATSPACE) + r' *', '', raw)",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "mcgen",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def mcgen(code: str, **kwds: object) -> str:\n    if code[0] == '\\n':\n        code = code[1:]\n    return cgen(code, **kwds)\ndef c_fname(filename: str) -> str:\n    return re.sub(r'[^A-Za-z0-9_]', '_', filename)\ndef guardstart(name: str) -> str:\n    return mcgen('''\n#ifndef %(name)s\n#define %(name)s",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "c_fname",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def c_fname(filename: str) -> str:\n    return re.sub(r'[^A-Za-z0-9_]', '_', filename)\ndef guardstart(name: str) -> str:\n    return mcgen('''\n#ifndef %(name)s\n#define %(name)s\n''',\n                 name=c_fname(name).upper())\ndef guardend(name: str) -> str:\n    return mcgen('''",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "guardstart",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def guardstart(name: str) -> str:\n    return mcgen('''\n#ifndef %(name)s\n#define %(name)s\n''',\n                 name=c_fname(name).upper())\ndef guardend(name: str) -> str:\n    return mcgen('''\n#endif /* %(name)s */\n''',",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "guardend",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def guardend(name: str) -> str:\n    return mcgen('''\n#endif /* %(name)s */\n''',\n                 name=c_fname(name).upper())\ndef gen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]],\n               cond_fmt: str, not_fmt: str,\n               all_operator: str, any_operator: str) -> str:\n    def do_gen(ifcond: Union[str, Dict[str, Any]],\n               need_parens: bool) -> str:",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "gen_ifcond",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def gen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]],\n               cond_fmt: str, not_fmt: str,\n               all_operator: str, any_operator: str) -> str:\n    def do_gen(ifcond: Union[str, Dict[str, Any]],\n               need_parens: bool) -> str:\n        if isinstance(ifcond, str):\n            return cond_fmt % ifcond\n        assert isinstance(ifcond, dict) and len(ifcond) == 1\n        if 'not' in ifcond:\n            return not_fmt % do_gen(ifcond['not'], True)",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "cgen_ifcond",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def cgen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]]) -> str:\n    return gen_ifcond(ifcond, 'defined(%s)', '!%s', ' && ', ' || ')\ndef docgen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]]) -> str:\n    # TODO Doc generated for conditions needs polish\n    return gen_ifcond(ifcond, '%s', 'not %s', ' and ', ' or ')\ndef gen_if(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#if %(cond)s",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "docgen_ifcond",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def docgen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]]) -> str:\n    # TODO Doc generated for conditions needs polish\n    return gen_ifcond(ifcond, '%s', 'not %s', ' and ', ' or ')\ndef gen_if(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#if %(cond)s\n''', cond=cond)\ndef gen_endif(cond: str) -> str:",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "gen_if",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def gen_if(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#if %(cond)s\n''', cond=cond)\ndef gen_endif(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "gen_endif",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def gen_endif(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#endif /* %(cond)s */\n''', cond=cond)\ndef must_match(pattern: str, string: str) -> Match[str]:\n    match = re.match(pattern, string)\n    assert match is not None\n    return match",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "must_match",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "def must_match(pattern: str, string: str) -> Match[str]:\n    match = re.match(pattern, string)\n    assert match is not None\n    return match",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "EATSPACE",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "EATSPACE = '\\033EATSPACE.'\nPOINTER_SUFFIX = ' *' + EATSPACE\ndef camel_to_upper(value: str) -> str:\n    \"\"\"\n    Converts CamelCase to CAMEL_CASE.\n    Examples::\n        ENUMName -> ENUM_NAME\n        EnumName1 -> ENUM_NAME1\n        ENUM_NAME -> ENUM_NAME\n        ENUM_NAME1 -> ENUM_NAME1",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "POINTER_SUFFIX",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "POINTER_SUFFIX = ' *' + EATSPACE\ndef camel_to_upper(value: str) -> str:\n    \"\"\"\n    Converts CamelCase to CAMEL_CASE.\n    Examples::\n        ENUMName -> ENUM_NAME\n        EnumName1 -> ENUM_NAME1\n        ENUM_NAME -> ENUM_NAME\n        ENUM_NAME1 -> ENUM_NAME1\n        ENUM_Name2 -> ENUM_NAME2",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "indent",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.common",
        "description": "qemu.build.scripts.qapi.common",
        "peekOfCode": "indent = Indentation()\ndef cgen(code: str, **kwds: object) -> str:\n    \"\"\"\n    Generate ``code`` with ``kwds`` interpolated.\n    Obey `indent`, and strip `EATSPACE`.\n    \"\"\"\n    raw = code % kwds\n    pfx = str(indent)\n    if pfx:\n        raw = re.sub(r'^(?!(#|$))', pfx, raw, flags=re.MULTILINE)",
        "detail": "qemu.build.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "QAPIError",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.error",
        "description": "qemu.build.scripts.qapi.error",
        "peekOfCode": "class QAPIError(Exception):\n    \"\"\"Base class for all exceptions from the QAPI package.\"\"\"\nclass QAPISourceError(QAPIError):\n    \"\"\"Error class for all exceptions identifying a source location.\"\"\"\n    def __init__(self,\n                 info: Optional[QAPISourceInfo],\n                 msg: str,\n                 col: Optional[int] = None):\n        super().__init__()\n        self.info = info",
        "detail": "qemu.build.scripts.qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPISourceError",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.error",
        "description": "qemu.build.scripts.qapi.error",
        "peekOfCode": "class QAPISourceError(QAPIError):\n    \"\"\"Error class for all exceptions identifying a source location.\"\"\"\n    def __init__(self,\n                 info: Optional[QAPISourceInfo],\n                 msg: str,\n                 col: Optional[int] = None):\n        super().__init__()\n        self.info = info\n        self.msg = msg\n        self.col = col",
        "detail": "qemu.build.scripts.qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPISemError",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.error",
        "description": "qemu.build.scripts.qapi.error",
        "peekOfCode": "class QAPISemError(QAPISourceError):\n    \"\"\"Error class for semantic QAPI errors.\"\"\"",
        "detail": "qemu.build.scripts.qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenEventVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.events",
        "description": "qemu.build.scripts.qapi.events",
        "peekOfCode": "class QAPISchemaGenEventVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-events',\n            ' * Schema-defined QAPI/QMP events', None, __doc__)\n        self._event_enum_name = c_name(prefix + 'QAPIEvent', protect=False)\n        self._event_enum_members: List[QAPISchemaEnumMember] = []\n        self._event_emit_name = c_name(prefix + 'qapi_event_emit')\n    def _begin_user_module(self, name: str) -> None:\n        events = self._module_basename('qapi-events', name)",
        "detail": "qemu.build.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "build_event_send_proto",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.events",
        "description": "qemu.build.scripts.qapi.events",
        "peekOfCode": "def build_event_send_proto(name: str,\n                           arg_type: Optional[QAPISchemaObjectType],\n                           boxed: bool) -> str:\n    return 'void qapi_event_send_%(c_name)s(%(param)s)' % {\n        'c_name': c_name(name.lower()),\n        'param': build_params(arg_type, boxed)}\ndef gen_event_send_decl(name: str,\n                        arg_type: Optional[QAPISchemaObjectType],\n                        boxed: bool) -> str:\n    return mcgen('''",
        "detail": "qemu.build.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_event_send_decl",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.events",
        "description": "qemu.build.scripts.qapi.events",
        "peekOfCode": "def gen_event_send_decl(name: str,\n                        arg_type: Optional[QAPISchemaObjectType],\n                        boxed: bool) -> str:\n    return mcgen('''\n%(proto)s;\n''',\n                 proto=build_event_send_proto(name, arg_type, boxed))\ndef gen_param_var(typ: QAPISchemaObjectType) -> str:\n    \"\"\"\n    Generate a struct variable holding the event parameters.",
        "detail": "qemu.build.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_param_var",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.events",
        "description": "qemu.build.scripts.qapi.events",
        "peekOfCode": "def gen_param_var(typ: QAPISchemaObjectType) -> str:\n    \"\"\"\n    Generate a struct variable holding the event parameters.\n    Initialize it with the function arguments defined in `gen_event_send`.\n    \"\"\"\n    assert not typ.branches\n    ret = mcgen('''\n    %(c_name)s param = {\n''',\n                c_name=typ.c_name())",
        "detail": "qemu.build.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_event_send",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.events",
        "description": "qemu.build.scripts.qapi.events",
        "peekOfCode": "def gen_event_send(name: str,\n                   arg_type: Optional[QAPISchemaObjectType],\n                   features: List[QAPISchemaFeature],\n                   boxed: bool,\n                   event_enum_name: str,\n                   event_emit: str) -> str:\n    # FIXME: Our declaration of local variables (and of 'errp' in the\n    # parameter list) can collide with exploded members of the event's\n    # data type passed in as parameters.  If this collision ever hits in\n    # practice, we can rename our local variables with a leading _ prefix,",
        "detail": "qemu.build.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_events",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.events",
        "description": "qemu.build.scripts.qapi.events",
        "peekOfCode": "def gen_events(schema: QAPISchema,\n               output_dir: str,\n               prefix: str) -> None:\n    vis = QAPISchemaGenEventVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.build.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "check_name_is_str",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_name_is_str(name: object,\n                      info: QAPISourceInfo,\n                      source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a ``str``.\n    :raise QAPISemError: When ``name`` fails validation.\n    \"\"\"\n    if not isinstance(name, str):\n        raise QAPISemError(info, \"%s requires a string name\" % source)\ndef check_name_str(name: str, info: QAPISourceInfo, source: str) -> str:",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_str",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_name_str(name: str, info: QAPISourceInfo, source: str) -> str:\n    \"\"\"\n    Ensure that ``name`` is a valid QAPI name.\n    A valid name consists of ASCII letters, digits, ``-``, and ``_``,\n    starting with a letter.  It may be prefixed by a downstream prefix\n    of the form __RFQDN_, or the experimental prefix ``x-``.  If both\n    prefixes are present, the __RFDQN_ prefix goes first.\n    A valid name cannot start with ``q_``, which is reserved.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_upper",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_name_upper(name: str, info: QAPISourceInfo, source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid event name.\n    This means it must be a valid QAPI name as checked by\n    `check_name_str()`, but where the stem prohibits lowercase\n    characters and ``-``.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing what ``name`` belongs to.\n    :raise QAPISemError: When ``name`` fails validation.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_lower",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_name_lower(name: str, info: QAPISourceInfo, source: str,\n                     permit_upper: bool = False,\n                     permit_underscore: bool = False) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid command or member name.\n    This means it must be a valid QAPI name as checked by\n    `check_name_str()`, but where the stem prohibits uppercase\n    characters and ``_``.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_camel",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_name_camel(name: str, info: QAPISourceInfo, source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid user-defined type name.\n    This means it must be a valid QAPI name as checked by\n    `check_name_str()`, but where the stem must be in CamelCase.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing what ``name`` belongs to.\n    :raise QAPISemError: When ``name`` fails validation.\n    \"\"\"",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_defn_name_str",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_defn_name_str(name: str, info: QAPISourceInfo, meta: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid definition name.\n    Based on the value of ``meta``, this means that:\n      - 'event' names adhere to `check_name_upper()`.\n      - 'command' names adhere to `check_name_lower()`.\n      - Else, meta is a type, and must pass `check_name_camel()`.\n        These names must not end with ``List``.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_keys",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_keys(value: Dict[str, object],\n               info: QAPISourceInfo,\n               source: str,\n               required: List[str],\n               optional: List[str]) -> None:\n    \"\"\"\n    Ensure that a dict has a specific set of keys.\n    :param value: The dict to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing this ``value``.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_flags",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_flags(expr: QAPIExpression) -> None:\n    \"\"\"\n    Ensure flag members (if present) have valid values.\n    :param expr: The expression to validate.\n    :raise QAPISemError:\n        When certain flags have an invalid value, or when\n        incompatible flags are present.\n    \"\"\"\n    for key in ('gen', 'success-response'):\n        if key in expr and expr[key] is not False:",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_if",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_if(expr: Dict[str, object],\n             info: QAPISourceInfo, source: str) -> None:\n    \"\"\"\n    Validate the ``if`` member of an object.\n    The ``if`` member may be either a ``str`` or a dict.\n    :param expr: The expression containing the ``if`` member to validate.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing ``expr``.\n    :raise QAPISemError:\n        When the \"if\" member fails validation, or when there are no",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "normalize_members",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def normalize_members(members: object) -> None:\n    \"\"\"\n    Normalize a \"members\" value.\n    If ``members`` is a dict, for every value in that dict, if that\n    value is not itself already a dict, normalize it to\n    ``{'type': value}``.\n    :forms:\n      :sugared: ``Dict[str, Union[str, TypeRef]]``\n      :canonical: ``Dict[str, TypeRef]``\n    :param members: The members value to normalize.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_name",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_type_name(value: Optional[object],\n                    info: QAPISourceInfo, source: str) -> None:\n    if value is not None and not isinstance(value, str):\n        raise QAPISemError(info, \"%s should be a type name\" % source)\ndef check_type_name_or_array(value: Optional[object],\n                             info: QAPISourceInfo, source: str) -> None:\n    if value is None or isinstance(value, str):\n        return\n    if not isinstance(value, list):\n        raise QAPISemError(info,",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_name_or_array",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_type_name_or_array(value: Optional[object],\n                             info: QAPISourceInfo, source: str) -> None:\n    if value is None or isinstance(value, str):\n        return\n    if not isinstance(value, list):\n        raise QAPISemError(info,\n                           \"%s should be a type name or array\" % source)\n    if len(value) != 1 or not isinstance(value[0], str):\n        raise QAPISemError(info,\n                           \"%s: array type must contain single type name\" %",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_implicit",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_type_implicit(value: Optional[object],\n                        info: QAPISourceInfo, source: str,\n                        parent_name: Optional[str]) -> None:\n    \"\"\"\n    Normalize and validate an optional implicit struct type.\n    Accept ``None`` or a ``dict`` defining an implicit struct type.\n    The latter is normalized in place.\n    :param value: The value to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing this ``value``.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_name_or_implicit",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_type_name_or_implicit(value: Optional[object],\n                                info: QAPISourceInfo, source: str,\n                                parent_name: Optional[str]) -> None:\n    if value is None or isinstance(value, str):\n        return\n    check_type_implicit(value, info, source, parent_name)\ndef check_features(features: Optional[object],\n                   info: QAPISourceInfo) -> None:\n    \"\"\"\n    Normalize and validate the ``features`` member.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_features",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_features(features: Optional[object],\n                   info: QAPISourceInfo) -> None:\n    \"\"\"\n    Normalize and validate the ``features`` member.\n    ``features`` may be a ``list`` of either ``str`` or ``dict``.\n    Any ``str`` element will be normalized to ``{'name': element}``.\n    :forms:\n      :sugared: ``List[Union[str, Feature]]``\n      :canonical: ``List[Feature]``\n    :param features: The features member value to validate.",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_enum",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_enum(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as an ``enum`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``enum``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    name = expr['enum']\n    members = expr['data']\n    prefix = expr.get('prefix')",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_struct",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_struct(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as a ``struct`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``struct``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    name = cast(str, expr['struct'])  # Checked in check_exprs\n    members = expr['data']\n    check_type_implicit(members, expr.info, \"'data'\", name)",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_union",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_union(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as a ``union`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: when ``expr`` is not a valid ``union``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    name = cast(str, expr['union'])  # Checked in check_exprs\n    base = expr['base']\n    discriminator = expr['discriminator']",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_alternate",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_alternate(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as an ``alternate`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``alternate``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    members = expr['data']\n    info = expr.info\n    if not members:",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_command",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_command(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as a ``command`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``command``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    args = expr.get('data')\n    rets = expr.get('returns')\n    boxed = expr.get('boxed', False)",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_event",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_event(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as an ``event`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``event``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    args = expr.get('data')\n    boxed = expr.get('boxed', False)\n    if boxed:",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_exprs",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "def check_exprs(exprs: List[QAPIExpression]) -> List[QAPIExpression]:\n    \"\"\"\n    Validate and normalize a list of parsed QAPI schema expressions.\n    This function accepts a list of expressions and metadata as returned\n    by the parser.  It destructively normalizes the expressions in-place.\n    :param exprs: The list of expressions to normalize and validate.\n    :raise QAPISemError: When any expression fails validation.\n    :return: The same list of expressions (now modified).\n    \"\"\"\n    for expr in exprs:",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "valid_name",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.expr",
        "description": "qemu.build.scripts.qapi.expr",
        "peekOfCode": "valid_name = re.compile(r'(__[a-z0-9.-]+_)?'\n                        r'(x-)?'\n                        r'([a-z][a-z0-9_-]*)$', re.IGNORECASE)\ndef check_name_is_str(name: object,\n                      info: QAPISourceInfo,\n                      source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a ``str``.\n    :raise QAPISemError: When ``name`` fails validation.\n    \"\"\"",
        "detail": "qemu.build.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenFeatureVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.features",
        "description": "qemu.build.scripts.qapi.features",
        "peekOfCode": "class QAPISchemaGenFeatureVisitor(QAPISchemaMonolithicCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-features',\n            ' * Schema-defined QAPI features',\n            __doc__)\n        self.features: ValuesView[QAPISchemaFeature]\n    def visit_begin(self, schema: QAPISchema) -> None:\n        self.features = schema.features()\n        self._genh.add(\"#include \\\"qapi/util.h\\\"\\n\\n\")",
        "detail": "qemu.build.scripts.qapi.features",
        "documentation": {}
    },
    {
        "label": "gen_features",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.features",
        "description": "qemu.build.scripts.qapi.features",
        "peekOfCode": "def gen_features(schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str) -> None:\n    vis = QAPISchemaGenFeatureVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.build.scripts.qapi.features",
        "documentation": {}
    },
    {
        "label": "QAPIGen",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "class QAPIGen:\n    def __init__(self, fname: str):\n        self.fname = fname\n        self._preamble = ''\n        self._body = ''\n    def preamble_add(self, text: str) -> None:\n        self._preamble += text\n    def add(self, text: str) -> None:\n        self._body += text\n    def get_content(self) -> str:",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenCCode",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenCCode(QAPIGen):\n    def __init__(self, fname: str):\n        super().__init__(fname)\n        self._start_if: Optional[Tuple[QAPISchemaIfCond, str, str]] = None\n    def start_if(self, ifcond: QAPISchemaIfCond) -> None:\n        assert self._start_if is None\n        self._start_if = (ifcond, self._body, self._preamble)\n    def end_if(self) -> None:\n        assert self._start_if is not None\n        self._body = _wrap_ifcond(self._start_if[0],",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenC",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenC(QAPIGenCCode):\n    def __init__(self, fname: str, blurb: str, pydoc: str):\n        super().__init__(fname)\n        self._blurb = blurb\n        self._copyright = '\\n * '.join(re.findall(r'^Copyright .*', pydoc,\n                                                  re.MULTILINE))\n    def _top(self) -> str:\n        return mcgen('''\n/* AUTOMATICALLY GENERATED by %(tool)s DO NOT MODIFY */\n/*",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenH",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenH(QAPIGenC):\n    def _top(self) -> str:\n        return super()._top() + guardstart(self.fname)\n    def _bottom(self) -> str:\n        return guardend(self.fname)\nclass QAPIGenTrace(QAPIGen):\n    def _top(self) -> str:\n        return (super()._top()\n                + '# AUTOMATICALLY GENERATED by '\n                + os.path.basename(sys.argv[0])",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenTrace",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenTrace(QAPIGen):\n    def _top(self) -> str:\n        return (super()._top()\n                + '# AUTOMATICALLY GENERATED by '\n                + os.path.basename(sys.argv[0])\n                + ', DO NOT MODIFY\\n\\n')\n@contextmanager\ndef ifcontext(ifcond: QAPISchemaIfCond, *args: QAPIGenCCode) -> Iterator[None]:\n    \"\"\"\n    A with-statement context manager that wraps with `start_if()` / `end_if()`.",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPISchemaMonolithicCVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "class QAPISchemaMonolithicCVisitor(QAPISchemaVisitor):\n    def __init__(self,\n                 prefix: str,\n                 what: str,\n                 blurb: str,\n                 pydoc: str):\n        self._prefix = prefix\n        self._what = what\n        self._genc = QAPIGenC(self._prefix + self._what + '.c',\n                              blurb, pydoc)",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPISchemaModularCVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "class QAPISchemaModularCVisitor(QAPISchemaVisitor):\n    def __init__(self,\n                 prefix: str,\n                 what: str,\n                 user_blurb: str,\n                 builtin_blurb: Optional[str],\n                 pydoc: str,\n                 gen_tracing: bool = False):\n        self._prefix = prefix\n        self._what = what",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "gen_features",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "def gen_features(features: Sequence[QAPISchemaFeature]) -> str:\n    feats = [f\"1u << {c_enum_const('qapi_feature', feat.name)}\"\n             for feat in features]\n    return ' | '.join(feats) or '0'\nclass QAPIGen:\n    def __init__(self, fname: str):\n        self.fname = fname\n        self._preamble = ''\n        self._body = ''\n    def preamble_add(self, text: str) -> None:",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "build_params",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "def build_params(arg_type: Optional[QAPISchemaObjectType],\n                 boxed: bool,\n                 extra: Optional[str] = None) -> str:\n    ret = ''\n    sep = ''\n    if boxed:\n        assert arg_type\n        ret += '%s arg' % arg_type.c_param_type()\n        sep = ', '\n    elif arg_type:",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "ifcontext",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.gen",
        "description": "qemu.build.scripts.qapi.gen",
        "peekOfCode": "def ifcontext(ifcond: QAPISchemaIfCond, *args: QAPIGenCCode) -> Iterator[None]:\n    \"\"\"\n    A with-statement context manager that wraps with `start_if()` / `end_if()`.\n    :param ifcond: A sequence of conditionals, passed to `start_if()`.\n    :param args: any number of `QAPIGenCCode`.\n    Example::\n        with ifcontext(ifcond, self._genh, self._genc):\n            modify self._genh and self._genc ...\n    Is equivalent to calling::\n        self._genh.start_if(ifcond)",
        "detail": "qemu.build.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "Annotated",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "class Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"\n    value: _ValueT\n    ifcond: QAPISchemaIfCond\n    comment: Optional[str] = None\ndef _tree_to_qlit(obj: JSONValue,",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenIntrospectVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "class QAPISchemaGenIntrospectVisitor(QAPISchemaMonolithicCVisitor):\n    def __init__(self, prefix: str, unmask: bool):\n        super().__init__(\n            prefix, 'qapi-introspect',\n            ' * QAPI/QMP schema introspection', __doc__)\n        self._unmask = unmask\n        self._schema: Optional[QAPISchema] = None\n        self._trees: List[Annotated[SchemaInfo]] = []\n        self._used_types: List[QAPISchemaType] = []\n        self._name_map: Dict[str, str] = {}",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "to_c_string",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "def to_c_string(string: str) -> str:\n    return '\"' + string.replace('\\\\', r'\\\\').replace('\"', r'\\\"') + '\"'\nclass QAPISchemaGenIntrospectVisitor(QAPISchemaMonolithicCVisitor):\n    def __init__(self, prefix: str, unmask: bool):\n        super().__init__(\n            prefix, 'qapi-introspect',\n            ' * QAPI/QMP schema introspection', __doc__)\n        self._unmask = unmask\n        self._schema: Optional[QAPISchema] = None\n        self._trees: List[Annotated[SchemaInfo]] = []",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "gen_introspect",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "def gen_introspect(schema: QAPISchema, output_dir: str, prefix: str,\n                   opt_unmask: bool) -> None:\n    vis = QAPISchemaGenIntrospectVisitor(prefix, opt_unmask)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_Stub",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "_Stub = Any\n_Scalar = Union[str, bool, None]\n_NonScalar = Union[Dict[str, _Stub], List[_Stub]]\n_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_Scalar",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "_Scalar = Union[str, bool, None]\n_NonScalar = Union[Dict[str, _Stub], List[_Stub]]\n_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_NonScalar",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "_NonScalar = Union[Dict[str, _Stub], List[_Stub]]\n_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_Value",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "JSONValue",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "JSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfo",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoEnumMember",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoObject",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoObjectVariant",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoObjectMember",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoCommand",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"\n    value: _ValueT",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_ValueT",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.introspect",
        "description": "qemu.build.scripts.qapi.introspect",
        "peekOfCode": "_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"\n    value: _ValueT\n    ifcond: QAPISchemaIfCond",
        "detail": "qemu.build.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "invalid_prefix_char",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.main",
        "description": "qemu.build.scripts.qapi.main",
        "peekOfCode": "def invalid_prefix_char(prefix: str) -> Optional[str]:\n    match = must_match(r'([A-Za-z_.-][A-Za-z0-9_.-]*)?', prefix)\n    if match.end() != len(prefix):\n        return prefix[match.end()]\n    return None\ndef create_backend(path: str) -> QAPIBackend:\n    if path is None:\n        return QAPICBackend()\n    module_path, dot, class_name = path.rpartition('.')\n    if not dot:",
        "detail": "qemu.build.scripts.qapi.main",
        "documentation": {}
    },
    {
        "label": "create_backend",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.main",
        "description": "qemu.build.scripts.qapi.main",
        "peekOfCode": "def create_backend(path: str) -> QAPIBackend:\n    if path is None:\n        return QAPICBackend()\n    module_path, dot, class_name = path.rpartition('.')\n    if not dot:\n        raise QAPIError(\"argument of -B must be of the form MODULE.CLASS\")\n    try:\n        mod = import_module(module_path)\n    except Exception as ex:\n        raise QAPIError(f\"unable to import '{module_path}': {ex}\") from ex",
        "detail": "qemu.build.scripts.qapi.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.main",
        "description": "qemu.build.scripts.qapi.main",
        "peekOfCode": "def main() -> int:\n    \"\"\"\n    gapi-gen executable entry point.\n    Expects arguments via sys.argv, see --help for details.\n    :return: int, 0 on success, 1 on failure.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Generate code from a QAPI schema')\n    parser.add_argument('-b', '--builtins', action='store_true',\n                        help=\"generate code for built-in types\")",
        "detail": "qemu.build.scripts.qapi.main",
        "documentation": {}
    },
    {
        "label": "QAPIExpression",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.parser",
        "description": "qemu.build.scripts.qapi.parser",
        "peekOfCode": "class QAPIExpression(Dict[str, Any]):\n    # pylint: disable=too-few-public-methods\n    def __init__(self,\n                 data: Mapping[str, object],\n                 info: QAPISourceInfo,\n                 doc: Optional['QAPIDoc'] = None):\n        super().__init__(data)\n        self.info = info\n        self.doc: Optional['QAPIDoc'] = doc\nclass QAPIParseError(QAPISourceError):",
        "detail": "qemu.build.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPIParseError",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.parser",
        "description": "qemu.build.scripts.qapi.parser",
        "peekOfCode": "class QAPIParseError(QAPISourceError):\n    \"\"\"Error class for all QAPI schema parsing errors.\"\"\"\n    def __init__(self, parser: 'QAPISchemaParser', msg: str):\n        col = 1\n        for ch in parser.src[parser.line_pos:parser.pos]:\n            if ch == '\\t':\n                col = (col + 7) % 8 + 1\n            else:\n                col += 1\n        super().__init__(parser.info, msg, col)",
        "detail": "qemu.build.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPISchemaParser",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.parser",
        "description": "qemu.build.scripts.qapi.parser",
        "peekOfCode": "class QAPISchemaParser:\n    \"\"\"\n    Parse QAPI schema source.\n    Parse a JSON-esque schema file and process directives.  See\n    qapi-code-gen.rst section \"Schema Syntax\" for the exact syntax.\n    Grammatical validation is handled later by `expr.check_exprs()`.\n    :param fname: Source file name.\n    :param previously_included:\n        The absolute names of previously included source files,\n        if being invoked from another parser.",
        "detail": "qemu.build.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPIDoc",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.parser",
        "description": "qemu.build.scripts.qapi.parser",
        "peekOfCode": "class QAPIDoc:\n    \"\"\"\n    A documentation comment block, either definition or free-form\n    Definition documentation blocks consist of\n    * a body section: one line naming the definition, followed by an\n      overview (any number of lines)\n    * argument sections: a description of each argument (for commands\n      and events) or member (for structs, unions and alternates)\n    * features sections: a description of each feature flag\n    * additional (non-argument) sections, possibly tagged",
        "detail": "qemu.build.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "_ExprValue",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.parser",
        "description": "qemu.build.scripts.qapi.parser",
        "peekOfCode": "_ExprValue = Union[List[object], Dict[str, object], str, bool]\nclass QAPIExpression(Dict[str, Any]):\n    # pylint: disable=too-few-public-methods\n    def __init__(self,\n                 data: Mapping[str, object],\n                 info: QAPISourceInfo,\n                 doc: Optional['QAPIDoc'] = None):\n        super().__init__(data)\n        self.info = info\n        self.doc: Optional['QAPIDoc'] = doc",
        "detail": "qemu.build.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPISchemaIfCond",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaIfCond:\n    def __init__(\n        self,\n        ifcond: Optional[Union[str, Dict[str, object]]] = None,\n    ) -> None:\n        self.ifcond = ifcond\n    def _cgen(self) -> str:\n        return cgen_ifcond(self.ifcond)\n    def gen_if(self) -> str:\n        return gen_if(self._cgen())",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEntity",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEntity:\n    \"\"\"\n    A schema entity.\n    This is either a directive, such as include, or a definition.\n    The latter uses sub-class `QAPISchemaDefinition`.\n    \"\"\"\n    def __init__(self, info: Optional[QAPISourceInfo]):\n        self._module: Optional[QAPISchemaModule] = None\n        # For explicitly defined entities, info points to the (explicit)\n        # definition.  For builtins (and their arrays), info is None.",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaDefinition",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaDefinition(QAPISchemaEntity):\n    meta: str\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond] = None,\n        features: Optional[List[QAPISchemaFeature]] = None,\n    ):",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaVisitor:\n    def visit_begin(self, schema: QAPISchema) -> None:\n        pass\n    def visit_end(self) -> None:\n        pass\n    def visit_module(self, name: str) -> None:\n        pass\n    def visit_needed(self, entity: QAPISchemaEntity) -> bool:\n        # pylint: disable=unused-argument\n        # Default to visiting everything",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaModule",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaModule:\n    BUILTIN_MODULE_NAME = './builtin'\n    def __init__(self, name: str):\n        self.name = name\n        self._entity_list: List[QAPISchemaEntity] = []\n    @staticmethod\n    def is_system_module(name: str) -> bool:\n        \"\"\"\n        System modules are internally defined modules.\n        Their names start with the \"./\" prefix.",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaInclude",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaInclude(QAPISchemaEntity):\n    def __init__(self, sub_module: QAPISchemaModule, info: QAPISourceInfo):\n        super().__init__(info)\n        self._sub_module = sub_module\n    def visit(self, visitor: QAPISchemaVisitor) -> None:\n        super().visit(visitor)\n        visitor.visit_include(self._sub_module.name, self.info)\nclass QAPISchemaType(QAPISchemaDefinition, ABC):\n    # Return the C type for common use.\n    # For the types we commonly box, this is a pointer type.",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaType",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaType(QAPISchemaDefinition, ABC):\n    # Return the C type for common use.\n    # For the types we commonly box, this is a pointer type.\n    @abstractmethod\n    def c_type(self) -> str:\n        pass\n    # Return the C type to be used in a parameter list.\n    def c_param_type(self) -> str:\n        return self.c_type()\n    # Return the C type to be used where we suppress boxing.",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaBuiltinType",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaBuiltinType(QAPISchemaType):\n    meta = 'built-in'\n    def __init__(self, name: str, json_type: str, c_type: str):\n        super().__init__(name, None, None)\n        assert json_type in ('string', 'number', 'int', 'boolean', 'null',\n                             'value')\n        self._json_type_name = json_type\n        self._c_type_name = c_type\n    def c_name(self) -> str:\n        return self.name",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEnumType",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEnumType(QAPISchemaType):\n    meta = 'enum'\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond],\n        features: Optional[List[QAPISchemaFeature]],\n        members: List[QAPISchemaEnumMember],",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaArrayType",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaArrayType(QAPISchemaType):\n    meta = 'array'\n    def __init__(\n        self, name: str, info: Optional[QAPISourceInfo], element_type: str\n    ):\n        super().__init__(name, info, None)\n        self._element_type_name = element_type\n        self.element_type: QAPISchemaType\n    def need_has_if_optional(self) -> bool:\n        # When FOO is an array, we still need has_FOO to distinguish",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaObjectType",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaObjectType(QAPISchemaType):\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond],\n        features: Optional[List[QAPISchemaFeature]],\n        base: Optional[str],\n        local_members: List[QAPISchemaObjectTypeMember],",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaAlternateType",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaAlternateType(QAPISchemaType):\n    meta = 'alternate'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond],\n        features: List[QAPISchemaFeature],\n        alternatives: QAPISchemaAlternatives,",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVariants",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaVariants:\n    def __init__(\n        self,\n        info: QAPISourceInfo,\n        variants: List[QAPISchemaVariant],\n    ):\n        self.info = info\n        self.tag_member: QAPISchemaObjectTypeMember\n        self.variants = variants\n    def set_defined_in(self, name: str) -> None:",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaBranches",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaBranches(QAPISchemaVariants):\n    def __init__(self,\n                 info: QAPISourceInfo,\n                 variants: List[QAPISchemaVariant],\n                 tag_name: str):\n        super().__init__(info, variants)\n        self._tag_name = tag_name\n    def check(\n            self, schema: QAPISchema, seen: Dict[str, QAPISchemaMember]\n    ) -> None:",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaAlternatives",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaAlternatives(QAPISchemaVariants):\n    def __init__(self,\n                 info: QAPISourceInfo,\n                 variants: List[QAPISchemaVariant],\n                 tag_member: QAPISchemaObjectTypeMember):\n        super().__init__(info, variants)\n        self.tag_member = tag_member\n    def check(\n            self, schema: QAPISchema, seen: Dict[str, QAPISchemaMember]\n    ) -> None:",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaMember",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaMember:\n    \"\"\" Represents object members, enum members and features \"\"\"\n    role = 'member'\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        ifcond: Optional[QAPISchemaIfCond] = None,\n    ):\n        self.name = name",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEnumMember",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEnumMember(QAPISchemaMember):\n    role = 'value'\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        ifcond: Optional[QAPISchemaIfCond] = None,\n        features: Optional[List[QAPISchemaFeature]] = None,\n    ):\n        super().__init__(name, info, ifcond)",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaFeature",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaFeature(QAPISchemaMember):\n    role = 'feature'\n    # Features which are standardized across all schemas\n    SPECIAL_NAMES = ['deprecated', 'unstable']\n    def is_special(self) -> bool:\n        return self.name in QAPISchemaFeature.SPECIAL_NAMES\nclass QAPISchemaObjectTypeMember(QAPISchemaMember):\n    def __init__(\n        self,\n        name: str,",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaObjectTypeMember",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaObjectTypeMember(QAPISchemaMember):\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        typ: str,\n        optional: bool,\n        ifcond: Optional[QAPISchemaIfCond] = None,\n        features: Optional[List[QAPISchemaFeature]] = None,\n    ):",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVariant",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaVariant(QAPISchemaObjectTypeMember):\n    role = 'branch'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        typ: str,\n        ifcond: QAPISchemaIfCond,\n    ):\n        super().__init__(name, info, typ, False, ifcond)",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaCommand",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaCommand(QAPISchemaDefinition):\n    meta = 'command'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        doc: Optional[QAPIDoc],\n        ifcond: QAPISchemaIfCond,\n        features: List[QAPISchemaFeature],\n        arg_type: Optional[str],",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEvent",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEvent(QAPISchemaDefinition):\n    meta = 'event'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        doc: Optional[QAPIDoc],\n        ifcond: QAPISchemaIfCond,\n        features: List[QAPISchemaFeature],\n        arg_type: Optional[str],",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchema",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.schema",
        "description": "qemu.build.scripts.qapi.schema",
        "peekOfCode": "class QAPISchema:\n    def __init__(self, fname: str):\n        self.fname = fname\n        try:\n            parser = QAPISchemaParser(fname)\n        except OSError as err:\n            raise QAPIError(\n                f\"can't read schema file '{fname}': {err.strerror}\"\n            ) from err\n        exprs = check_exprs(parser.exprs)",
        "detail": "qemu.build.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaPragma",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.source",
        "description": "qemu.build.scripts.qapi.source",
        "peekOfCode": "class QAPISchemaPragma:\n    # Replace with @dataclass in Python 3.7+\n    # pylint: disable=too-few-public-methods\n    def __init__(self) -> None:\n        # Are documentation comments required?\n        self.doc_required = False\n        # Commands whose names may use '_'\n        self.command_name_exceptions: List[str] = []\n        # Commands allowed to return a non-dictionary\n        self.command_returns_exceptions: List[str] = []",
        "detail": "qemu.build.scripts.qapi.source",
        "documentation": {}
    },
    {
        "label": "QAPISourceInfo",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.source",
        "description": "qemu.build.scripts.qapi.source",
        "peekOfCode": "class QAPISourceInfo:\n    T = TypeVar('T', bound='QAPISourceInfo')\n    def __init__(self, fname: str, parent: Optional['QAPISourceInfo']):\n        self.fname = fname\n        self.line = 1\n        self.parent = parent\n        self.pragma: QAPISchemaPragma = (\n            parent.pragma if parent else QAPISchemaPragma()\n        )\n        self.defn_meta: Optional[str] = None",
        "detail": "qemu.build.scripts.qapi.source",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenTypeVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "class QAPISchemaGenTypeVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-types', ' * Schema-defined QAPI types',\n            ' * Built-in QAPI types', __doc__)\n    def _begin_builtin_module(self) -> None:\n        self._genc.preamble_add(mcgen('''\n#include \"qemu/osdep.h\"\n#include \"qapi/dealloc-visitor.h\"\n#include \"qapi/qapi-builtin-types.h\"",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_enum_lookup",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_enum_lookup(name: str,\n                    members: List[QAPISchemaEnumMember],\n                    prefix: Optional[str] = None) -> str:\n    max_index = c_enum_const(name, '_MAX', prefix)\n    feats = ''\n    ret = mcgen('''\nconst QEnumLookup %(c_name)s_lookup = {\n    .array = (const char *const[]) {\n''',\n                c_name=c_name(name))",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_enum",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_enum(name: str,\n             members: List[QAPISchemaEnumMember],\n             prefix: Optional[str] = None) -> str:\n    # append automatically generated _MAX value\n    enum_members = members + [QAPISchemaEnumMember('_MAX', None)]\n    ret = mcgen('''\ntypedef enum %(c_name)s {\n''',\n                c_name=c_name(name))\n    for memb in enum_members:",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_fwd_object_or_array",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_fwd_object_or_array(name: str) -> str:\n    return mcgen('''\ntypedef struct %(c_name)s %(c_name)s;\n''',\n                 c_name=c_name(name))\ndef gen_array(name: str, element_type: QAPISchemaType) -> str:\n    return mcgen('''\nstruct %(c_name)s {\n    %(c_name)s *next;\n    %(c_type)s value;",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_array",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_array(name: str, element_type: QAPISchemaType) -> str:\n    return mcgen('''\nstruct %(c_name)s {\n    %(c_name)s *next;\n    %(c_type)s value;\n};\n''',\n                 c_name=c_name(name), c_type=element_type.c_type())\ndef gen_struct_members(members: List[QAPISchemaObjectTypeMember]) -> str:\n    ret = ''",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_struct_members",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_struct_members(members: List[QAPISchemaObjectTypeMember]) -> str:\n    ret = ''\n    for memb in members:\n        ret += memb.ifcond.gen_if()\n        if memb.need_has():\n            ret += mcgen('''\n    bool has_%(c_name)s;\n''',\n                         c_name=c_name(memb.name))\n        ret += mcgen('''",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_object",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_object(name: str, ifcond: QAPISchemaIfCond,\n               base: Optional[QAPISchemaObjectType],\n               members: List[QAPISchemaObjectTypeMember],\n               variants: Optional[QAPISchemaVariants]) -> str:\n    if name in objects_seen:\n        return ''\n    objects_seen.add(name)\n    ret = ''\n    for var in variants.variants if variants else ():\n        obj = var.type",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_upcast",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_upcast(name: str, base: QAPISchemaObjectType) -> str:\n    # C makes const-correctness ugly.  We have to cast away const to let\n    # this function work for both const and non-const obj.\n    return mcgen('''\nstatic inline %(base)s *qapi_%(c_name)s_base(const %(c_name)s *obj)\n{\n    return (%(base)s *)obj;\n}\n''',\n                 c_name=c_name(name), base=base.c_name())",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_variants",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_variants(variants: QAPISchemaVariants) -> str:\n    ret = mcgen('''\n    union { /* union tag is @%(c_name)s */\n''',\n                c_name=c_name(variants.tag_member.name))\n    for var in variants.variants:\n        if var.type.name == 'q_empty':\n            continue\n        ret += var.ifcond.gen_if()\n        ret += mcgen('''",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_type_cleanup_decl",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_type_cleanup_decl(name: str) -> str:\n    ret = mcgen('''\nvoid qapi_free_%(c_name)s(%(c_name)s *obj);\nG_DEFINE_AUTOPTR_CLEANUP_FUNC(%(c_name)s, qapi_free_%(c_name)s)\n''',\n                c_name=c_name(name))\n    return ret\ndef gen_type_cleanup(name: str) -> str:\n    ret = mcgen('''\nvoid qapi_free_%(c_name)s(%(c_name)s *obj)",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_type_cleanup",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_type_cleanup(name: str) -> str:\n    ret = mcgen('''\nvoid qapi_free_%(c_name)s(%(c_name)s *obj)\n{\n    Visitor *v;\n    if (!obj) {\n        return;\n    }\n    v = qapi_dealloc_visitor_new();\n    visit_type_%(c_name)s(v, NULL, &obj, NULL);",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_types",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "def gen_types(schema: QAPISchema,\n              output_dir: str,\n              prefix: str,\n              opt_builtins: bool) -> None:\n    vis = QAPISchemaGenTypeVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir, opt_builtins)",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "objects_seen",
        "kind": 5,
        "importPath": "qemu.build.scripts.qapi.types",
        "description": "qemu.build.scripts.qapi.types",
        "peekOfCode": "objects_seen = set()\ndef gen_enum_lookup(name: str,\n                    members: List[QAPISchemaEnumMember],\n                    prefix: Optional[str] = None) -> str:\n    max_index = c_enum_const(name, '_MAX', prefix)\n    feats = ''\n    ret = mcgen('''\nconst QEnumLookup %(c_name)s_lookup = {\n    .array = (const char *const[]) {\n''',",
        "detail": "qemu.build.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenVisitVisitor",
        "kind": 6,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "class QAPISchemaGenVisitVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-visit', ' * Schema-defined QAPI visitors',\n            ' * Built-in QAPI visitors', __doc__)\n    def _begin_builtin_module(self) -> None:\n        self._genc.preamble_add(mcgen('''\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qapi-builtin-visit.h\"",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_decl",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_decl(name: str, scalar: bool = False) -> str:\n    c_type = c_name(name) + ' *'\n    if not scalar:\n        c_type += '*'\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_type)sobj, Error **errp);\n''',\n                 c_name=c_name(name), c_type=c_type)\ndef gen_visit_members_decl(name: str) -> str:",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_members_decl",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_members_decl(name: str) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s_members(Visitor *v, %(c_name)s *obj, Error **errp);\n''',\n                 c_name=c_name(name))\ndef gen_visit_object_members(name: str,\n                             base: Optional[QAPISchemaObjectType],\n                             members: List[QAPISchemaObjectTypeMember],\n                             branches: Optional[QAPISchemaBranches]) -> str:\n    ret = mcgen('''",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_object_members",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_object_members(name: str,\n                             base: Optional[QAPISchemaObjectType],\n                             members: List[QAPISchemaObjectTypeMember],\n                             branches: Optional[QAPISchemaBranches]) -> str:\n    ret = mcgen('''\nbool visit_type_%(c_name)s_members(Visitor *v, %(c_name)s *obj, Error **errp)\n{\n''',\n                c_name=c_name(name))\n    sep = ''",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_list",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_list(name: str, element_type: QAPISchemaType) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s **obj, Error **errp)\n{\n    bool ok = false;\n    %(c_name)s *tail;\n    size_t size = sizeof(**obj);\n    if (!visit_start_list(v, name, (GenericList **)obj, size, errp)) {\n        return false;",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_enum",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_enum(name: str) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s *obj, Error **errp)\n{\n    int value = *obj;\n    bool ok = visit_type_enum(v, name, &value, &%(c_name)s_lookup, errp);\n    *obj = value;\n    return ok;\n}",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_alternate",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_alternate(name: str,\n                        alternatives: QAPISchemaAlternatives) -> str:\n    ret = mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s **obj, Error **errp)\n{\n    bool ok = false;\n    if (!visit_start_alternate(v, name, (GenericAlternate **)obj,\n                               sizeof(**obj), errp)) {\n        return false;",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_object",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_object(name: str) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s **obj, Error **errp)\n{\n    bool ok = false;\n    if (!visit_start_struct(v, name, (void **)obj, sizeof(%(c_name)s), errp)) {\n        return false;\n    }\n    if (!*obj) {",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit",
        "kind": 2,
        "importPath": "qemu.build.scripts.qapi.visit",
        "description": "qemu.build.scripts.qapi.visit",
        "peekOfCode": "def gen_visit(schema: QAPISchema,\n              output_dir: str,\n              prefix: str,\n              opt_builtins: bool) -> None:\n    vis = QAPISchemaGenVisitVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir, opt_builtins)",
        "detail": "qemu.build.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "HandlersCommand",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.aio",
        "description": "qemu.build.scripts.qemugdb.aio",
        "peekOfCode": "class HandlersCommand(gdb.Command):\n    '''Display aio handlers'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu handlers', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        verbose = False\n        argv = gdb.string_to_argv(arg)\n        if len(argv) > 0 and argv[0] == '--verbose':\n            verbose = True",
        "detail": "qemu.build.scripts.qemugdb.aio",
        "documentation": {}
    },
    {
        "label": "isnull",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.aio",
        "description": "qemu.build.scripts.qemugdb.aio",
        "peekOfCode": "def isnull(ptr):\n    return ptr == gdb.Value(0).cast(ptr.type)\ndef dump_aiocontext(context, verbose):\n    '''Display a dump and backtrace for an aiocontext'''\n    cur = context['aio_handlers']['lh_first']\n    # Get pointers to functions we're going to process specially\n    sym_fd_coroutine_enter = gdb.parse_and_eval('fd_coroutine_enter')\n    while not isnull(cur):\n        entry = cur.dereference()\n        gdb.write('----\\n%s\\n' % entry)",
        "detail": "qemu.build.scripts.qemugdb.aio",
        "documentation": {}
    },
    {
        "label": "dump_aiocontext",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.aio",
        "description": "qemu.build.scripts.qemugdb.aio",
        "peekOfCode": "def dump_aiocontext(context, verbose):\n    '''Display a dump and backtrace for an aiocontext'''\n    cur = context['aio_handlers']['lh_first']\n    # Get pointers to functions we're going to process specially\n    sym_fd_coroutine_enter = gdb.parse_and_eval('fd_coroutine_enter')\n    while not isnull(cur):\n        entry = cur.dereference()\n        gdb.write('----\\n%s\\n' % entry)\n        if verbose and cur['io_read'] == sym_fd_coroutine_enter:\n            coptr = (cur['opaque'].cast(gdb.lookup_type('FDYieldUntilData').pointer()))['co']",
        "detail": "qemu.build.scripts.qemugdb.aio",
        "documentation": {}
    },
    {
        "label": "CoroutineCommand",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutineCommand(gdb.Command):\n    '''Display coroutine backtrace'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu coroutine', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        argv = gdb.string_to_argv(arg)\n        if len(argv) != 1:\n            gdb.write('usage: qemu coroutine <coroutine-pointer>\\n')\n            return",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "CoroutineBt",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutineBt(gdb.Command):\n    '''Display backtrace including coroutine switches'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu bt', gdb.COMMAND_STACK,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        gdb.execute(\"bt\")\n        try:\n            # This only works with a live session\n            co_ptr = gdb.parse_and_eval(\"qemu_coroutine_self()\")",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "CoroutineSPFunction",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutineSPFunction(gdb.Function):\n    def __init__(self):\n        gdb.Function.__init__(self, 'qemu_coroutine_sp')\n    def invoke(self, addr):\n        return get_jmpbuf_regs(coroutine_to_jmpbuf(addr))['rsp'].cast(VOID_PTR)\nclass CoroutinePCFunction(gdb.Function):\n    def __init__(self):\n        gdb.Function.__init__(self, 'qemu_coroutine_pc')\n    def invoke(self, addr):\n        return get_jmpbuf_regs(coroutine_to_jmpbuf(addr))['rip'].cast(VOID_PTR)",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "CoroutinePCFunction",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutinePCFunction(gdb.Function):\n    def __init__(self):\n        gdb.Function.__init__(self, 'qemu_coroutine_pc')\n    def invoke(self, addr):\n        return get_jmpbuf_regs(coroutine_to_jmpbuf(addr))['rip'].cast(VOID_PTR)",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "pthread_self",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def pthread_self():\n    '''Fetch the base address of TLS.'''\n    return gdb.parse_and_eval(\"$fs_base\")\ndef get_glibc_pointer_guard():\n    '''Fetch glibc pointer guard value'''\n    fs_base = pthread_self()\n    return gdb.parse_and_eval('*(uint64_t*)((uint64_t)%s + 0x30)' % fs_base)\ndef glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''\n    return gdb.parse_and_eval('(((uint64_t)%s >> 0x11) | ((uint64_t)%s << (64 - 0x11))) ^ (uint64_t)%s' % (val, val, pointer_guard))",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "get_glibc_pointer_guard",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def get_glibc_pointer_guard():\n    '''Fetch glibc pointer guard value'''\n    fs_base = pthread_self()\n    return gdb.parse_and_eval('*(uint64_t*)((uint64_t)%s + 0x30)' % fs_base)\ndef glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''\n    return gdb.parse_and_eval('(((uint64_t)%s >> 0x11) | ((uint64_t)%s << (64 - 0x11))) ^ (uint64_t)%s' % (val, val, pointer_guard))\ndef get_jmpbuf_regs(jmpbuf):\n    JB_RBX  = 0\n    JB_RBP  = 1",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "glibc_ptr_demangle",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''\n    return gdb.parse_and_eval('(((uint64_t)%s >> 0x11) | ((uint64_t)%s << (64 - 0x11))) ^ (uint64_t)%s' % (val, val, pointer_guard))\ndef get_jmpbuf_regs(jmpbuf):\n    JB_RBX  = 0\n    JB_RBP  = 1\n    JB_R12  = 2\n    JB_R13  = 3\n    JB_R14  = 4\n    JB_R15  = 5",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "get_jmpbuf_regs",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def get_jmpbuf_regs(jmpbuf):\n    JB_RBX  = 0\n    JB_RBP  = 1\n    JB_R12  = 2\n    JB_R13  = 3\n    JB_R14  = 4\n    JB_R15  = 5\n    JB_RSP  = 6\n    JB_PC   = 7\n    pointer_guard = get_glibc_pointer_guard()",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "symbol_lookup",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def symbol_lookup(addr):\n    # Example: \"__clone3 + 44 in section .text of /lib64/libc.so.6\"\n    result = gdb.execute(f\"info symbol {hex(addr)}\", to_string=True).strip()\n    try:\n        if \"+\" in result:\n            (func, result) = result.split(\" + \")\n            (offset, result) = result.split(\" in \")\n        else:\n            offset = \"0\"\n            (func, result) = result.split(\" in \")",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "dump_backtrace",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def dump_backtrace(regs):\n    '''\n    Backtrace dump with raw registers, mimic GDB command 'bt'.\n    '''\n    # Here only rbp and rip that matter..\n    rbp = regs['rbp']\n    rip = regs['rip']\n    i = 0\n    while rbp:\n        # For all return addresses on stack, we want to look up symbol/line",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "dump_backtrace_live",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def dump_backtrace_live(regs):\n    '''\n    Backtrace dump with gdb's 'bt' command, only usable in a live session.\n    '''\n    old = dict()\n    # remember current stack frame and select the topmost\n    # so that register modifications don't wreck it\n    selected_frame = gdb.selected_frame()\n    gdb.newest_frame().select()\n    for i in regs:",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "bt_jmpbuf",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def bt_jmpbuf(jmpbuf):\n    '''Backtrace a jmpbuf'''\n    regs = get_jmpbuf_regs(jmpbuf)\n    try:\n        # This reuses gdb's \"bt\" command, which can be slightly prettier\n        # but only works with live sessions.\n        dump_backtrace_live(regs)\n    except:\n        # If above doesn't work, fallback to poor man's unwind\n        dump_backtrace(regs)",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "co_cast",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def co_cast(co):\n    return co.cast(gdb.lookup_type('CoroutineUContext').pointer())\ndef coroutine_to_jmpbuf(co):\n    coroutine_pointer = co_cast(co)\n    return coroutine_pointer['env']['__jmpbuf']\nclass CoroutineCommand(gdb.Command):\n    '''Display coroutine backtrace'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu coroutine', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "coroutine_to_jmpbuf",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "def coroutine_to_jmpbuf(co):\n    coroutine_pointer = co_cast(co)\n    return coroutine_pointer['env']['__jmpbuf']\nclass CoroutineCommand(gdb.Command):\n    '''Display coroutine backtrace'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu coroutine', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        argv = gdb.string_to_argv(arg)",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "VOID_PTR",
        "kind": 5,
        "importPath": "qemu.build.scripts.qemugdb.coroutine",
        "description": "qemu.build.scripts.qemugdb.coroutine",
        "peekOfCode": "VOID_PTR = gdb.lookup_type('void').pointer()\ndef pthread_self():\n    '''Fetch the base address of TLS.'''\n    return gdb.parse_and_eval(\"$fs_base\")\ndef get_glibc_pointer_guard():\n    '''Fetch glibc pointer guard value'''\n    fs_base = pthread_self()\n    return gdb.parse_and_eval('*(uint64_t*)((uint64_t)%s + 0x30)' % fs_base)\ndef glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''",
        "detail": "qemu.build.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "MtreeCommand",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.mtree",
        "description": "qemu.build.scripts.qemugdb.mtree",
        "peekOfCode": "class MtreeCommand(gdb.Command):\n    '''Display the memory tree hierarchy'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu mtree', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n        self.queue = []\n    def invoke(self, arg, from_tty):\n        self.seen = set()\n        self.queue_root('address_space_memory')\n        self.queue_root('address_space_io')",
        "detail": "qemu.build.scripts.qemugdb.mtree",
        "documentation": {}
    },
    {
        "label": "isnull",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.mtree",
        "description": "qemu.build.scripts.qemugdb.mtree",
        "peekOfCode": "def isnull(ptr):\n    return ptr == gdb.Value(0).cast(ptr.type)\ndef int128(p):\n    '''Read an Int128 type to a python integer.\n    QEMU can be built with native Int128 support so we need to detect\n    if the value is a structure or the native type.\n    '''\n    if p.type.code == gdb.TYPE_CODE_STRUCT:\n        return int(p['lo']) + (int(p['hi']) << 64)\n    else:",
        "detail": "qemu.build.scripts.qemugdb.mtree",
        "documentation": {}
    },
    {
        "label": "int128",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemugdb.mtree",
        "description": "qemu.build.scripts.qemugdb.mtree",
        "peekOfCode": "def int128(p):\n    '''Read an Int128 type to a python integer.\n    QEMU can be built with native Int128 support so we need to detect\n    if the value is a structure or the native type.\n    '''\n    if p.type.code == gdb.TYPE_CODE_STRUCT:\n        return int(p['lo']) + (int(p['hi']) << 64)\n    else:\n        return int((\"%s\" % p), 16)\nclass MtreeCommand(gdb.Command):",
        "detail": "qemu.build.scripts.qemugdb.mtree",
        "documentation": {}
    },
    {
        "label": "TCGLockStatusCommand",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.tcg",
        "description": "qemu.build.scripts.qemugdb.tcg",
        "peekOfCode": "class TCGLockStatusCommand(gdb.Command):\n    '''Display TCG Execution Status'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu tcg-lock-status', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        gdb.write(\"Thread, BQL (iothread_mutex), Replay, Blocked?\\n\")\n        for thread in gdb.inferiors()[0].threads():\n            thread.switch()\n            iothread = gdb.parse_and_eval(\"iothread_locked\")",
        "detail": "qemu.build.scripts.qemugdb.tcg",
        "documentation": {}
    },
    {
        "label": "TimersCommand",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemugdb.timers",
        "description": "qemu.build.scripts.qemugdb.timers",
        "peekOfCode": "class TimersCommand(gdb.Command):\n    '''Display the current QEMU timers'''\n    def __init__(self):\n        'Register the class as a gdb command'\n        gdb.Command.__init__(self, 'qemu timers', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def dump_timers(self, timer):\n        \"Follow a timer and recursively dump each one in the list.\"\n        # timer should be of type QemuTimer\n        gdb.write(\"    timer %s/%s (cb:%s,opq:%s)\\n\" % (",
        "detail": "qemu.build.scripts.qemugdb.timers",
        "documentation": {}
    },
    {
        "label": "CargoTOML",
        "kind": 6,
        "importPath": "qemu.build.scripts.rust.rustc_args",
        "description": "qemu.build.scripts.rust.rustc_args",
        "peekOfCode": "class CargoTOML:\n    tomldata: Mapping[Any, Any]\n    workspace_data: Mapping[Any, Any]\n    check_cfg: Set[str]\n    def __init__(self, path: Optional[str], workspace: Optional[str]):\n        if path is not None:\n            with open(path, 'rb') as f:\n                self.tomldata = tomllib.load(f)\n        else:\n            self.tomldata = {\"lints\": {\"workspace\": True}}",
        "detail": "qemu.build.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "LintFlag",
        "kind": 6,
        "importPath": "qemu.build.scripts.rust.rustc_args",
        "description": "qemu.build.scripts.rust.rustc_args",
        "peekOfCode": "class LintFlag:\n    flags: List[str]\n    priority: int\ndef generate_lint_flags(cargo_toml: CargoTOML, strict_lints: bool) -> Iterable[str]:\n    \"\"\"Converts Cargo.toml lints to rustc -A/-D/-F/-W flags.\"\"\"\n    toml_lints = cargo_toml.lints\n    lint_list = []\n    for k, v in toml_lints.items():\n        prefix = \"\" if k == \"rust\" else k + \"::\"\n        for lint, data in v.items():",
        "detail": "qemu.build.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "generate_lint_flags",
        "kind": 2,
        "importPath": "qemu.build.scripts.rust.rustc_args",
        "description": "qemu.build.scripts.rust.rustc_args",
        "peekOfCode": "def generate_lint_flags(cargo_toml: CargoTOML, strict_lints: bool) -> Iterable[str]:\n    \"\"\"Converts Cargo.toml lints to rustc -A/-D/-F/-W flags.\"\"\"\n    toml_lints = cargo_toml.lints\n    lint_list = []\n    for k, v in toml_lints.items():\n        prefix = \"\" if k == \"rust\" else k + \"::\"\n        for lint, data in v.items():\n            level = data if isinstance(data, str) else data[\"level\"]\n            priority = 0 if isinstance(data, str) else data.get(\"priority\", 0)\n            if level == \"deny\":",
        "detail": "qemu.build.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "generate_cfg_flags",
        "kind": 2,
        "importPath": "qemu.build.scripts.rust.rustc_args",
        "description": "qemu.build.scripts.rust.rustc_args",
        "peekOfCode": "def generate_cfg_flags(header: str, cargo_toml: CargoTOML) -> Iterable[str]:\n    \"\"\"Converts defines from config[..].h headers to rustc --cfg flags.\"\"\"\n    with open(header, encoding=\"utf-8\") as cfg:\n        config = [l.split()[1:] for l in cfg if l.startswith(\"#define\")]\n    cfg_list = []\n    for cfg in config:\n        name = cfg[0]\n        if f'cfg({name})' not in cargo_toml.check_cfg:\n            continue\n        if len(cfg) >= 2 and cfg[1] != \"1\":",
        "detail": "qemu.build.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.rust.rustc_args",
        "description": "qemu.build.scripts.rust.rustc_args",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    parser.add_argument(\n        \"--config-headers\",\n        metavar=\"CONFIG_HEADER\",\n        action=\"append\",\n        dest=\"config_headers\",\n        help=\"paths to any configuration C headers (*.h files), if any\",\n        required=False,",
        "detail": "qemu.build.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "STRICT_LINTS",
        "kind": 5,
        "importPath": "qemu.build.scripts.rust.rustc_args",
        "description": "qemu.build.scripts.rust.rustc_args",
        "peekOfCode": "STRICT_LINTS = {\"unknown_lints\", \"warnings\"}\nclass CargoTOML:\n    tomldata: Mapping[Any, Any]\n    workspace_data: Mapping[Any, Any]\n    check_cfg: Set[str]\n    def __init__(self, path: Optional[str], workspace: Optional[str]):\n        if path is not None:\n            with open(path, 'rb') as f:\n                self.tomldata = tomllib.load(f)\n        else:",
        "detail": "qemu.build.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "ExtendAction",
        "kind": 6,
        "importPath": "qemu.build.scripts.simplebench.bench-backup",
        "description": "qemu.build.scripts.simplebench.bench-backup",
        "peekOfCode": "class ExtendAction(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest) or []\n        items.extend(values)\n        setattr(namespace, self.dest, items)\nif __name__ == '__main__':\n    p = argparse.ArgumentParser('Backup benchmark', epilog='''\nENV format\n    (LABEL:PATH|LABEL|PATH)[,max-workers=N][,use-copy-range=(on|off)][,mirror]\n    LABEL                short name for the binary",
        "detail": "qemu.build.scripts.simplebench.bench-backup",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench-backup",
        "description": "qemu.build.scripts.simplebench.bench-backup",
        "peekOfCode": "def bench_func(env, case):\n    \"\"\" Handle one \"cell\" of benchmarking table. \"\"\"\n    cmd_options = env['cmd-options'] if 'cmd-options' in env else {}\n    return bench_block_copy(env['qemu-binary'], env['cmd'],\n                            cmd_options,\n                            case['source'], case['target'])\ndef bench(args):\n    test_cases = []\n    # paths with colon not supported, so we just split by ':'\n    dirs = dict(d.split(':') for d in args.dir)",
        "detail": "qemu.build.scripts.simplebench.bench-backup",
        "documentation": {}
    },
    {
        "label": "bench",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench-backup",
        "description": "qemu.build.scripts.simplebench.bench-backup",
        "peekOfCode": "def bench(args):\n    test_cases = []\n    # paths with colon not supported, so we just split by ':'\n    dirs = dict(d.split(':') for d in args.dir)\n    nbd_drv = None\n    if args.nbd:\n        nbd = args.nbd.split(':')\n        host = nbd[0]\n        port = '10809' if len(nbd) == 1 else nbd[1]\n        nbd_drv = drv_nbd(host, port)",
        "detail": "qemu.build.scripts.simplebench.bench-backup",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "def bench_func(env, case):\n    \"\"\" Handle one \"cell\" of benchmarking table. \"\"\"\n    return bench_block_copy(env['qemu_binary'], env['cmd'], {},\n                            case['source'], case['target'])\n# You may set the following five variables to correct values, to turn this\n# example to real benchmark.\nssd_source = '/path-to-raw-source-image-at-ssd'\nssd_target = '/path-to-raw-target-image-at-ssd'\nhdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "ssd_source",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "ssd_source = '/path-to-raw-source-image-at-ssd'\nssd_target = '/path-to-raw-target-image-at-ssd'\nhdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "ssd_target",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "ssd_target = '/path-to-raw-target-image-at-ssd'\nhdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "hdd_target",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "hdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "nbd_ip",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "nbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)\n    },",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "nbd_port",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "nbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)\n    },\n    {",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "test_cases",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "test_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)\n    },\n    {\n        'id': 'ssd -> hdd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(hdd_target)",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "test_envs",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "test_envs = [\n    {\n        'id': 'backup-1',\n        'cmd': 'blockdev-backup',\n        'qemu_binary': '/path-to-qemu-binary-1'\n    },\n    {\n        'id': 'backup-2',\n        'cmd': 'blockdev-backup',\n        'qemu_binary': '/path-to-qemu-binary-2'",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.bench-example",
        "description": "qemu.build.scripts.simplebench.bench-example",
        "peekOfCode": "result = simplebench.bench(bench_func, test_envs, test_cases, count=3)\nprint(results_to_text(result))",
        "detail": "qemu.build.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "bench_block_job",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_block_job",
        "description": "qemu.build.scripts.simplebench.bench_block_job",
        "peekOfCode": "def bench_block_job(cmd, cmd_args, qemu_args):\n    \"\"\"Benchmark block-job\n    cmd       -- qmp command to run block-job (like blockdev-backup)\n    cmd_args  -- dict of qmp command arguments\n    qemu_args -- list of Qemu command line arguments, including path to Qemu\n                 binary\n    Returns {'seconds': int} on success and {'error': str} on failure, dict may\n    contain additional 'vm-log' field. Return value is compatible with\n    simplebench lib.\n    \"\"\"",
        "detail": "qemu.build.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "get_image_size",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_block_job",
        "description": "qemu.build.scripts.simplebench.bench_block_job",
        "peekOfCode": "def get_image_size(path):\n    out = subprocess.run(['qemu-img', 'info', '--out=json', path],\n                         stdout=subprocess.PIPE, check=True).stdout\n    return json.loads(out)['virtual-size']\ndef get_blockdev_size(obj):\n    img = obj['filename'] if 'filename' in obj else obj['file']['filename']\n    return get_image_size(img)\n# Bench backup or mirror\ndef bench_block_copy(qemu_binary, cmd, cmd_options, source, target):\n    \"\"\"Helper to run bench_block_job() for mirror or backup\"\"\"",
        "detail": "qemu.build.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "get_blockdev_size",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_block_job",
        "description": "qemu.build.scripts.simplebench.bench_block_job",
        "peekOfCode": "def get_blockdev_size(obj):\n    img = obj['filename'] if 'filename' in obj else obj['file']['filename']\n    return get_image_size(img)\n# Bench backup or mirror\ndef bench_block_copy(qemu_binary, cmd, cmd_options, source, target):\n    \"\"\"Helper to run bench_block_job() for mirror or backup\"\"\"\n    assert cmd in ('blockdev-backup', 'blockdev-mirror')\n    if target['driver'] == 'qcow2':\n        try:\n            os.remove(target['file']['filename'])",
        "detail": "qemu.build.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "bench_block_copy",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_block_job",
        "description": "qemu.build.scripts.simplebench.bench_block_job",
        "peekOfCode": "def bench_block_copy(qemu_binary, cmd, cmd_options, source, target):\n    \"\"\"Helper to run bench_block_job() for mirror or backup\"\"\"\n    assert cmd in ('blockdev-backup', 'blockdev-mirror')\n    if target['driver'] == 'qcow2':\n        try:\n            os.remove(target['file']['filename'])\n        except OSError:\n            pass\n        subprocess.run(['qemu-img', 'create', '-f', 'qcow2',\n                        target['file']['filename'],",
        "detail": "qemu.build.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_file",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_block_job",
        "description": "qemu.build.scripts.simplebench.bench_block_job",
        "peekOfCode": "def drv_file(filename, o_direct=True):\n    node = {'driver': 'file', 'filename': filename}\n    if o_direct:\n        node['cache'] = {'direct': True}\n        node['aio'] = 'native'\n    return node\ndef drv_nbd(host, port):\n    return {'driver': 'nbd',\n            'server': {'type': 'inet', 'host': host, 'port': port}}\ndef drv_qcow2(file):",
        "detail": "qemu.build.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_nbd",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_block_job",
        "description": "qemu.build.scripts.simplebench.bench_block_job",
        "peekOfCode": "def drv_nbd(host, port):\n    return {'driver': 'nbd',\n            'server': {'type': 'inet', 'host': host, 'port': port}}\ndef drv_qcow2(file):\n    return {'driver': 'qcow2', 'file': file}\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) < 4:\n        print('USAGE: {} <qmp block-job command name> '\n              '<json string of arguments for the command> '",
        "detail": "qemu.build.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_qcow2",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_block_job",
        "description": "qemu.build.scripts.simplebench.bench_block_job",
        "peekOfCode": "def drv_qcow2(file):\n    return {'driver': 'qcow2', 'file': file}\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) < 4:\n        print('USAGE: {} <qmp block-job command name> '\n              '<json string of arguments for the command> '\n              '<qemu binary path and arguments>'.format(sys.argv[0]))\n        exit(1)\n    res = bench_block_job(sys.argv[1], json.loads(sys.argv[2]), sys.argv[3:])",
        "detail": "qemu.build.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "qemu_img_bench",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_prealloc",
        "description": "qemu.build.scripts.simplebench.bench_prealloc",
        "peekOfCode": "def qemu_img_bench(args):\n    p = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                       universal_newlines=True)\n    if p.returncode == 0:\n        try:\n            m = re.search(r'Run completed in (\\d+.\\d+) seconds.', p.stdout)\n            return {'seconds': float(m.group(1))}\n        except Exception:\n            return {'error': f'failed to parse qemu-img output: {p.stdout}'}\n    else:",
        "detail": "qemu.build.scripts.simplebench.bench_prealloc",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_prealloc",
        "description": "qemu.build.scripts.simplebench.bench_prealloc",
        "peekOfCode": "def bench_func(env, case):\n    fname = f\"{case['dir']}/prealloc-test.qcow2\"\n    try:\n        os.remove(fname)\n    except OSError:\n        pass\n    subprocess.run([env['qemu-img-binary'], 'create', '-f', 'qcow2', fname,\n                   '16G'], stdout=subprocess.DEVNULL,\n                   stderr=subprocess.DEVNULL, check=True)\n    args = [env['qemu-img-binary'], 'bench', '-c', str(case['count']),",
        "detail": "qemu.build.scripts.simplebench.bench_prealloc",
        "documentation": {}
    },
    {
        "label": "auto_count_bench_func",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_prealloc",
        "description": "qemu.build.scripts.simplebench.bench_prealloc",
        "peekOfCode": "def auto_count_bench_func(env, case):\n    case['count'] = 100\n    while True:\n        res = bench_func(env, case)\n        if 'error' in res:\n            return res\n        if res['seconds'] >= 1:\n            break\n        case['count'] *= 10\n    if res['seconds'] < 5:",
        "detail": "qemu.build.scripts.simplebench.bench_prealloc",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_write_req",
        "description": "qemu.build.scripts.simplebench.bench_write_req",
        "peekOfCode": "def bench_func(env, case):\n    \"\"\" Handle one \"cell\" of benchmarking table. \"\"\"\n    return bench_write_req(env['qemu_img'], env['image_name'],\n                           case['block_size'], case['block_offset'],\n                           case['cluster_size'])\ndef qemu_img_pipe(*args):\n    '''Run qemu-img and return its output'''\n    subp = subprocess.Popen(list(args),\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT,",
        "detail": "qemu.build.scripts.simplebench.bench_write_req",
        "documentation": {}
    },
    {
        "label": "qemu_img_pipe",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_write_req",
        "description": "qemu.build.scripts.simplebench.bench_write_req",
        "peekOfCode": "def qemu_img_pipe(*args):\n    '''Run qemu-img and return its output'''\n    subp = subprocess.Popen(list(args),\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT,\n                            universal_newlines=True)\n    exitcode = subp.wait()\n    if exitcode < 0:\n        sys.stderr.write('qemu-img received signal %i: %s\\n'\n                         % (-exitcode, ' '.join(list(args))))",
        "detail": "qemu.build.scripts.simplebench.bench_write_req",
        "documentation": {}
    },
    {
        "label": "bench_write_req",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.bench_write_req",
        "description": "qemu.build.scripts.simplebench.bench_write_req",
        "peekOfCode": "def bench_write_req(qemu_img, image_name, block_size, block_offset,\n                    cluster_size):\n    \"\"\"Benchmark write requests\n    The function creates a QCOW2 image with the given path/name. Then it runs\n    the 'qemu-img bench' command and makes series of write requests on the\n    image clusters. Finally, it returns the total time of the write operations\n    on the disk.\n    qemu_img     -- path to qemu_img executable file\n    image_name   -- QCOW2 image name to create\n    block_size   -- size of a block to write to clusters",
        "detail": "qemu.build.scripts.simplebench.bench_write_req",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.img_bench_templater",
        "description": "qemu.build.scripts.simplebench.img_bench_templater",
        "peekOfCode": "def bench_func(env, case):\n    test = templater.gen(env['data'], case['data'])\n    p = subprocess.run(test, shell=True, stdout=subprocess.PIPE,\n                       stderr=subprocess.STDOUT, universal_newlines=True)\n    if p.returncode == 0:\n        try:\n            m = re.search(r'Run completed in (\\d+.\\d+) seconds.', p.stdout)\n            return {'seconds': float(m.group(1))}\n        except Exception:\n            return {'error': f'failed to parse qemu-img output: {p.stdout}'}",
        "detail": "qemu.build.scripts.simplebench.img_bench_templater",
        "documentation": {}
    },
    {
        "label": "format_value",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.results_to_text",
        "description": "qemu.build.scripts.simplebench.results_to_text",
        "peekOfCode": "def format_value(x, stdev):\n    stdev_pr = stdev / x * 100\n    if stdev_pr < 1.5:\n        # don't care too much\n        return f'{x:.2g}'\n    else:\n        return f'{x:.2g}  {math.ceil(stdev_pr)}%'\ndef result_to_text(result):\n    \"\"\"Return text representation of bench_one() returned dict.\"\"\"\n    if 'average' in result:",
        "detail": "qemu.build.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "result_to_text",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.results_to_text",
        "description": "qemu.build.scripts.simplebench.results_to_text",
        "peekOfCode": "def result_to_text(result):\n    \"\"\"Return text representation of bench_one() returned dict.\"\"\"\n    if 'average' in result:\n        s = format_value(result['average'], result['stdev'])\n        if 'n-failed' in result:\n            s += '\\n({} failed)'.format(result['n-failed'])\n        return s\n    else:\n        return 'FAILED'\ndef results_dimension(results):",
        "detail": "qemu.build.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "results_dimension",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.results_to_text",
        "description": "qemu.build.scripts.simplebench.results_to_text",
        "peekOfCode": "def results_dimension(results):\n    dim = None\n    for case in results['cases']:\n        for env in results['envs']:\n            res = results['tab'][case['id']][env['id']]\n            if dim is None:\n                dim = res['dimension']\n            else:\n                assert dim == res['dimension']\n    assert dim in ('iops', 'seconds')",
        "detail": "qemu.build.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.results_to_text",
        "description": "qemu.build.scripts.simplebench.results_to_text",
        "peekOfCode": "def results_to_text(results):\n    \"\"\"Return text representation of bench() returned dict.\"\"\"\n    n_columns = len(results['envs'])\n    named_columns = n_columns > 2\n    dim = results_dimension(results)\n    tab = []\n    if named_columns:\n        # Environment columns are named A, B, ...\n        tab.append([''] + [chr(ord('A') + i) for i in range(n_columns)])\n    tab.append([''] + [c['id'] for c in results['envs']])",
        "detail": "qemu.build.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "tabulate.PRESERVE_WHITESPACE",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.results_to_text",
        "description": "qemu.build.scripts.simplebench.results_to_text",
        "peekOfCode": "tabulate.PRESERVE_WHITESPACE = True\ndef format_value(x, stdev):\n    stdev_pr = stdev / x * 100\n    if stdev_pr < 1.5:\n        # don't care too much\n        return f'{x:.2g}'\n    else:\n        return f'{x:.2g}  {math.ceil(stdev_pr)}%'\ndef result_to_text(result):\n    \"\"\"Return text representation of bench_one() returned dict.\"\"\"",
        "detail": "qemu.build.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "do_drop_caches",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.simplebench",
        "description": "qemu.build.scripts.simplebench.simplebench",
        "peekOfCode": "def do_drop_caches():\n    subprocess.run('sync; echo 3 > /proc/sys/vm/drop_caches', shell=True,\n                   check=True)\ndef bench_one(test_func, test_env, test_case, count=5, initial_run=True,\n              slow_limit=100, drop_caches=False):\n    \"\"\"Benchmark one test-case\n    test_func   -- benchmarking function with prototype\n                   test_func(env, case), which takes test_env and test_case\n                   arguments and on success returns dict with 'seconds' or\n                   'iops' (or both) fields, specifying the benchmark result.",
        "detail": "qemu.build.scripts.simplebench.simplebench",
        "documentation": {}
    },
    {
        "label": "bench_one",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.simplebench",
        "description": "qemu.build.scripts.simplebench.simplebench",
        "peekOfCode": "def bench_one(test_func, test_env, test_case, count=5, initial_run=True,\n              slow_limit=100, drop_caches=False):\n    \"\"\"Benchmark one test-case\n    test_func   -- benchmarking function with prototype\n                   test_func(env, case), which takes test_env and test_case\n                   arguments and on success returns dict with 'seconds' or\n                   'iops' (or both) fields, specifying the benchmark result.\n                   If both 'iops' and 'seconds' provided, the 'iops' is\n                   considered the main, and 'seconds' is just an additional\n                   info. On failure test_func should return {'error': str}.",
        "detail": "qemu.build.scripts.simplebench.simplebench",
        "documentation": {}
    },
    {
        "label": "bench",
        "kind": 2,
        "importPath": "qemu.build.scripts.simplebench.simplebench",
        "description": "qemu.build.scripts.simplebench.simplebench",
        "peekOfCode": "def bench(test_func, test_envs, test_cases, *args, **vargs):\n    \"\"\"Fill benchmark table\n    test_func -- benchmarking function, see bench_one for description\n    test_envs -- list of test environments, see bench_one\n    test_cases -- list of test cases, see bench_one\n    args, vargs -- additional arguments for bench_one\n    Returns dict with the following fields:\n        'envs':  test_envs\n        'cases': test_cases\n        'tab':   filled 2D array, where cell [i][j] is bench_one result for",
        "detail": "qemu.build.scripts.simplebench.simplebench",
        "documentation": {}
    },
    {
        "label": "Templater",
        "kind": 6,
        "importPath": "qemu.build.scripts.simplebench.table_templater",
        "description": "qemu.build.scripts.simplebench.table_templater",
        "peekOfCode": "class Templater:\n    def __init__(self, template):\n        self.tree = parser.parse(template)\n        c_switches = []\n        r_switches = []\n        for x in self.tree.children:\n            if x.data == 'column_switch':\n                c_switches.append([el.children[0].value for el in x.children])\n            elif x.data == 'row_switch':\n                r_switches.append([el.children[0].value for el in x.children])",
        "detail": "qemu.build.scripts.simplebench.table_templater",
        "documentation": {}
    },
    {
        "label": "grammar",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.table_templater",
        "description": "qemu.build.scripts.simplebench.table_templater",
        "peekOfCode": "grammar = \"\"\"\nstart: ( text | column_switch | row_switch )+\ncolumn_switch: \"{\" text [\"|\" text]+ \"}\"\nrow_switch: \"[\" text [\"|\" text]+ \"]\"\ntext: /[^|{}\\[\\]]+/\n\"\"\"\nparser = Lark(grammar)\nclass Templater:\n    def __init__(self, template):\n        self.tree = parser.parse(template)",
        "detail": "qemu.build.scripts.simplebench.table_templater",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.build.scripts.simplebench.table_templater",
        "description": "qemu.build.scripts.simplebench.table_templater",
        "peekOfCode": "parser = Lark(grammar)\nclass Templater:\n    def __init__(self, template):\n        self.tree = parser.parse(template)\n        c_switches = []\n        r_switches = []\n        for x in self.tree.children:\n            if x.data == 'column_switch':\n                c_switches.append([el.children[0].value for el in x.children])\n            elif x.data == 'row_switch':",
        "detail": "qemu.build.scripts.simplebench.table_templater",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY\ndef generate_h_begin(events, group):",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "binary",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY\ndef generate_h_begin(events, group):\n    if group == \"root\":\n        header = \"trace-dtrace-root.h\"\n    else:\n        header = \"trace-dtrace-%s.h\" % group\n    # Workaround for ust backend, which also includes <sys/sdt.h> and may",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def generate_h_begin(events, group):\n    if group == \"root\":\n        header = \"trace-dtrace-root.h\"\n    else:\n        header = \"trace-dtrace-%s.h\" % group\n    # Workaround for ust backend, which also includes <sys/sdt.h> and may\n    # require SDT_USE_VARIADIC to be defined. If dtrace includes <sys/sdt.h>\n    # first without defining SDT_USE_VARIADIC then ust breaks because the\n    # STAP_PROBEV() macro is not defined.\n    out('#ifndef SDT_USE_VARIADIC')",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def generate_h(event, group):\n    out('    QEMU_%(uppername)s(%(argnames)s);',\n        uppername=event.name.upper(),\n        argnames=\", \".join(event.args.names()))\ndef generate_h_backend_dstate(event, group):\n    out('    QEMU_%(uppername)s_ENABLED() || \\\\',\n        uppername=event.name.upper())",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    QEMU_%(uppername)s_ENABLED() || \\\\',\n        uppername=event.name.upper())",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nPUBLIC = True\nPROBEPREFIX = None\ndef probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "PUBLIC = True\nPROBEPREFIX = None\ndef probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "PROBEPREFIX",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "PROBEPREFIX = None\ndef probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "BINARY",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.dtrace",
        "description": "qemu.build.scripts.tracetool.backend.dtrace",
        "peekOfCode": "BINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY\ndef generate_h_begin(events, group):\n    if group == \"root\":\n        header = \"trace-dtrace-root.h\"\n    else:\n        header = \"trace-dtrace-%s.h\" % group",
        "detail": "qemu.build.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.ftrace",
        "description": "qemu.build.scripts.tracetool.backend.ftrace",
        "peekOfCode": "def generate_h_begin(events, group):\n    out('#include \"trace/ftrace.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    {',\n        '        char ftrace_buf[MAX_TRACE_STRLEN];',\n        '        int unused __attribute__ ((unused));',",
        "detail": "qemu.build.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.ftrace",
        "description": "qemu.build.scripts.tracetool.backend.ftrace",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    {',\n        '        char ftrace_buf[MAX_TRACE_STRLEN];',\n        '        int unused __attribute__ ((unused));',\n        '        int trlen;',\n        '        if (trace_event_get_state(%(event_id)s)) {',\n        '#line %(event_lineno)d \"%(event_filename)s\"',",
        "detail": "qemu.build.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.ftrace",
        "description": "qemu.build.scripts.tracetool.backend.ftrace",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())",
        "detail": "qemu.build.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.ftrace",
        "description": "qemu.build.scripts.tracetool.backend.ftrace",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport os.path\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"trace/ftrace.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())",
        "detail": "qemu.build.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.ftrace",
        "description": "qemu.build.scripts.tracetool.backend.ftrace",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"trace/ftrace.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    {',\n        '        char ftrace_buf[MAX_TRACE_STRLEN];',",
        "detail": "qemu.build.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.log",
        "description": "qemu.build.scripts.tracetool.backend.log",
        "peekOfCode": "def generate_h_begin(events, group):\n    out('#include \"qemu/log-for-trace.h\"',\n        '#include \"qemu/error-report.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code",
        "detail": "qemu.build.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.log",
        "description": "qemu.build.scripts.tracetool.backend.log",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code\n        cond = \"true\"\n    else:\n        cond = \"trace_event_get_state(%s)\" % (\"TRACE_\" + event.name.upper())\n    out('    if (%(cond)s && qemu_loglevel_mask(LOG_TRACE)) {',",
        "detail": "qemu.build.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.log",
        "description": "qemu.build.scripts.tracetool.backend.log",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())",
        "detail": "qemu.build.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.log",
        "description": "qemu.build.scripts.tracetool.backend.log",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport os.path\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"qemu/log-for-trace.h\"',\n        '#include \"qemu/error-report.h\"',\n        '')\ndef generate_h(event, group):",
        "detail": "qemu.build.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.log",
        "description": "qemu.build.scripts.tracetool.backend.log",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"qemu/log-for-trace.h\"',\n        '#include \"qemu/error-report.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:",
        "detail": "qemu.build.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "is_string",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "def is_string(arg):\n    strtype = ('const char*', 'char*', 'const char *', 'char *')\n    arg_strip = arg.lstrip()\n    if arg_strip.startswith(strtype) and arg_strip.count('*') == 1:\n        return True\n    else:\n        return False\ndef generate_h_begin(events, group):\n    for event in events:\n        out('void _simple_%(api)s(%(args)s);',",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_h_begin(events, group):\n    for event in events:\n        out('void _simple_%(api)s(%(args)s);',\n            api=event.api(),\n            args=event.args)\n    out('')\ndef generate_h(event, group):\n    out('    _simple_%(api)s(%(args)s);',\n        api=event.api(),\n        args=\", \".join(event.args.names()))",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_h(event, group):\n    out('    _simple_%(api)s(%(args)s);',\n        api=event.api(),\n        args=\", \".join(event.args.names()))\ndef generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())\ndef generate_c_begin(events, group):\n    out('#include \"qemu/osdep.h\"',\n        '#include \"trace/control.h\"',",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())\ndef generate_c_begin(events, group):\n    out('#include \"qemu/osdep.h\"',\n        '#include \"trace/control.h\"',\n        '#include \"trace/simple.h\"',\n        '')\ndef generate_c(event, group):\n    out('void _simple_%(api)s(%(args)s)',",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_c_begin",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_c_begin(events, group):\n    out('#include \"qemu/osdep.h\"',\n        '#include \"trace/control.h\"',\n        '#include \"trace/simple.h\"',\n        '')\ndef generate_c(event, group):\n    out('void _simple_%(api)s(%(args)s)',\n        '{',\n        '    TraceBufferRecord rec;',\n        api=event.api(),",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_c",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_c(event, group):\n    out('void _simple_%(api)s(%(args)s)',\n        '{',\n        '    TraceBufferRecord rec;',\n        api=event.api(),\n        args=event.args)\n    sizes = []\n    for type_, name in event.args:\n        if is_string(type_):\n            out('    size_t arg%(name)s_len = %(name)s ? MIN(strlen(%(name)s), MAX_TRACE_STRLEN) : 0;',",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nPUBLIC = True\ndef is_string(arg):\n    strtype = ('const char*', 'char*', 'const char *', 'char *')\n    arg_strip = arg.lstrip()\n    if arg_strip.startswith(strtype) and arg_strip.count('*') == 1:\n        return True\n    else:",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.simple",
        "description": "qemu.build.scripts.tracetool.backend.simple",
        "peekOfCode": "PUBLIC = True\ndef is_string(arg):\n    strtype = ('const char*', 'char*', 'const char *', 'char *')\n    arg_strip = arg.lstrip()\n    if arg_strip.startswith(strtype) and arg_strip.count('*') == 1:\n        return True\n    else:\n        return False\ndef generate_h_begin(events, group):\n    for event in events:",
        "detail": "qemu.build.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.syslog",
        "description": "qemu.build.scripts.tracetool.backend.syslog",
        "peekOfCode": "def generate_h_begin(events, group):\n    out('#include <syslog.h>',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code\n        cond = \"true\"",
        "detail": "qemu.build.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.syslog",
        "description": "qemu.build.scripts.tracetool.backend.syslog",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code\n        cond = \"true\"\n    else:\n        cond = \"trace_event_get_state(%s)\" % (\"TRACE_\" + event.name.upper())\n    out('    if (%(cond)s) {',",
        "detail": "qemu.build.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.syslog",
        "description": "qemu.build.scripts.tracetool.backend.syslog",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())",
        "detail": "qemu.build.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.syslog",
        "description": "qemu.build.scripts.tracetool.backend.syslog",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport os.path\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include <syslog.h>',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())",
        "detail": "qemu.build.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.syslog",
        "description": "qemu.build.scripts.tracetool.backend.syslog",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include <syslog.h>',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code",
        "detail": "qemu.build.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.ust",
        "description": "qemu.build.scripts.tracetool.backend.ust",
        "peekOfCode": "def generate_h_begin(events, group):\n    header = 'trace-ust-' + group + '.h'\n    out('#include <lttng/tracepoint.h>',\n        '#include \"%s\"' % header,\n        '',\n        '/* tracepoint_enabled() was introduced in LTTng UST 2.7 */',\n        '#ifndef tracepoint_enabled',\n        '#define tracepoint_enabled(a, b) true',\n        '#endif',\n        '')",
        "detail": "qemu.build.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.ust",
        "description": "qemu.build.scripts.tracetool.backend.ust",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    tracepoint(qemu, %(name)s%(tp_args)s);',\n        name=event.name,\n        tp_args=argnames)\ndef generate_h_backend_dstate(event, group):\n    out('    tracepoint_enabled(qemu, %(name)s) || \\\\',\n        name=event.name)",
        "detail": "qemu.build.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.backend.ust",
        "description": "qemu.build.scripts.tracetool.backend.ust",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    tracepoint_enabled(qemu, %(name)s) || \\\\',\n        name=event.name)",
        "detail": "qemu.build.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.ust",
        "description": "qemu.build.scripts.tracetool.backend.ust",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    header = 'trace-ust-' + group + '.h'\n    out('#include <lttng/tracepoint.h>',\n        '#include \"%s\"' % header,\n        '',\n        '/* tracepoint_enabled() was introduced in LTTng UST 2.7 */',",
        "detail": "qemu.build.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.backend.ust",
        "description": "qemu.build.scripts.tracetool.backend.ust",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    header = 'trace-ust-' + group + '.h'\n    out('#include <lttng/tracepoint.h>',\n        '#include \"%s\"' % header,\n        '',\n        '/* tracepoint_enabled() was introduced in LTTng UST 2.7 */',\n        '#ifndef tracepoint_enabled',\n        '#define tracepoint_enabled(a, b) true',\n        '#endif',",
        "detail": "qemu.build.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.c",
        "description": "qemu.build.scripts.tracetool.format.c",
        "peekOfCode": "def generate(events, backend, group):\n    active_events = [e for e in events\n                     if \"disable\" not in e.properties]\n    header = \"trace-\" + group + \".h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',\n        '#include \"qemu/module.h\"',\n        '#include \"%s\"' % header,\n        '')",
        "detail": "qemu.build.scripts.tracetool.format.c",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.c",
        "description": "qemu.build.scripts.tracetool.format.c",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    active_events = [e for e in events\n                     if \"disable\" not in e.properties]\n    header = \"trace-\" + group + \".h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',",
        "detail": "qemu.build.scripts.tracetool.format.c",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.d",
        "description": "qemu.build.scripts.tracetool.format.d",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disable\" not in e.properties]\n    # SystemTap's dtrace(1) warns about empty \"provider qemu {}\" but is happy\n    # with an empty file.  Avoid the warning.\n    # But dtrace on macOS can't deal with empty files.\n    if not events and platform != \"darwin\":\n        return\n    out('/* This file is autogenerated by tracetool, do not edit. */'\n        '',",
        "detail": "qemu.build.scripts.tracetool.format.d",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.d",
        "description": "qemu.build.scripts.tracetool.format.d",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nfrom sys import platform\n# Reserved keywords from\n# https://wikis.oracle.com/display/DTrace/Types,+Operators+and+Expressions\nRESERVED_WORDS = (\n    'auto', 'goto', 'sizeof', 'break', 'if', 'static', 'case', 'import',\n    'string', 'char', 'inline', 'stringof', 'const', 'int', 'struct',\n    'continue', 'long', 'switch', 'counter', 'offsetof', 'this',",
        "detail": "qemu.build.scripts.tracetool.format.d",
        "documentation": {}
    },
    {
        "label": "RESERVED_WORDS",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.d",
        "description": "qemu.build.scripts.tracetool.format.d",
        "peekOfCode": "RESERVED_WORDS = (\n    'auto', 'goto', 'sizeof', 'break', 'if', 'static', 'case', 'import',\n    'string', 'char', 'inline', 'stringof', 'const', 'int', 'struct',\n    'continue', 'long', 'switch', 'counter', 'offsetof', 'this',\n    'default', 'probe', 'translator', 'do', 'provider', 'typedef',\n    'double', 'register', 'union', 'else', 'restrict', 'unsigned',\n    'enum', 'return', 'void', 'extern', 'self', 'volatile', 'float',\n    'short', 'while', 'for', 'signed', 'xlate',\n)\ndef generate(events, backend, group):",
        "detail": "qemu.build.scripts.tracetool.format.d",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.h",
        "description": "qemu.build.scripts.tracetool.format.h",
        "peekOfCode": "def generate(events, backend, group):\n    header = \"trace/control.h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#ifndef TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '#define TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '',\n        '#include \"%s\"' % header,\n        '')\n    for e in events:",
        "detail": "qemu.build.scripts.tracetool.format.h",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.h",
        "description": "qemu.build.scripts.tracetool.format.h",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    header = \"trace/control.h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#ifndef TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '#define TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '',",
        "detail": "qemu.build.scripts.tracetool.format.h",
        "documentation": {}
    },
    {
        "label": "global_var_name",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "def global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\nSTATE_SKIP = 0\nSTATE_LITERAL = 1\nSTATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "c_macro_to_format",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "def c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"\n    macro = \"\"\n    escape = 0;",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "c_fmt_to_stap",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "def c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"\n    macro = \"\"\n    escape = 0;\n    for i in range(len(fmt)):\n        if fmt[i] == '\\\\':\n            if escape:\n                escape = 0",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "def generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for event_id, e in enumerate(events):\n        if 'disable' in e.properties:\n            continue\n        out('probe %(probeprefix)s.log.%(name)s = %(probeprefix)s.%(name)s ?',\n            '{',\n            probeprefix=probeprefix(),\n            name=e.name)",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "__maintainer__ = \"Daniel Berrange\"\n__email__      = \"berrange@redhat.com\"\nimport re\nfrom tracetool import out\nfrom tracetool.backend.dtrace import binary, probeprefix\nfrom tracetool.backend.simple import is_string\nfrom tracetool.format.stap import stap_escape\ndef global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\nSTATE_SKIP = 0",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "STATE_SKIP",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "STATE_SKIP = 0\nSTATE_LITERAL = 1\nSTATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "STATE_LITERAL",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "STATE_LITERAL = 1\nSTATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "STATE_MACRO",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.log_stap",
        "description": "qemu.build.scripts.tracetool.format.log_stap",
        "peekOfCode": "STATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"\n    macro = \"\"",
        "detail": "qemu.build.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "global_var_name",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "description": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "peekOfCode": "def global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\ndef generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for event_id, e in enumerate(events):\n        if 'disable' in e.properties:\n            continue\n        out('probe %(probeprefix)s.simpletrace.%(name)s = %(probeprefix)s.%(name)s ?',\n            '{',",
        "detail": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "description": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "peekOfCode": "def generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for event_id, e in enumerate(events):\n        if 'disable' in e.properties:\n            continue\n        out('probe %(probeprefix)s.simpletrace.%(name)s = %(probeprefix)s.%(name)s ?',\n            '{',\n            probeprefix=probeprefix(),\n            name=e.name)",
        "detail": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "description": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nfrom tracetool.backend.dtrace import probeprefix\nfrom tracetool.backend.simple import is_string\nfrom tracetool.format.stap import stap_escape\ndef global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\ndef generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',",
        "detail": "qemu.build.scripts.tracetool.format.simpletrace_stap",
        "documentation": {}
    },
    {
        "label": "stap_escape",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.stap",
        "description": "qemu.build.scripts.tracetool.format.stap",
        "peekOfCode": "def stap_escape(identifier):\n    # Append underscore to reserved keywords\n    if identifier in RESERVED_WORDS:\n        return identifier + '_'\n    return identifier\ndef generate(events, backend, group):\n    events = [e for e in events\n              if \"disable\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')",
        "detail": "qemu.build.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.stap",
        "description": "qemu.build.scripts.tracetool.format.stap",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disable\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for e in events:\n        # Define prototype for probe arguments\n        out('probe %(probeprefix)s.%(name)s = process(\"%(binary)s\").mark(\"%(name)s\")',\n            '{',\n            probeprefix=probeprefix(),",
        "detail": "qemu.build.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.stap",
        "description": "qemu.build.scripts.tracetool.format.stap",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nfrom tracetool.backend.dtrace import binary, probeprefix\n# Technically 'self' is not used by systemtap yet, but\n# they recommended we keep it in the reserved list anyway\nRESERVED_WORDS = (\n    'break', 'catch', 'continue', 'delete', 'else', 'for',\n    'foreach', 'function', 'global', 'if', 'in', 'limit',\n    'long', 'next', 'probe', 'return', 'self', 'string',",
        "detail": "qemu.build.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "RESERVED_WORDS",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.stap",
        "description": "qemu.build.scripts.tracetool.format.stap",
        "peekOfCode": "RESERVED_WORDS = (\n    'break', 'catch', 'continue', 'delete', 'else', 'for',\n    'foreach', 'function', 'global', 'if', 'in', 'limit',\n    'long', 'next', 'probe', 'return', 'self', 'string',\n    'try', 'while'\n    )\ndef stap_escape(identifier):\n    # Append underscore to reserved keywords\n    if identifier in RESERVED_WORDS:\n        return identifier + '_'",
        "detail": "qemu.build.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.ust_events_c",
        "description": "qemu.build.scripts.tracetool.format.ust_events_c",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',\n        '',\n        '#define TRACEPOINT_DEFINE',\n        '#define TRACEPOINT_CREATE_PROBES',\n        '',",
        "detail": "qemu.build.scripts.tracetool.format.ust_events_c",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.ust_events_c",
        "description": "qemu.build.scripts.tracetool.format.ust_events_c",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',\n        '',",
        "detail": "qemu.build.scripts.tracetool.format.ust_events_c",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool.format.ust_events_h",
        "description": "qemu.build.scripts.tracetool.format.ust_events_h",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    if group == \"all\":\n        include = \"trace-ust-all.h\"\n    else:\n        include = \"trace-ust.h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#undef TRACEPOINT_PROVIDER',",
        "detail": "qemu.build.scripts.tracetool.format.ust_events_h",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool.format.ust_events_h",
        "description": "qemu.build.scripts.tracetool.format.ust_events_h",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    if group == \"all\":\n        include = \"trace-ust-all.h\"\n    else:\n        include = \"trace-ust.h\"",
        "detail": "qemu.build.scripts.tracetool.format.ust_events_h",
        "documentation": {}
    },
    {
        "label": "VirtFSRequestTracker",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyse-9p-simpletrace",
        "description": "qemu.build.scripts.analyse-9p-simpletrace",
        "peekOfCode": "class VirtFSRequestTracker(simpletrace.Analyzer):\n        def begin(self):\n                print(\"Pretty printing 9p simpletrace log ...\")\n        def v9fs_rerror(self, tag, id, err):\n                print(\"RERROR (tag =\", tag, \", id =\", symbol_9p[id], \", err = \\\"\", os.strerror(err), \"\\\")\")\n        def v9fs_version(self, tag, id, msize, version):\n                print(\"TVERSION (tag =\", tag, \", msize =\", msize, \", version =\", version, \")\")\n        def v9fs_version_return(self, tag, id, msize, version):\n                print(\"RVERSION (tag =\", tag, \", msize =\", msize, \", version =\", version, \")\")\n        def v9fs_attach(self, tag, id, fid, afid, uname, aname):",
        "detail": "qemu.build.scripts.analyse-9p-simpletrace",
        "documentation": {}
    },
    {
        "label": "symbol_9p",
        "kind": 5,
        "importPath": "qemu.build.scripts.analyse-9p-simpletrace",
        "description": "qemu.build.scripts.analyse-9p-simpletrace",
        "peekOfCode": "symbol_9p = {\n    6   : 'TLERROR',\n    7   : 'RLERROR',\n    8   : 'TSTATFS',\n    9   : 'RSTATFS',\n    12  : 'TLOPEN',\n    13  : 'RLOPEN',\n    14  : 'TLCREATE',\n    15  : 'RLCREATE',\n    16  : 'TSYMLINK',",
        "detail": "qemu.build.scripts.analyse-9p-simpletrace",
        "documentation": {}
    },
    {
        "label": "MutexAnalyser",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyse-locks-simpletrace",
        "description": "qemu.build.scripts.analyse-locks-simpletrace",
        "peekOfCode": "class MutexAnalyser(simpletrace.Analyzer):\n    \"A simpletrace Analyser for checking locks.\"\n    def __init__(self):\n        self.locks = 0\n        self.locked = 0\n        self.unlocks = 0\n        self.mutex_records = {}\n    def _get_mutex(self, mutex):\n        if not mutex in self.mutex_records:\n            self.mutex_records[mutex] = {\"locks\": 0,",
        "detail": "qemu.build.scripts.analyse-locks-simpletrace",
        "documentation": {}
    },
    {
        "label": "get_args",
        "kind": 2,
        "importPath": "qemu.build.scripts.analyse-locks-simpletrace",
        "description": "qemu.build.scripts.analyse-locks-simpletrace",
        "peekOfCode": "def get_args():\n    \"Grab options\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--output\", \"-o\", type=str, help=\"Render plot to file\")\n    parser.add_argument(\"events\", type=str, help='trace file read from')\n    parser.add_argument(\"tracefile\", type=str, help='trace file read from')\n    return parser.parse_args()\nif __name__ == '__main__':\n    args = get_args()\n    # Gather data from the trace",
        "detail": "qemu.build.scripts.analyse-locks-simpletrace",
        "documentation": {}
    },
    {
        "label": "MigrationFile",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class MigrationFile(object):\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = open(self.filename, \"rb\")\n    def read64(self):\n        return int.from_bytes(self.file.read(8), byteorder='big', signed=False)\n    def read32(self):\n        return int.from_bytes(self.file.read(4), byteorder='big', signed=False)\n    def read16(self):\n        return int.from_bytes(self.file.read(2), byteorder='big', signed=False)",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "RamSection",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class RamSection(object):\n    RAM_SAVE_FLAG_COMPRESS = 0x02\n    RAM_SAVE_FLAG_MEM_SIZE = 0x04\n    RAM_SAVE_FLAG_PAGE     = 0x08\n    RAM_SAVE_FLAG_EOS      = 0x10\n    RAM_SAVE_FLAG_CONTINUE = 0x20\n    RAM_SAVE_FLAG_XBZRLE   = 0x40\n    RAM_SAVE_FLAG_HOOK     = 0x80\n    RAM_SAVE_FLAG_COMPRESS_PAGE = 0x100\n    RAM_SAVE_FLAG_MULTIFD_FLUSH = 0x200",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "HTABSection",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class HTABSection(object):\n    HASH_PTE_SIZE_64       = 16\n    def __init__(self, file, version_id, device, section_key):\n        if version_id != 1:\n            raise Exception(\"Unknown HTAB version %d\" % version_id)\n        self.file = file\n        self.section_key = section_key\n    def read(self):\n        header = self.file.read32()\n        if (header == -1):",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "S390StorageAttributes",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class S390StorageAttributes(object):\n    STATTR_FLAG_EOS   = 0x01\n    STATTR_FLAG_MORE  = 0x02\n    STATTR_FLAG_ERROR = 0x04\n    STATTR_FLAG_DONE  = 0x08\n    def __init__(self, file, version_id, device, section_key):\n        if version_id != 0:\n            raise Exception(\"Unknown storage_attributes version %d\" % version_id)\n        self.file = file\n        self.section_key = section_key",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "ConfigurationSection",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class ConfigurationSection(object):\n    def __init__(self, file, desc):\n        self.file = file\n        self.desc = desc\n        self.caps = []\n    def parse_capabilities(self, vmsd_caps):\n        if not vmsd_caps:\n            return\n        ncaps = vmsd_caps.data['caps_count'].data\n        self.caps = vmsd_caps.data['capabilities']",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldGeneric",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldGeneric(object):\n    def __init__(self, desc, file):\n        self.file = file\n        self.desc = desc\n        self.data = \"\"\n    def __repr__(self):\n        return str(self.__str__())\n    def __str__(self):\n        return \" \".join(\"{0:02x}\".format(c) for c in self.data)\n    def getDict(self):",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldCap",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldCap(object):\n    def __init__(self, desc, file):\n        self.file = file\n        self.desc = desc\n        self.data = \"\"\n    def __repr__(self):\n        return self.data\n    def __str__(self):\n        return self.data\n    def read(self):",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldInt",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldInt(VMSDFieldGeneric):\n    def __init__(self, desc, file):\n        super(VMSDFieldInt, self).__init__(desc, file)\n        self.size = int(desc['size'])\n        self.format = '0x%%0%dx' % (self.size * 2)\n        self.sdtype = '>i%d' % self.size\n        self.udtype = '>u%d' % self.size\n    def __repr__(self):\n        if self.data < 0:\n            return ('%s (%d)' % ((self.format % self.udata), self.data))",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldUInt",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldUInt(VMSDFieldInt):\n    def __init__(self, desc, file):\n        super(VMSDFieldUInt, self).__init__(desc, file)\n    def read(self):\n        super(VMSDFieldUInt, self).read()\n        self.data = self.udata\n        return self.data\nclass VMSDFieldIntLE(VMSDFieldInt):\n    def __init__(self, desc, file):\n        super(VMSDFieldIntLE, self).__init__(desc, file)",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldIntLE",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldIntLE(VMSDFieldInt):\n    def __init__(self, desc, file):\n        super(VMSDFieldIntLE, self).__init__(desc, file)\n        self.dtype = '<i%d' % self.size\nclass VMSDFieldNull(VMSDFieldGeneric):\n    NULL_PTR_MARKER = b'0'\n    def __init__(self, desc, file):\n        super(VMSDFieldNull, self).__init__(desc, file)\n    def __repr__(self):\n        # A NULL pointer is encoded in the stream as a '0' to",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldNull",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldNull(VMSDFieldGeneric):\n    NULL_PTR_MARKER = b'0'\n    def __init__(self, desc, file):\n        super(VMSDFieldNull, self).__init__(desc, file)\n    def __repr__(self):\n        # A NULL pointer is encoded in the stream as a '0' to\n        # disambiguate from a mere 0x0 value and avoid consumers\n        # trying to follow the NULL pointer. Displaying '0', 0x30 or\n        # 0x0 when analyzing the JSON debug stream could become\n        # confusing, so use an explicit term instead.",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldBool",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldBool(VMSDFieldGeneric):\n    def __init__(self, desc, file):\n        super(VMSDFieldBool, self).__init__(desc, file)\n    def __repr__(self):\n        return self.data.__repr__()\n    def __str__(self):\n        return self.data.__str__()\n    def getDict(self):\n        return self.data\n    def read(self):",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldStruct",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldStruct(VMSDFieldGeneric):\n    QEMU_VM_SUBSECTION    = 0x05\n    def __init__(self, desc, file):\n        super(VMSDFieldStruct, self).__init__(desc, file)\n        self.data = collections.OrderedDict()\n        if 'fields' not in self.desc['struct']:\n            raise Exception(\"No fields in struct. VMSD:\\n%s\" % self.desc)\n        # When we see compressed array elements, unfold them here\n        new_fields = []\n        for field in self.desc['struct']['fields']:",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDSection",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class VMSDSection(VMSDFieldStruct):\n    def __init__(self, file, version_id, device, section_key):\n        self.file = file\n        self.data = \"\"\n        self.vmsd_name = \"\"\n        self.section_key = section_key\n        desc = device\n        if 'vmsd_name' in device:\n            self.vmsd_name = device['vmsd_name']\n        # A section really is nothing but a FieldStruct :)",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "MigrationDump",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class MigrationDump(object):\n    QEMU_VM_FILE_MAGIC    = 0x5145564d\n    QEMU_VM_FILE_VERSION  = 0x00000003\n    QEMU_VM_EOF           = 0x00\n    QEMU_VM_SECTION_START = 0x01\n    QEMU_VM_SECTION_PART  = 0x02\n    QEMU_VM_SECTION_END   = 0x03\n    QEMU_VM_SECTION_FULL  = 0x04\n    QEMU_VM_SUBSECTION    = 0x05\n    QEMU_VM_VMDESCRIPTION = 0x06",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "JSONEncoder",
        "kind": 6,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "class JSONEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, VMSDFieldGeneric):\n            return str(o)\n        return json.JSONEncoder.default(self, o)\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-f\", \"--file\", help='migration dump to read from', required=True)\nparser.add_argument(\"-m\", \"--memory\", help='dump RAM contents as well', action='store_true')\nparser.add_argument(\"-d\", \"--dump\", help='what to dump (\"state\" or \"desc\")', default='state')\nparser.add_argument(\"-x\", \"--extract\", help='extract contents into individual files', action='store_true')",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "def mkdir_p(path):\n    try:\n        os.makedirs(path)\n    except OSError:\n        pass\nclass MigrationFile(object):\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = open(self.filename, \"rb\")\n    def read64(self):",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "vmsd_field_readers",
        "kind": 5,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "vmsd_field_readers = {\n    \"bool\" : VMSDFieldBool,\n    \"int8\" : VMSDFieldInt,\n    \"int16\" : VMSDFieldInt,\n    \"int32\" : VMSDFieldInt,\n    \"int32 equal\" : VMSDFieldInt,\n    \"int32 le\" : VMSDFieldIntLE,\n    \"int64\" : VMSDFieldInt,\n    \"uint8\" : VMSDFieldUInt,\n    \"uint16\" : VMSDFieldUInt,",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"-f\", \"--file\", help='migration dump to read from', required=True)\nparser.add_argument(\"-m\", \"--memory\", help='dump RAM contents as well', action='store_true')\nparser.add_argument(\"-d\", \"--dump\", help='what to dump (\"state\" or \"desc\")', default='state')\nparser.add_argument(\"-x\", \"--extract\", help='extract contents into individual files', action='store_true')\nargs = parser.parse_args()\njsonenc = JSONEncoder(indent=4, separators=(',', ': '))\nif not any([args.extract, args.dump == \"state\", args.dump == \"desc\"]):\n    raise Exception(\"Please specify either -x, -d state or -d desc\")\ntry:",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "args = parser.parse_args()\njsonenc = JSONEncoder(indent=4, separators=(',', ': '))\nif not any([args.extract, args.dump == \"state\", args.dump == \"desc\"]):\n    raise Exception(\"Please specify either -x, -d state or -d desc\")\ntry:\n    dump = MigrationDump(args.file)\n    if args.extract:\n        dump.read(desc_only = True)\n        print(\"desc.json\")\n        f = open(\"desc.json\", \"w\")",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "jsonenc",
        "kind": 5,
        "importPath": "qemu.build.scripts.analyze-migration",
        "description": "qemu.build.scripts.analyze-migration",
        "peekOfCode": "jsonenc = JSONEncoder(indent=4, separators=(',', ': '))\nif not any([args.extract, args.dump == \"state\", args.dump == \"desc\"]):\n    raise Exception(\"Please specify either -x, -d state or -d desc\")\ntry:\n    dump = MigrationDump(args.file)\n    if args.extract:\n        dump.read(desc_only = True)\n        print(\"desc.json\")\n        f = open(\"desc.json\", \"w\")\n        f.truncate()",
        "detail": "qemu.build.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "ParamDecl",
        "kind": 6,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "class ParamDecl:\n    param_re = re.compile(r'(?P<decl>'\n                          r'(?P<type>.*[ *])'\n                          r'(?P<name>[a-z][a-z0-9_]*)'\n                          r')')\n    def __init__(self, param_decl: str) -> None:\n        m = self.param_re.match(param_decl.strip())\n        if m is None:\n            raise ValueError(f'Wrong parameter declaration: \"{param_decl}\"')\n        self.decl = m.group('decl')",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "FuncDecl",
        "kind": 6,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "class FuncDecl:\n    def __init__(self, wrapper_type: str, return_type: str, name: str,\n                 args: str, variant: str) -> None:\n        self.return_type = return_type.strip()\n        self.name = name.strip()\n        self.struct_name = snake_to_camel(self.name)\n        self.args = [ParamDecl(arg.strip()) for arg in args.split(',')]\n        self.create_only_co = 'mixed' not in variant\n        self.graph_rdlock = 'bdrv_rdlock' in variant\n        self.graph_wrlock = 'bdrv_wrlock' in variant",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_header",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_header():\n    copyright = re.sub('^.*Copyright', 'Copyright', __doc__, flags=re.DOTALL)\n    copyright = re.sub('^(?=.)', ' * ', copyright.strip(), flags=re.MULTILINE)\n    copyright = re.sub('^$', ' *', copyright, flags=re.MULTILINE)\n    return f\"\"\"\\\n/*\n * File is generated by scripts/block-coroutine-wrapper.py\n *\n{copyright}\n */",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "func_decl_iter",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def func_decl_iter(text: str) -> Iterator:\n    for m in func_decl_re.finditer(text):\n        yield FuncDecl(wrapper_type=m.group('wrapper_type'),\n                       return_type=m.group('return_type'),\n                       name=m.group('wrapper_name'),\n                       args=m.group('args'),\n                       variant=m.group('variant'))\ndef snake_to_camel(func_name: str) -> str:\n    \"\"\"\n    Convert underscore names like 'some_function_name' to camel-case like",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "snake_to_camel",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def snake_to_camel(func_name: str) -> str:\n    \"\"\"\n    Convert underscore names like 'some_function_name' to camel-case like\n    'SomeFunctionName'\n    \"\"\"\n    words = func_name.split('_')\n    words = [w[0].upper() + w[1:] for w in words]\n    return ''.join(words)\ndef create_mixed_wrapper(func: FuncDecl) -> str:\n    \"\"\"",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "create_mixed_wrapper",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def create_mixed_wrapper(func: FuncDecl) -> str:\n    \"\"\"\n    Checks if we are already in coroutine\n    \"\"\"\n    name = func.target_name\n    struct_name = func.struct_name\n    graph_assume_lock = 'assume_graph_lock();' if func.graph_rdlock else ''\n    return f\"\"\"\\\n{func.return_type} {func.name}({ func.gen_list('{decl}') })\n{{",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "create_co_wrapper",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def create_co_wrapper(func: FuncDecl) -> str:\n    \"\"\"\n    Assumes we are not in coroutine, and creates one\n    \"\"\"\n    name = func.target_name\n    struct_name = func.struct_name\n    return f\"\"\"\\\n{func.return_type} {func.name}({ func.gen_list('{decl}') })\n{{\n    {struct_name} s = {{",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_co_wrapper",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_co_wrapper(func: FuncDecl) -> str:\n    assert not '_co_' in func.name\n    assert func.wrapper_type == 'co'\n    name = func.target_name\n    struct_name = func.struct_name\n    graph_lock=''\n    graph_unlock=''\n    if func.graph_rdlock:\n        graph_lock='    bdrv_graph_co_rdlock();'\n        graph_unlock='    bdrv_graph_co_rdunlock();'",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_no_co_wrapper",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_no_co_wrapper(func: FuncDecl) -> str:\n    assert '_co_' in func.name\n    assert func.wrapper_type == 'no_co'\n    name = func.target_name\n    struct_name = func.struct_name\n    graph_lock=''\n    graph_unlock=''\n    if func.graph_rdlock:\n        graph_lock='    bdrv_graph_rdlock_main_loop();'\n        graph_unlock='    bdrv_graph_rdunlock_main_loop();'",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_wrappers",
        "kind": 2,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_wrappers(input_code: str) -> str:\n    res = ''\n    for func in func_decl_iter(input_code):\n        res += '\\n\\n\\n'\n        if func.wrapper_type == 'co':\n            res += gen_co_wrapper(func)\n        else:\n            res += gen_no_co_wrapper(func)\n    return res\nif __name__ == '__main__':",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "func_decl_re",
        "kind": 5,
        "importPath": "qemu.build.scripts.block-coroutine-wrapper",
        "description": "qemu.build.scripts.block-coroutine-wrapper",
        "peekOfCode": "func_decl_re = re.compile(r'^(?P<return_type>[a-zA-Z][a-zA-Z0-9_]* [\\*]?)'\n                          r'(\\s*coroutine_fn)?'\n                          r'\\s*(?P<wrapper_type>(no_)?co)_wrapper'\n                          r'(?P<variant>(_[a-z][a-z0-9_]*)?)\\s*'\n                          r'(?P<wrapper_name>[a-z][a-z0-9_]*)'\n                          r'\\((?P<args>[^)]*)\\);$', re.MULTILINE)\ndef func_decl_iter(text: str) -> Iterator:\n    for m in func_decl_re.finditer(text):\n        yield FuncDecl(wrapper_type=m.group('wrapper_type'),\n                       return_type=m.group('return_type'),",
        "detail": "qemu.build.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "cmdline_for_sparse",
        "kind": 2,
        "importPath": "qemu.build.scripts.check_sparse",
        "description": "qemu.build.scripts.check_sparse",
        "peekOfCode": "def cmdline_for_sparse(sparse, cmdline):\n    # Do not include the C compiler executable\n    skip = True\n    arg = False\n    out = sparse + ['-no-compile']\n    for x in cmdline:\n        if arg:\n            out.append(x)\n            arg = False\n            continue",
        "detail": "qemu.build.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "build_path",
        "kind": 2,
        "importPath": "qemu.build.scripts.check_sparse",
        "description": "qemu.build.scripts.check_sparse",
        "peekOfCode": "def build_path(s):\n    return s if not root_path else os.path.join(root_path, s)\nccjson_path = build_path(sys.argv[1])\nwith open(ccjson_path, 'r') as fd:\n    compile_commands = json.load(fd)\nsparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)",
        "detail": "qemu.build.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "root_path",
        "kind": 5,
        "importPath": "qemu.build.scripts.check_sparse",
        "description": "qemu.build.scripts.check_sparse",
        "peekOfCode": "root_path = os.getenv('MESON_BUILD_ROOT')\ndef build_path(s):\n    return s if not root_path else os.path.join(root_path, s)\nccjson_path = build_path(sys.argv[1])\nwith open(ccjson_path, 'r') as fd:\n    compile_commands = json.load(fd)\nsparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])",
        "detail": "qemu.build.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "ccjson_path",
        "kind": 5,
        "importPath": "qemu.build.scripts.check_sparse",
        "description": "qemu.build.scripts.check_sparse",
        "peekOfCode": "ccjson_path = build_path(sys.argv[1])\nwith open(ccjson_path, 'r') as fd:\n    compile_commands = json.load(fd)\nsparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)\n    print('REAL_CC=%s' % shlex.quote(cmdline[0]),\n          ' '.join((shlex.quote(x) for x in cmd)))",
        "detail": "qemu.build.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "sparse",
        "kind": 5,
        "importPath": "qemu.build.scripts.check_sparse",
        "description": "qemu.build.scripts.check_sparse",
        "peekOfCode": "sparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)\n    print('REAL_CC=%s' % shlex.quote(cmdline[0]),\n          ' '.join((shlex.quote(x) for x in cmd)))\n    sparse_env['REAL_CC'] = cmdline[0]\n    r = subprocess.run(cmd, env=sparse_env, cwd=root_path)\n    if r.returncode != 0:",
        "detail": "qemu.build.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "sparse_env",
        "kind": 5,
        "importPath": "qemu.build.scripts.check_sparse",
        "description": "qemu.build.scripts.check_sparse",
        "peekOfCode": "sparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)\n    print('REAL_CC=%s' % shlex.quote(cmdline[0]),\n          ' '.join((shlex.quote(x) for x in cmd)))\n    sparse_env['REAL_CC'] = cmdline[0]\n    r = subprocess.run(cmd, env=sparse_env, cwd=root_path)\n    if r.returncode != 0:\n        sys.exit(r.returncode)",
        "detail": "qemu.build.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "Driver",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class Driver():\n    def __init__(self, vm: QEMUMachine, name: str, abstract: bool) -> None:\n        self.vm = vm\n        self.name = name\n        self.abstract = abstract\n        self.parent: Optional[Driver] = None\n        self.property_getter: Optional[Driver] = None\n    def get_prop(self, driver: str, prop: str) -> str:\n        if self.property_getter:\n            return self.property_getter.get_prop(driver, prop)",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUObject",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class QEMUObject(Driver):\n    def __init__(self, vm: QEMUMachine, name: str) -> None:\n        super().__init__(vm, name, True)\n    def set_implementations(self, implementations: List[Driver]) -> None:\n        self.implementations = implementations\n        # each implementation of the abstract driver has to use property getter\n        # of this abstract driver unless it has specialization. (e.g. having\n        # 'device' and 'x86_64-cpu', property getter of 'x86_64-cpu' will be\n        # used for '486-x86_64-cpu')\n        for impl in implementations:",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUDevice",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class QEMUDevice(QEMUObject):\n    def __init__(self, vm: QEMUMachine) -> None:\n        super().__init__(vm, 'device')\n        self.cached: Dict[str, List[Dict[str, Any]]] = {}\n    def get_prop(self, driver: str, prop_name: str) -> str:\n        if driver not in self.cached:\n            self.cached[driver] = self.vm.cmd('device-list-properties',\n                                              typename=driver)\n        for prop in self.cached[driver]:\n            if prop['name'] == prop_name:",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUx86CPU",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class QEMUx86CPU(QEMUObject):\n    def __init__(self, vm: QEMUMachine) -> None:\n        super().__init__(vm, 'x86_64-cpu')\n        self.cached: Dict[str, Dict[str, Any]] = {}\n    def get_prop(self, driver: str, prop_name: str) -> str:\n        if not driver.endswith('-x86_64-cpu'):\n            return 'Wrong x86_64-cpu name'\n        # crop last 11 chars '-x86_64-cpu'\n        name = driver[:-11]\n        if name not in self.cached:",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUMemoryBackend",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class QEMUMemoryBackend(QEMUObject):\n    def __init__(self, vm: QEMUMachine) -> None:\n        super().__init__(vm, 'memory-backend')\n        self.cached: Dict[str, List[Dict[str, Any]]] = {}\n    def get_prop(self, driver: str, prop_name: str) -> str:\n        if driver not in self.cached:\n            self.cached[driver] = self.vm.cmd('qom-list-properties',\n                                              typename=driver)\n        for prop in self.cached[driver]:\n            if prop['name'] == prop_name:",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "VMPropertyGetter",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class VMPropertyGetter:\n    \"\"\"It implements the relationship between drivers and how to get their\n    properties\"\"\"\n    def __init__(self, vm: QEMUMachine) -> None:\n        self.drivers: Dict[str, Driver] = {}\n        qom_all_types = vm.cmd('qom-list-types', abstract=True)\n        self.drivers = {t['name']: new_driver(vm, t['name'],\n                                              t.get('abstract', False))\n                        for t in qom_all_types}\n        for t in qom_all_types:",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "Machine",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class Machine:\n    \"\"\"A short QEMU machine type description. It contains only processed\n    compat_props (properties of abstract classes are applied to its\n    implementations)\n    \"\"\"\n    # raw_mt_dict - dict produced by `query-machines`\n    def __init__(self, raw_mt_dict: Dict[str, Any],\n                 qemu_drivers: VMPropertyGetter) -> None:\n        self.name = raw_mt_dict['name']\n        self.compat_props: Dict[str, Any] = {}",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "Configuration",
        "kind": 6,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "class Configuration():\n    \"\"\"Class contains all necessary components to generate table and is used\n    to compare different binaries\"\"\"\n    def __init__(self, vm: QEMUMachine,\n                 req_mt: List[str], all_mt: bool) -> None:\n        self._vm = vm\n        self._binary = vm.binary\n        self._qemu_args = args.qemu_args.split(' ')\n        self._qemu_drivers = VMPropertyGetter(vm)\n        self.req_mt = get_req_mt(self._qemu_drivers, vm, req_mt, all_mt)",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "new_driver",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def new_driver(vm: QEMUMachine, name: str, is_abstr: bool) -> Driver:\n    if name == 'object':\n        return QEMUObject(vm, 'object')\n    elif name == 'device':\n        return QEMUDevice(vm)\n    elif name == 'x86_64-cpu':\n        return QEMUx86CPU(vm)\n    elif name == 'memory-backend':\n        return QEMUMemoryBackend(vm)\n    else:",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def parse_args() -> Namespace:\n    parser = ArgumentParser(formatter_class=RawTextHelpFormatter,\n                            description=script_desc)\n    parser.add_argument('--format', choices=['human-readable', 'json', 'csv'],\n                        default='human-readable',\n                        help='returns table in json format')\n    parser.add_argument('--raw', action='store_true',\n                        help='prints ALL defined properties without value '\n                             'transformation. By default, only rows '\n                             'with different values will be printed and '",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "mt_comp",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def mt_comp(mt: Machine) -> Tuple[str, int, int, int]:\n    \"\"\"Function to compare and sort machine by names.\n    It returns socket_name, major version, minor version, revision\"\"\"\n    # none, microvm, x-remote and etc.\n    if '-' not in mt.name or '.' not in mt.name:\n        return mt.name, 0, 0, 0\n    socket, ver = mt.name.rsplit('-', 1)\n    ver_list = list(map(int, ver.split('.', 2)))\n    ver_list += [0] * (3 - len(ver_list))\n    return socket, ver_list[0], ver_list[1], ver_list[2]",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "get_mt_definitions",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def get_mt_definitions(qemu_drivers: VMPropertyGetter,\n                       vm: QEMUMachine) -> List[Machine]:\n    \"\"\"Constructs list of machine definitions (primarily compat_props) via\n    info from QEMU\"\"\"\n    raw_mt_defs = vm.cmd('query-machines', compat_props=True)\n    mt_defs = []\n    for raw_mt in raw_mt_defs:\n        mt_defs.append(Machine(raw_mt, qemu_drivers))\n    mt_defs.sort(key=mt_comp)\n    return mt_defs",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "get_req_mt",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def get_req_mt(qemu_drivers: VMPropertyGetter, vm: QEMUMachine,\n               req_mt: Optional[List[str]], all_mt: bool) -> List[Machine]:\n    \"\"\"Returns list of requested by user machines\"\"\"\n    mt_defs = get_mt_definitions(qemu_drivers, vm)\n    if all_mt:\n        return mt_defs\n    if req_mt is None:\n        print('Enter machine types for comparision')\n        exit(0)\n    matched_mt = []",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "get_affected_props",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def get_affected_props(configs: List[Configuration]) -> Generator[Tuple[str,\n                                                                        str],\n                                                                  None, None]:\n    \"\"\"Helps to go through all affected in machine definitions drivers\n    and properties\"\"\"\n    driver_props: Dict[str, Set[Any]] = {}\n    for config in configs:\n        for mt in config.req_mt:\n            compat_props = mt.compat_props\n            for driver, prop in compat_props.items():",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "transform_value",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def transform_value(value: str) -> Union[str, bool]:\n    true_list = ['true', 'on']\n    false_list = ['false', 'off']\n    out = value.lower()\n    if out in true_list:\n        return True\n    if out in false_list:\n        return False\n    return value\ndef simplify_table(table: pd.DataFrame) -> pd.DataFrame:",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "simplify_table",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def simplify_table(table: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"transforms values to make it easier to compare it and drops rows\n    with the same values for all columns\"\"\"\n    table = table.map(transform_value)\n    return table[~table.iloc[:, 3:].eq(table.iloc[:, 2], axis=0).all(axis=1)]\n# constructs table in the format:\n#\n# Driver  | Property  | binary1  | binary1  | ...\n#         |           | machine1 | machine2 | ...\n# ------------------------------------------------------ ...",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "fill_prop_table",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def fill_prop_table(configs: List[Configuration],\n                    is_raw: bool) -> pd.DataFrame:\n    req_props = list(get_affected_props(configs))\n    if not req_props:\n        print('No drivers to compare. Check machine names')\n        exit(0)\n    driver_col, prop_col = tuple(zip(*req_props))\n    table = [pd.DataFrame({'Driver': driver_col}),\n             pd.DataFrame({'Property': prop_col})]\n    table.extend([config.get_table(req_props) for config in configs])",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "print_table",
        "kind": 2,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "def print_table(table: pd.DataFrame, table_format: str) -> None:\n    if table_format == 'json':\n        print(comp_table.to_json())\n    elif table_format == 'csv':\n        print(comp_table.to_csv())\n    else:\n        print(comp_table.to_markdown(index=False, stralign='center',\n                                     colalign=('center',), headers='keys',\n                                     tablefmt='fancy_grid',\n                                     disable_numparse=True))",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "default_qemu_args",
        "kind": 5,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "default_qemu_args = '-enable-kvm -machine none'\ndefault_qemu_binary = 'build/qemu-system-x86_64'\n# Methods for gettig the right values of drivers properties\n#\n# Use these methods as a 'whitelist' and add entries only if necessary. It's\n# important to be stable and predictable in analysis and tests.\n# Be careful:\n# * Class must be inherited from 'QEMUObject' and used in new_driver()\n# * Class has to implement get_prop method in order to get values\n# * Specialization always wins (with the given classes for 'device' and",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "default_qemu_binary",
        "kind": 5,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "default_qemu_binary = 'build/qemu-system-x86_64'\n# Methods for gettig the right values of drivers properties\n#\n# Use these methods as a 'whitelist' and add entries only if necessary. It's\n# important to be stable and predictable in analysis and tests.\n# Be careful:\n# * Class must be inherited from 'QEMUObject' and used in new_driver()\n# * Class has to implement get_prop method in order to get values\n# * Specialization always wins (with the given classes for 'device' and\n#   'x86_64-cpu', method of 'x86_64-cpu' will be used for '486-x86_64-cpu')",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "script_desc",
        "kind": 5,
        "importPath": "qemu.build.scripts.compare-machine-types",
        "description": "qemu.build.scripts.compare-machine-types",
        "peekOfCode": "script_desc = \"\"\"Script to compare machine types (their compat_props).\nExamples:\n* save info about all machines:  ./scripts/compare-machine-types.py --all \\\n--format csv --raw > table.csv\n* compare machines: ./scripts/compare-machine-types.py --mt pc-q35-2.12 \\\npc-q35-3.0\n* compare binaries and machines: ./scripts/compare-machine-types.py \\\n--mt pc-q35-6.2 pc-q35-7.0 --qemu-binary build/qemu-system-x86_64 \\\nbuild/qemu-exp\n  \\",
        "detail": "qemu.build.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "print_uarch_abi_csv",
        "kind": 2,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "def print_uarch_abi_csv():\n    print(\"Model,baseline,v2,v3,v4\")\n    for name in models.keys():\n        print(name, end=\"\")\n        for level in range(len(levels)):\n            if models[name][\"levels\"][level]:\n                print(\",\", end=\"\")\n            else:\n                print(\",\", end=\"\")\n        print()",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "levels",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "levels = [\n    [ # x86-64 baseline\n        \"cmov\",\n        \"cx8\",\n        \"fpu\",\n        \"fxsr\",\n        \"mmx\",\n        \"syscall\",\n        \"sse\",\n        \"sse2\",",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "sock = sys.argv[1]\nshell = QEMUMonitorProtocol(sock)\nshell.connect()\nmodels = shell.cmd(\"query-cpu-definitions\")\n# These QMP props don't correspond to CPUID fatures\n# so ignore them\nskip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "shell",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "shell = QEMUMonitorProtocol(sock)\nshell.connect()\nmodels = shell.cmd(\"query-cpu-definitions\")\n# These QMP props don't correspond to CPUID fatures\n# so ignore them\nskip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",\n    \"vendor\",",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "models = shell.cmd(\"query-cpu-definitions\")\n# These QMP props don't correspond to CPUID fatures\n# so ignore them\nskip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",\n    \"vendor\",\n    \"model\",\n    \"model-id\",",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "skip",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "skip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",\n    \"vendor\",\n    \"model\",\n    \"model-id\",\n    \"stepping\",\n]\nnames = []",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "names = []\nfor model in models:\n    if \"alias-of\" in model:\n        continue\n    names.append(model[\"name\"])\nmodels = {}\nfor name in sorted(names):\n    cpu = shell.cmd(\"query-cpu-model-expansion\",\n                    type=\"static\",\n                    model={ \"name\": name })",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "models = {}\nfor name in sorted(names):\n    cpu = shell.cmd(\"query-cpu-model-expansion\",\n                    type=\"static\",\n                    model={ \"name\": name })\n    got = {}\n    for (feature, present) in cpu[\"model\"][\"props\"].items():\n        if present and feature not in skip:\n            got[feature] = True\n    if name in [\"host\", \"max\", \"base\"]:",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "abi_models",
        "kind": 5,
        "importPath": "qemu.build.scripts.cpu-x86-uarch-abi",
        "description": "qemu.build.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "abi_models = [\n    [],\n    [],\n    [],\n    [],\n]\nfor name in models.keys():\n    for level in range(len(levels)):\n        if models[name][\"levels\"][level]:\n            abi_models[level].append(name)",
        "detail": "qemu.build.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "CycleError",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class CycleError(ValueError):\n    \"\"\"Subclass of ValueError raised if cycles exist in the graph\"\"\"\n    pass\nclass TopologicalSorter:\n    \"\"\"Topologically sort a graph\"\"\"\n    def __init__(self, graph=None):\n        self.graph = graph\n    def static_order(self):\n        # We do the sort right here, unlike the stdlib version\n        from functools import reduce",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "TopologicalSorter",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class TopologicalSorter:\n    \"\"\"Topologically sort a graph\"\"\"\n    def __init__(self, graph=None):\n        self.graph = graph\n    def static_order(self):\n        # We do the sort right here, unlike the stdlib version\n        from functools import reduce\n        data = {}\n        r = []\n        if not self.graph:",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Field",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class Field:\n    \"\"\"Class representing a simple instruction field\"\"\"\n    def __init__(self, sign, pos, len):\n        self.sign = sign\n        self.pos = pos\n        self.len = len\n        self.mask = ((1 << len) - 1) << pos\n    def __str__(self):\n        if self.sign:\n            s = 's'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "MultiField",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class MultiField:\n    \"\"\"Class representing a compound instruction field\"\"\"\n    def __init__(self, subs, mask):\n        self.subs = subs\n        self.sign = subs[0].sign\n        self.mask = mask\n    def __str__(self):\n        return str(self.subs)\n    def str_extract(self, lvalue_formatter):\n        global bitop_width",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ConstField",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class ConstField:\n    \"\"\"Class representing an argument field with constant value\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.mask = 0\n        self.sign = value < 0\n    def __str__(self):\n        return str(self.value)\n    def str_extract(self, lvalue_formatter):\n        return str(self.value)",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "FunctionField",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class FunctionField:\n    \"\"\"Class representing a field passed through a function\"\"\"\n    def __init__(self, func, base):\n        self.mask = base.mask\n        self.sign = base.sign\n        self.base = base\n        self.func = func\n    def __str__(self):\n        return self.func + '(' + str(self.base) + ')'\n    def str_extract(self, lvalue_formatter):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ParameterField",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class ParameterField:\n    \"\"\"Class representing a pseudo-field read from a function\"\"\"\n    def __init__(self, func):\n        self.mask = 0\n        self.sign = 0\n        self.func = func\n    def __str__(self):\n        return self.func\n    def str_extract(self, lvalue_formatter):\n        return self.func + '(ctx)'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "NamedField",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class NamedField:\n    \"\"\"Class representing a field already named in the pattern\"\"\"\n    def __init__(self, name, sign, len):\n        self.mask = 0\n        self.sign = sign\n        self.len = len\n        self.name = name\n    def __str__(self):\n        return self.name\n    def str_extract(self, lvalue_formatter):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Arguments",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class Arguments:\n    \"\"\"Class representing the extracted fields of a format\"\"\"\n    def __init__(self, nm, flds, types, extern):\n        self.name = nm\n        self.extern = extern\n        self.fields = flds\n        self.types = types\n    def __str__(self):\n        return self.name + ' ' + str(self.fields)\n    def struct_name(self):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "General",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class General:\n    \"\"\"Common code between instruction formats and instruction patterns\"\"\"\n    def __init__(self, name, lineno, base, fixb, fixm, udfm, fldm, flds, w):\n        self.name = name\n        self.file = input_file\n        self.lineno = lineno\n        self.base = base\n        self.fixedbits = fixb\n        self.fixedmask = fixm\n        self.undefmask = udfm",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Format",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class Format(General):\n    \"\"\"Class representing an instruction format\"\"\"\n    def extract_name(self):\n        global decode_function\n        return decode_function + '_extract_' + self.name\n    def output_extract(self):\n        output('static void ', self.extract_name(), '(DisasContext *ctx, ',\n               self.base.struct_name(), ' *a, ', insntype, ' insn)\\n{\\n')\n        self.output_fields(str_indent(4), lambda n: 'a->' + n)\n        output('}\\n\\n')",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class Pattern(General):\n    \"\"\"Class representing an instruction pattern\"\"\"\n    def output_decl(self):\n        global translate_scope\n        global translate_prefix\n        output('typedef ', self.base.base.struct_name(),\n               ' arg_', self.name, ';\\n')\n        output(translate_scope, 'bool ', translate_prefix, '_', self.name,\n               '(DisasContext *ctx, arg_', self.name, ' *a);\\n')\n    def output_code(self, i, extracted, outerbits, outermask):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "MultiPattern",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class MultiPattern(General):\n    \"\"\"Class representing a set of instruction patterns\"\"\"\n    def __init__(self, lineno):\n        self.file = input_file\n        self.lineno = lineno\n        self.pats = []\n        self.base = None\n        self.fixedbits = 0\n        self.fixedmask = 0\n        self.undefmask = 0",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "IncMultiPattern",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class IncMultiPattern(MultiPattern):\n    \"\"\"Class representing an overlapping set of instruction patterns\"\"\"\n    def output_code(self, i, extracted, outerbits, outermask):\n        global translate_prefix\n        ind = str_indent(i)\n        for p in self.pats:\n            if outermask != p.fixedmask:\n                innermask = p.fixedmask & ~outermask\n                innerbits = p.fixedbits & ~outermask\n                output(ind, f'if ((insn & {whexC(innermask)}) == {whexC(innerbits)}) {{\\n')",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class Tree:\n    \"\"\"Class representing a node in a decode tree\"\"\"\n    def __init__(self, fm, tm):\n        self.fixedmask = fm\n        self.thismask = tm\n        self.subs = []\n        self.base = None\n    def str1(self, i):\n        ind = str_indent(i)\n        r = ind + whex(self.fixedmask)",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ExcMultiPattern",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class ExcMultiPattern(MultiPattern):\n    \"\"\"Class representing a non-overlapping set of instruction patterns\"\"\"\n    def output_code(self, i, extracted, outerbits, outermask):\n        # Defer everything to our decomposed Tree node\n        self.tree.output_code(i, extracted, outerbits, outermask)\n    @staticmethod\n    def __build_tree(pats, outerbits, outermask):\n        # Find the intersection of all remaining fixedmask.\n        innermask = ~outermask & insnmask\n        for i in pats:",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "SizeTree",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class SizeTree:\n    \"\"\"Class representing a node in a size decode tree\"\"\"\n    def __init__(self, m, w):\n        self.mask = m\n        self.subs = []\n        self.base = None\n        self.width = w\n    def str1(self, i):\n        ind = str_indent(i)\n        r = ind + whex(self.mask) + ' [\\n'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "SizeLeaf",
        "kind": 6,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "class SizeLeaf:\n    \"\"\"Class representing a leaf node in a size decode tree\"\"\"\n    def __init__(self, m, w):\n        self.mask = m\n        self.width = w\n    def str1(self, i):\n        return str_indent(i) + whex(self.mask)\n    def __str__(self):\n        return self.str1(0)\n    def output_code(self, i, extracted, outerbits, outermask):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "error_with_file",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def error_with_file(file, lineno, *args):\n    \"\"\"Print an error message from file:line and args and exit.\"\"\"\n    global output_file\n    global output_fd\n    # For the test suite expected-errors case, don't print the\n    # string \"error: \", so they don't turn up as false positives\n    # if you grep the meson logs for strings like that.\n    end = 'error: ' if not testforerror else 'detected: '\n    prefix = ''\n    if file:",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def error(lineno, *args):\n    error_with_file(input_file, lineno, *args)\n# end error\ndef output(*args):\n    global output_fd\n    for a in args:\n        output_fd.write(a)\ndef output_autogen():\n    output('/* This file is autogenerated by scripts/decodetree.py.  */\\n\\n')\ndef str_indent(c):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def output(*args):\n    global output_fd\n    for a in args:\n        output_fd.write(a)\ndef output_autogen():\n    output('/* This file is autogenerated by scripts/decodetree.py.  */\\n\\n')\ndef str_indent(c):\n    \"\"\"Return a string with C spaces\"\"\"\n    return ' ' * c\ndef str_fields(fields):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_autogen",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def output_autogen():\n    output('/* This file is autogenerated by scripts/decodetree.py.  */\\n\\n')\ndef str_indent(c):\n    \"\"\"Return a string with C spaces\"\"\"\n    return ' ' * c\ndef str_fields(fields):\n    \"\"\"Return a string uniquely identifying FIELDS\"\"\"\n    r = ''\n    for n in sorted(fields.keys()):\n        r += '_' + n",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "str_indent",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def str_indent(c):\n    \"\"\"Return a string with C spaces\"\"\"\n    return ' ' * c\ndef str_fields(fields):\n    \"\"\"Return a string uniquely identifying FIELDS\"\"\"\n    r = ''\n    for n in sorted(fields.keys()):\n        r += '_' + n\n    return r[1:]\ndef whex(val):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "str_fields",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def str_fields(fields):\n    \"\"\"Return a string uniquely identifying FIELDS\"\"\"\n    r = ''\n    for n in sorted(fields.keys()):\n        r += '_' + n\n    return r[1:]\ndef whex(val):\n    \"\"\"Return a hex string for val padded for insnwidth\"\"\"\n    global insnwidth\n    return f'0x{val:0{insnwidth // 4}x}'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "whex",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def whex(val):\n    \"\"\"Return a hex string for val padded for insnwidth\"\"\"\n    global insnwidth\n    return f'0x{val:0{insnwidth // 4}x}'\ndef whexC(val):\n    \"\"\"Return a hex string for val padded for insnwidth,\n       and with the proper suffix for a C constant.\"\"\"\n    suffix = ''\n    if val >= 0x100000000:\n        suffix = 'ull'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "whexC",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def whexC(val):\n    \"\"\"Return a hex string for val padded for insnwidth,\n       and with the proper suffix for a C constant.\"\"\"\n    suffix = ''\n    if val >= 0x100000000:\n        suffix = 'ull'\n    elif val >= 0x80000000:\n        suffix = 'u'\n    return whex(val) + suffix\ndef str_match_bits(bits, mask):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "str_match_bits",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def str_match_bits(bits, mask):\n    \"\"\"Return a string pretty-printing BITS/MASK\"\"\"\n    global insnwidth\n    i = 1 << (insnwidth - 1)\n    space = 0x01010100\n    r = ''\n    while i != 0:\n        if i & mask:\n            if i & bits:\n                r += '1'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "is_pow2",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def is_pow2(x):\n    \"\"\"Return true iff X is equal to a power of 2.\"\"\"\n    return (x & (x - 1)) == 0\ndef ctz(x):\n    \"\"\"Return the number of times 2 factors into X.\"\"\"\n    assert x != 0\n    r = 0\n    while ((x >> r) & 1) == 0:\n        r += 1\n    return r",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ctz",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def ctz(x):\n    \"\"\"Return the number of times 2 factors into X.\"\"\"\n    assert x != 0\n    r = 0\n    while ((x >> r) & 1) == 0:\n        r += 1\n    return r\ndef is_contiguous(bits):\n    if bits == 0:\n        return -1",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "is_contiguous",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def is_contiguous(bits):\n    if bits == 0:\n        return -1\n    shift = ctz(bits)\n    if is_pow2((bits >> shift) + 1):\n        return shift\n    else:\n        return -1\ndef eq_fields_for_args(flds_a, arg):\n    if len(flds_a) != len(arg.fields):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "eq_fields_for_args",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def eq_fields_for_args(flds_a, arg):\n    if len(flds_a) != len(arg.fields):\n        return False\n    # Only allow inference on default types\n    for t in arg.types:\n        if t != 'int':\n            return False\n    for k, a in flds_a.items():\n        if k not in arg.fields:\n            return False",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "eq_fields_for_fmts",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def eq_fields_for_fmts(flds_a, flds_b):\n    if len(flds_a) != len(flds_b):\n        return False\n    for k, a in flds_a.items():\n        if k not in flds_b:\n            return False\n        b = flds_b[k]\n        if a.__class__ != b.__class__ or a != b:\n            return False\n    return True",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_field",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def parse_field(lineno, name, toks):\n    \"\"\"Parse one instruction field from TOKS at LINENO\"\"\"\n    global fields\n    global insnwidth\n    global re_C_ident\n    # A \"simple\" field will have only one entry;\n    # a \"multifield\" will have several.\n    subs = []\n    width = 0\n    func = None",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def parse_arguments(lineno, name, toks):\n    \"\"\"Parse one argument set from TOKS at LINENO\"\"\"\n    global arguments\n    global re_C_ident\n    global anyextern\n    flds = []\n    types = []\n    extern = False\n    for n in toks:\n        if re.fullmatch('!extern', n):",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "lookup_field",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def lookup_field(lineno, name):\n    global fields\n    if name in fields:\n        return fields[name]\n    error(lineno, 'undefined field', name)\ndef add_field(lineno, flds, new_name, f):\n    if new_name in flds:\n        error(lineno, 'duplicate field', new_name)\n    flds[new_name] = f\n    return flds",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "add_field",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def add_field(lineno, flds, new_name, f):\n    if new_name in flds:\n        error(lineno, 'duplicate field', new_name)\n    flds[new_name] = f\n    return flds\ndef add_field_byname(lineno, flds, new_name, old_name):\n    return add_field(lineno, flds, new_name, lookup_field(lineno, old_name))\ndef infer_argument_set(flds):\n    global arguments\n    global decode_function",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "add_field_byname",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def add_field_byname(lineno, flds, new_name, old_name):\n    return add_field(lineno, flds, new_name, lookup_field(lineno, old_name))\ndef infer_argument_set(flds):\n    global arguments\n    global decode_function\n    for arg in arguments.values():\n        if eq_fields_for_args(flds, arg):\n            return arg\n    name = decode_function + str(len(arguments))\n    arg = Arguments(name, flds.keys(), ['int'] * len(flds), False)",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "infer_argument_set",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def infer_argument_set(flds):\n    global arguments\n    global decode_function\n    for arg in arguments.values():\n        if eq_fields_for_args(flds, arg):\n            return arg\n    name = decode_function + str(len(arguments))\n    arg = Arguments(name, flds.keys(), ['int'] * len(flds), False)\n    arguments[name] = arg\n    return arg",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "infer_format",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def infer_format(arg, fieldmask, flds, width):\n    global arguments\n    global formats\n    global decode_function\n    const_flds = {}\n    var_flds = {}\n    for n, c in flds.items():\n        if c is ConstField:\n            const_flds[n] = c\n        else:",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_generic",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def parse_generic(lineno, parent_pat, name, toks):\n    \"\"\"Parse one instruction format from TOKS at LINENO\"\"\"\n    global fields\n    global arguments\n    global formats\n    global allpatterns\n    global re_arg_ident\n    global re_fld_ident\n    global re_fmt_ident\n    global re_C_ident",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_file",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def parse_file(f, parent_pat):\n    \"\"\"Parse all of the patterns within a file\"\"\"\n    global re_arg_ident\n    global re_fld_ident\n    global re_fmt_ident\n    global re_pat_ident\n    # Read all of the lines of the file.  Concatenate lines\n    # ending in backslash; discard empty lines and comments.\n    toks = []\n    lineno = 0",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "build_size_tree",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def build_size_tree(pats, width, outerbits, outermask):\n    global insnwidth\n    # Collect the mask of bits that are fixed in this width\n    innermask = 0xff << (insnwidth - width)\n    innermask &= ~outermask\n    minwidth = None\n    onewidth = True\n    for i in pats:\n        innermask &= i.fixedmask\n        if minwidth is None:",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "prop_size",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def prop_size(tree):\n    \"\"\"Propagate minimum widths up the decode size tree\"\"\"\n    if isinstance(tree, SizeTree):\n        min = None\n        for (b, s) in tree.subs:\n            width = prop_size(s)\n            if min is None or min > width:\n                min = width\n        assert min >= tree.width\n        tree.width = min",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "def main():\n    global arguments\n    global formats\n    global allpatterns\n    global translate_scope\n    global translate_prefix\n    global output_fd\n    global output_file\n    global output_null\n    global input_file",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "insnwidth",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "insnwidth = 32\nbitop_width = 32\ninsnmask = 0xffffffff\nvariablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "bitop_width",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "bitop_width = 32\ninsnmask = 0xffffffff\nvariablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "insnmask",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "insnmask = 0xffffffff\nvariablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "variablewidth",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "variablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "fields",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "fields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "arguments",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "arguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "formats",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "formats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "allpatterns",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "allpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "anyextern",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "anyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "testforerror",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "testforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "translate_prefix",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "translate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "translate_scope",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "translate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "input_file",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "input_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "output_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_fd",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "output_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_null",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "output_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "insntype",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "insntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "decode_function",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "decode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_C_ident",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "re_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_arg_ident",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "re_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_fld_ident",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "re_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#\n# https://docs.python.org/3.9/library/graphlib.html#graphlib.TopologicalSorter",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_fmt_ident",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "re_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#\n# https://docs.python.org/3.9/library/graphlib.html#graphlib.TopologicalSorter\n#",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_pat_ident",
        "kind": 5,
        "importPath": "qemu.build.scripts.decodetree",
        "description": "qemu.build.scripts.decodetree",
        "peekOfCode": "re_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#\n# https://docs.python.org/3.9/library/graphlib.html#graphlib.TopologicalSorter\n#\n# We only implement the parts of TopologicalSorter we care about:",
        "detail": "qemu.build.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ELF",
        "kind": 6,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "class ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None\n        self.notes = []\n        self.segments = []\n        self.notes_size = 0\n        self.endianness = None\n        self.elfclass = ELFCLASS64\n        if arch == 'aarch64-le':",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "Ident",
        "kind": 6,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "class Ident(ctypes.Structure):\n    \"\"\"Represents the ELF ident array in the ehdr structure.\"\"\"\n    _fields_ = [('ei_mag0', ctypes.c_ubyte),\n                ('ei_mag1', ctypes.c_ubyte),\n                ('ei_mag2', ctypes.c_ubyte),\n                ('ei_mag3', ctypes.c_ubyte),\n                ('ei_class', ctypes.c_ubyte),\n                ('ei_data', ctypes.c_ubyte),\n                ('ei_version', ctypes.c_ubyte),\n                ('ei_osabi', ctypes.c_ubyte),",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "DumpGuestMemory",
        "kind": 6,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "class DumpGuestMemory(gdb.Command):\n    \"\"\"Extract guest vmcore from qemu process coredump.\nThe two required arguments are FILE and ARCH:\nFILE identifies the target file to write the guest vmcore to.\nARCH specifies the architecture for which the core will be generated.\nThis GDB command reimplements the dump-guest-memory QMP command in\npython, using the representation of guest memory as captured in the qemu\ncoredump. The qemu process that has been dumped must have had the\ncommand line option \"-machine dump-guest-core=on\" which is the default.\nFor simplicity, the \"paging\", \"begin\" and \"end\" parameters of the QMP",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "le16_to_cpu",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "le32_to_cpu",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None\n        self.notes = []\n        self.segments = []",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "le64_to_cpu",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None\n        self.notes = []\n        self.segments = []\n        self.notes_size = 0\n        self.endianness = None",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_arch_note",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def get_arch_note(endianness, len_name, len_desc):\n    \"\"\"Returns a Note class with the specified endianness.\"\"\"\n    if endianness == ELFDATA2LSB:\n        superclass = ctypes.LittleEndianStructure\n    else:\n        superclass = ctypes.BigEndianStructure\n    len_name = len_name + 1\n    class Note(superclass):\n        \"\"\"Represents an ELF note, includes the content.\"\"\"\n        _fields_ = [(\"n_namesz\", ctypes.c_uint32),",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_arch_ehdr",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def get_arch_ehdr(endianness, elfclass):\n    \"\"\"Returns a EHDR64 class with the specified endianness.\"\"\"\n    if endianness == ELFDATA2LSB:\n        superclass = ctypes.LittleEndianStructure\n    else:\n        superclass = ctypes.BigEndianStructure\n    class EHDR64(superclass):\n        \"\"\"Represents the 64 bit ELF header struct.\"\"\"\n        _fields_ = [('e_ident', Ident),\n                    ('e_type', ctypes.c_uint16),",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_arch_phdr",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def get_arch_phdr(endianness, elfclass):\n    \"\"\"Returns a 32 or 64 bit PHDR class with the specified endianness.\"\"\"\n    if endianness == ELFDATA2LSB:\n        superclass = ctypes.LittleEndianStructure\n    else:\n        superclass = ctypes.BigEndianStructure\n    class PHDR64(superclass):\n        \"\"\"Represents the 64 bit ELF program header struct.\"\"\"\n        _fields_ = [('p_type', ctypes.c_uint32),\n                    ('p_flags', ctypes.c_uint32),",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "int128_get64",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def int128_get64(val):\n    \"\"\"Returns low 64bit part of Int128 struct.\"\"\"\n    try:\n        assert val[\"hi\"] == 0\n        return val[\"lo\"]\n    except gdb.error:\n        u64t = gdb.lookup_type('uint64_t').array(2)\n        u64 = val.cast(u64t)\n        if sys.byteorder == 'little':\n            assert u64[1] == 0",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "qlist_foreach",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def qlist_foreach(head, field_str):\n    \"\"\"Generator for qlists.\"\"\"\n    var_p = head[\"lh_first\"]\n    while var_p != 0:\n        var = var_p.dereference()\n        var_p = var[field_str][\"le_next\"]\n        yield var\ndef qemu_map_ram_ptr(block, offset):\n    \"\"\"Returns qemu vaddr for given guest physical address.\"\"\"\n    return block[\"host\"] + offset",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "qemu_map_ram_ptr",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def qemu_map_ram_ptr(block, offset):\n    \"\"\"Returns qemu vaddr for given guest physical address.\"\"\"\n    return block[\"host\"] + offset\ndef memory_region_get_ram_ptr(memory_region):\n    if memory_region[\"alias\"] != 0:\n        return (memory_region_get_ram_ptr(memory_region[\"alias\"].dereference())\n                + memory_region[\"alias_offset\"])\n    return qemu_map_ram_ptr(memory_region[\"ram_block\"], 0)\ndef get_guest_phys_blocks():\n    \"\"\"Returns a list of ram blocks.",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "memory_region_get_ram_ptr",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def memory_region_get_ram_ptr(memory_region):\n    if memory_region[\"alias\"] != 0:\n        return (memory_region_get_ram_ptr(memory_region[\"alias\"].dereference())\n                + memory_region[\"alias_offset\"])\n    return qemu_map_ram_ptr(memory_region[\"ram_block\"], 0)\ndef get_guest_phys_blocks():\n    \"\"\"Returns a list of ram blocks.\n    Each block entry contains:\n    'target_start': guest block phys start address\n    'target_end':   guest block phys end address",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_guest_phys_blocks",
        "kind": 2,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "def get_guest_phys_blocks():\n    \"\"\"Returns a list of ram blocks.\n    Each block entry contains:\n    'target_start': guest block phys start address\n    'target_end':   guest block phys end address\n    'host_addr':    qemu vaddr of the block's start\n    \"\"\"\n    guest_phys_blocks = []\n    print(\"guest RAM blocks:\")\n    print(\"target_start     target_end       host_addr        message \"",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "TARGET_PAGE_SIZE",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "TARGET_PAGE_SIZE = 0x1000\nTARGET_PAGE_MASK = 0xFFFFFFFFFFFFF000\n# Special value for e_phnum. This indicates that the real number of\n# program headers is too large to fit into e_phnum. Instead the real\n# value is in the field sh_info of section 0.\nPN_XNUM = 0xFFFF\nEV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "TARGET_PAGE_MASK",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "TARGET_PAGE_MASK = 0xFFFFFFFFFFFFF000\n# Special value for e_phnum. This indicates that the real number of\n# program headers is too large to fit into e_phnum. Instead the real\n# value is in the field sh_info of section 0.\nPN_XNUM = 0xFFFF\nEV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "PN_XNUM",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "PN_XNUM = 0xFFFF\nEV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EV_CURRENT",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "EV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFCLASS32",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "ELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFCLASS64",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "ELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFDATA2LSB",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "ELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFDATA2MSB",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "ELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ET_CORE",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "ET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "PT_LOAD",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "PT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "PT_NOTE",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "PT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_386",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "EM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_PPC",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "EM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_PPC64",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "EM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_S390",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "EM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_AARCH",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "EM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_X86_64",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "EM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "VMCOREINFO_FORMAT_ELF",
        "kind": 5,
        "importPath": "qemu.build.scripts.dump-guest-memory",
        "description": "qemu.build.scripts.dump-guest-memory",
        "peekOfCode": "VMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):",
        "detail": "qemu.build.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "writeliteral",
        "kind": 2,
        "importPath": "qemu.build.scripts.feature_to_c",
        "description": "qemu.build.scripts.feature_to_c",
        "peekOfCode": "def writeliteral(indent, bytes):\n    sys.stdout.write(' ' * indent)\n    sys.stdout.write('\"')\n    quoted = True\n    for c in bytes:\n        if not quoted:\n            sys.stdout.write('\\n')\n            sys.stdout.write(' ' * indent)\n            sys.stdout.write('\"')\n            quoted = True",
        "detail": "qemu.build.scripts.feature_to_c",
        "documentation": {}
    },
    {
        "label": "get_help",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def get_help(opt):\n    if opt[\"name\"] == \"libdir\":\n        return 'system default'\n    value = opt[\"value\"]\n    if isinstance(value, list):\n        return \",\".join(value)\n    if isinstance(value, bool):\n        return \"enabled\" if value else \"disabled\"\n    return str(value)\ndef wrap(left, text, indent):",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "wrap",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def wrap(left, text, indent):\n    spaces = \" \" * indent\n    if len(left) >= indent:\n        yield left\n        left = spaces\n    else:\n        left = (left + spaces)[0:indent]\n    yield from textwrap.wrap(\n        text, width=LINE_WIDTH, initial_indent=left, subsequent_indent=spaces\n    )",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "sh_print",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def sh_print(line=\"\"):\n    print('  printf \"%s\\\\n\"', shlex.quote(line))\ndef help_line(left, opt, indent, long):\n    right = f'{opt[\"description\"]}'\n    if long:\n        value = get_help(opt)\n        if value != \"auto\" and value != \"\":\n            right += f\" [{value}]\"\n    if \"choices\" in opt and long:\n        choices = \"/\".join(sorted(opt[\"choices\"]))",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "help_line",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def help_line(left, opt, indent, long):\n    right = f'{opt[\"description\"]}'\n    if long:\n        value = get_help(opt)\n        if value != \"auto\" and value != \"\":\n            right += f\" [{value}]\"\n    if \"choices\" in opt and long:\n        choices = \"/\".join(sorted(opt[\"choices\"]))\n        right += f\" (choices: {choices})\"\n    for x in wrap(\"  \" + left, right, indent):",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "allow_arg",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def allow_arg(opt):\n    if opt[\"type\"] == \"boolean\":\n        return False\n    if opt[\"type\"] != \"combo\":\n        return True\n    return not (set(opt[\"choices\"]) <= {\"auto\", \"disabled\", \"enabled\"})\n# Return whether the option (a dictionary) can be used without\n# arguments.  Booleans can only be used without arguments;\n# combos require an argument if they accept neither \"enabled\"\n# nor \"disabled\"",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "require_arg",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def require_arg(opt):\n    if opt[\"type\"] == \"boolean\":\n        return False\n    if opt[\"type\"] != \"combo\":\n        return True\n    return not ({\"enabled\", \"disabled\"}.intersection(opt[\"choices\"]))\ndef filter_options(json):\n    if \":\" in json[\"name\"]:\n        return False\n    if json[\"section\"] == \"user\":",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "filter_options",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def filter_options(json):\n    if \":\" in json[\"name\"]:\n        return False\n    if json[\"section\"] == \"user\":\n        return json[\"name\"] not in SKIP_OPTIONS\n    else:\n        return json[\"name\"] in BUILTIN_OPTIONS\ndef load_options(json):\n    json = [x for x in json if filter_options(x)]\n    return sorted(json, key=lambda x: x[\"name\"])",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "load_options",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def load_options(json):\n    json = [x for x in json if filter_options(x)]\n    return sorted(json, key=lambda x: x[\"name\"])\ndef cli_option(opt):\n    name = opt[\"name\"]\n    if name in OPTION_NAMES:\n        return OPTION_NAMES[name]\n    return name.replace(\"_\", \"-\")\ndef cli_help_key(opt):\n    key = cli_option(opt)",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "cli_option",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def cli_option(opt):\n    name = opt[\"name\"]\n    if name in OPTION_NAMES:\n        return OPTION_NAMES[name]\n    return name.replace(\"_\", \"-\")\ndef cli_help_key(opt):\n    key = cli_option(opt)\n    if require_arg(opt):\n        return key\n    if opt[\"type\"] == \"boolean\" and opt[\"value\"]:",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "cli_help_key",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def cli_help_key(opt):\n    key = cli_option(opt)\n    if require_arg(opt):\n        return key\n    if opt[\"type\"] == \"boolean\" and opt[\"value\"]:\n        return f\"disable-{key}\"\n    return f\"enable-{key}\"\ndef cli_metavar(opt):\n    if opt[\"type\"] == \"string\":\n        return \"VALUE\"",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "cli_metavar",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def cli_metavar(opt):\n    if opt[\"type\"] == \"string\":\n        return \"VALUE\"\n    if opt[\"type\"] == \"array\":\n        return \"CHOICES\" if \"choices\" in opt else \"VALUES\"\n    return \"CHOICE\"\ndef print_help(options):\n    print(\"meson_options_help() {\")\n    feature_opts = []\n    for opt in sorted(options, key=cli_help_key):",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "print_help",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def print_help(options):\n    print(\"meson_options_help() {\")\n    feature_opts = []\n    for opt in sorted(options, key=cli_help_key):\n        key = cli_help_key(opt)\n        # The first section includes options that have an arguments,\n        # and booleans (i.e., only one of enable/disable makes sense)\n        if require_arg(opt):\n            metavar = cli_metavar(opt)\n            left = f\"--{key}={metavar}\"",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "print_parse",
        "kind": 2,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "def print_parse(options):\n    print(\"_meson_option_parse() {\")\n    print(\"  case $1 in\")\n    for opt in options:\n        key = cli_option(opt)\n        name = opt[\"name\"]\n        if require_arg(opt):\n            if opt[\"type\"] == \"array\" and not \"choices\" in opt:\n                print(f'    --{key}=*) quote_sh \"-D{name}=$(meson_option_build_array $2)\" ;;')\n            else:",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "SKIP_OPTIONS",
        "kind": 5,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "SKIP_OPTIONS = {\n    \"default_devices\",\n    \"fuzzing_engine\",\n}\n# Options whose name doesn't match the option for backwards compatibility\n# reasons, because Meson gives them a funny name, or both\nOPTION_NAMES = {\n    \"b_coverage\": \"gcov\",\n    \"b_lto\": \"lto\",\n    \"coroutine_backend\": \"with-coroutine\",",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "OPTION_NAMES",
        "kind": 5,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "OPTION_NAMES = {\n    \"b_coverage\": \"gcov\",\n    \"b_lto\": \"lto\",\n    \"coroutine_backend\": \"with-coroutine\",\n    \"debug\": \"debug-info\",\n    \"malloc\": \"enable-malloc\",\n    \"pkgversion\": \"with-pkgversion\",\n    \"qemu_firmwarepath\": \"firmwarepath\",\n    \"qemu_suffix\": \"with-suffix\",\n    \"trace_backends\": \"enable-trace-backends\",",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "AUTO_OPTIONS",
        "kind": 5,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "AUTO_OPTIONS = {\n    \"plugins\",\n    \"werror\",\n}\n# Builtin options that should be definable via configure.  Some of the others\n# we really do not want (e.g. c_args is defined via the native file, not\n# via -D, because it's a mix of CFLAGS and --extra-cflags); for specific\n# cases \"../configure -D\" can be used as an escape hatch.\nBUILTIN_OPTIONS = {\n    \"b_coverage\",",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "BUILTIN_OPTIONS",
        "kind": 5,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "BUILTIN_OPTIONS = {\n    \"b_coverage\",\n    \"b_lto\",\n    \"bindir\",\n    \"datadir\",\n    \"debug\",\n    \"includedir\",\n    \"libdir\",\n    \"libexecdir\",\n    \"localedir\",",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "LINE_WIDTH",
        "kind": 5,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "LINE_WIDTH = 76\n# Convert the default value of an option to the string used in\n# the help message\ndef get_help(opt):\n    if opt[\"name\"] == \"libdir\":\n        return 'system default'\n    value = opt[\"value\"]\n    if isinstance(value, list):\n        return \",\".join(value)\n    if isinstance(value, bool):",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "json_data",
        "kind": 5,
        "importPath": "qemu.build.scripts.meson-buildoptions",
        "description": "qemu.build.scripts.meson-buildoptions",
        "peekOfCode": "json_data = sys.stdin.read()\ntry:\n    options = load_options(json.loads(json_data))\nexcept:\n    print(\"Failure in scripts/meson-buildoptions.py parsing stdin as json\",\n          file=sys.stderr)\n    print(json_data, file=sys.stderr)\n    sys.exit(1)\nprint(\"# This file is generated by meson-buildoptions.py, do not edit!\")\nprint_help(options)",
        "detail": "qemu.build.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "KconfigDataError",
        "kind": 6,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "class KconfigDataError(Exception):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return self.msg\nallyesconfig = lambda x: True\nallnoconfig = lambda x: False\ndefconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "KconfigData",
        "kind": 6,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "class KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):\n            return KconfigData.NOT(self)\n        # Abstract methods\n        def add_edges_to(self, var):",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "KconfigParserError",
        "kind": 6,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "class KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)\n        self.msg = msg\n    def __str__(self):\n        return \"%s: %s\" % (self.loc, self.msg)",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "KconfigParser",
        "kind": 6,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "class KconfigParser:\n    @classmethod\n    def parse(self, fp, mode=None):\n        data = KconfigData(mode or KconfigParser.defconfig)\n        parser = KconfigParser(data)\n        parser.parse_file(fp)\n        return data\n    def __init__(self, data):\n        self.data = data\n    def parse_file(self, fp):",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "debug_print",
        "kind": 2,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "def debug_print(*args):\n    #print('# ' + (' '.join(str(x) for x in args)))\n    pass\n# -------------------------------------------\n# KconfigData implements the Kconfig semantics.  For now it can only\n# detect undefined symbols, i.e. symbols that were referenced in\n# assignments or dependencies but were not declared with \"config FOO\".\n#\n# Semantic actions are represented by methods called do_*.  The do_var\n# method return the semantic value of a variable (which right now is",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "__all__ = [ 'KconfigDataError', 'KconfigParserError',\n            'KconfigData', 'KconfigParser' ,\n            'defconfig', 'allyesconfig', 'allnoconfig', 'randconfig' ]\ndef debug_print(*args):\n    #print('# ' + (' '.join(str(x) for x in args)))\n    pass\n# -------------------------------------------\n# KconfigData implements the Kconfig semantics.  For now it can only\n# detect undefined symbols, i.e. symbols that were referenced in\n# assignments or dependencies but were not declared with \"config FOO\".",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "allyesconfig",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "allyesconfig = lambda x: True\nallnoconfig = lambda x: False\ndefconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "allnoconfig",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "allnoconfig = lambda x: False\ndefconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "defconfig",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "defconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):\n            return KconfigData.NOT(self)",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "randconfig",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "randconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):\n            return KconfigData.NOT(self)\n        # Abstract methods",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOKENS",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOKENS = {}\nTOK_NONE = -1\nTOK_LPAREN = 0;   TOKENS[TOK_LPAREN] = '\"(\"';\nTOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_NONE",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_NONE = -1\nTOK_LPAREN = 0;   TOKENS[TOK_LPAREN] = '\"(\"';\nTOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_LPAREN",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_LPAREN = 0;   TOKENS[TOK_LPAREN] = '\"(\"';\nTOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_RPAREN",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_EQUAL",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_AND",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_OR",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_NOT",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_DEPENDS",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_ON",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_SELECT",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_IMPLY",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_CONFIG",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_DEFAULT",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_Y",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_N",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_SOURCE",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_BOOL",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_IF",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_ID",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)\n        self.msg = msg",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_EOF",
        "kind": 5,
        "importPath": "qemu.build.scripts.minikconf",
        "description": "qemu.build.scripts.minikconf",
        "peekOfCode": "TOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)\n        self.msg = msg\n    def __str__(self):",
        "detail": "qemu.build.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "find_command",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-collect",
        "description": "qemu.build.scripts.modinfo-collect",
        "peekOfCode": "def find_command(src, target, compile_commands):\n    for command in compile_commands:\n        if command['file'] != src:\n            continue\n        if target != '' and command['command'].find(target) == -1:\n            continue\n        return command['command']\n    return 'false'\ndef process_command(src, command):\n    skip = False",
        "detail": "qemu.build.scripts.modinfo-collect",
        "documentation": {}
    },
    {
        "label": "process_command",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-collect",
        "description": "qemu.build.scripts.modinfo-collect",
        "peekOfCode": "def process_command(src, command):\n    skip = False\n    out = []\n    for item in shlex.split(command):\n        if skip:\n            skip = False\n            continue\n        if item == '-MF' or item == '-MQ' or item == '-o':\n            skip = True\n            continue",
        "detail": "qemu.build.scripts.modinfo-collect",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-collect",
        "description": "qemu.build.scripts.modinfo-collect",
        "peekOfCode": "def main(args):\n    target = ''\n    if args[0] == '--target':\n        args.pop(0)\n        target = args.pop(0)\n        print(\"MODINFO_DEBUG target %s\" % target)\n        arch = target[:-8] # cut '-softmmu'\n        print(\"MODINFO_START arch \\\"%s\\\" MODINFO_END\" % arch)\n    with open('compile_commands.json') as f:\n        compile_commands = json.load(f)",
        "detail": "qemu.build.scripts.modinfo-collect",
        "documentation": {}
    },
    {
        "label": "print_array",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-generate",
        "description": "qemu.build.scripts.modinfo-generate",
        "peekOfCode": "def print_array(name, values):\n    if len(values) == 0:\n        return\n    list = \", \".join(values)\n    print(\"    .%s = ((const char*[]){ %s, NULL }),\" % (name, list))\ndef parse_line(line):\n    kind = \"\"\n    data = \"\"\n    get_kind = False\n    get_data = False",
        "detail": "qemu.build.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "parse_line",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-generate",
        "description": "qemu.build.scripts.modinfo-generate",
        "peekOfCode": "def parse_line(line):\n    kind = \"\"\n    data = \"\"\n    get_kind = False\n    get_data = False\n    for item in line.split():\n        if item == \"MODINFO_START\":\n            get_kind = True\n            continue\n        if item.startswith(\"MODINFO_END\"):",
        "detail": "qemu.build.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-generate",
        "description": "qemu.build.scripts.modinfo-generate",
        "peekOfCode": "def generate(name, lines, enabled):\n    arch = \"\"\n    objs = []\n    deps = []\n    opts = []\n    for line in lines:\n        if line.find(\"MODINFO_START\") != -1:\n            (kind, data) = parse_line(line)\n            if kind == 'obj':\n                objs.append(data)",
        "detail": "qemu.build.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "print_pre",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-generate",
        "description": "qemu.build.scripts.modinfo-generate",
        "peekOfCode": "def print_pre():\n    print(\"/* generated by scripts/modinfo-generate.py */\")\n    print(\"#include \\\"qemu/osdep.h\\\"\")\n    print(\"#include \\\"qemu/module.h\\\"\")\n    print(\"const QemuModinfo qemu_modinfo[] = {{\")\ndef print_post():\n    print(\"    /* end of list */\")\n    print(\"}};\")\ndef main(args):\n    if len(args) < 3 or args[0] != '--devices':",
        "detail": "qemu.build.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "print_post",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-generate",
        "description": "qemu.build.scripts.modinfo-generate",
        "peekOfCode": "def print_post():\n    print(\"    /* end of list */\")\n    print(\"}};\")\ndef main(args):\n    if len(args) < 3 or args[0] != '--devices':\n        print('Expected: modinfo-generate.py --devices '\n              'config-device.mak [modinfo files]', file=sys.stderr)\n        exit(1)\n    # get all devices enabled in kconfig, from *-config-device.mak\n    enabled = set()",
        "detail": "qemu.build.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.modinfo-generate",
        "description": "qemu.build.scripts.modinfo-generate",
        "peekOfCode": "def main(args):\n    if len(args) < 3 or args[0] != '--devices':\n        print('Expected: modinfo-generate.py --devices '\n              'config-device.mak [modinfo files]', file=sys.stderr)\n        exit(1)\n    # get all devices enabled in kconfig, from *-config-device.mak\n    enabled = set()\n    with open(args[1]) as file:\n        for line in file.readlines():\n            config = line.split('=')",
        "detail": "qemu.build.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "Suite",
        "kind": 6,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "class Suite(object):\n    def __init__(self):\n        self.deps = set()\n        self.speeds = ['quick']\n    def names(self, base):\n        return [base if speed == 'quick' else f'{base}-{speed}' for speed in self.speeds]\nprint('''\nSPEED = quick\n.speed.quick = $(foreach s,$(sort $(filter-out %-slow %-thorough, $1)), --suite $s)\n.speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "process_tests",
        "kind": 2,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "def process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])\n    deps = itertools.chain.from_iterable(deps)\n    deps = list(deps)\n    test_suites = test['suite'] or ['default']",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "emit_prolog",
        "kind": 2,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "def emit_prolog(suites, prefix):\n    all_targets = ' '.join((f'{prefix}-{k}' for k in suites.keys()))\n    all_xml = ' '.join((f'{prefix}-report-{k}.junit.xml' for k in suites.keys()))\n    print()\n    print(f'all-{prefix}-targets = {all_targets}')\n    print(f'all-{prefix}-xml = {all_xml}')\n    print(f'.PHONY: {prefix} do-meson-{prefix} {prefix}-report.junit.xml $(all-{prefix}-targets) $(all-{prefix}-xml)')\n    print(f'ifeq ($(filter {prefix}, $(MAKECMDGOALS)),)')\n    print(f'.{prefix}.mtestargs += $(call .speed.$(SPEED), $(.{prefix}.mtest-suites))')\n    print(f'endif')",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "emit_suite_deps",
        "kind": 2,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "def emit_suite_deps(name, suite, prefix):\n    deps = ' '.join(suite.deps)\n    targets = [f'{prefix}-{name}', f'{prefix}-report-{name}.junit.xml', f'{prefix}', f'{prefix}-report.junit.xml',\n               f'{prefix}-build']\n    print()\n    print(f'.{prefix}-{name}.deps = {deps}')\n    for t in targets:\n        print(f'.ninja-goals.{t} += $(.{prefix}-{name}.deps)')\ndef emit_suite(name, suite, prefix):\n    emit_suite_deps(name, suite, prefix)",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "emit_suite",
        "kind": 2,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "def emit_suite(name, suite, prefix):\n    emit_suite_deps(name, suite, prefix)\n    targets = f'{prefix}-{name} {prefix}-report-{name}.junit.xml {prefix} {prefix}-report.junit.xml'\n    print(f'ifneq ($(filter {targets}, $(MAKECMDGOALS)),)')\n    print(f'.{prefix}.mtest-suites += ' + ' '.join(suite.names(name)))\n    print(f'endif')\ntargets = {t['id']: [os.path.relpath(f) for f in t['filename']]\n           for t in introspect['targets']}\ntestsuites = defaultdict(Suite)\nfor test in introspect['tests']:",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "SPEED",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "SPEED = quick\n.speed.quick = $(foreach s,$(sort $(filter-out %-slow %-thorough, $1)), --suite $s)\n.speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)\n.speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".speed.quick",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": ".speed.quick = $(foreach s,$(sort $(filter-out %-slow %-thorough, $1)), --suite $s)\n.speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)\n.speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".speed.slow",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": ".speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)\n.speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".speed.thorough",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": ".speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".mtestargs",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": ".mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".check.mtestargs",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": ".check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".bench.mtestargs",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": ".bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])\n    deps = itertools.chain.from_iterable(deps)",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "introspect",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "introspect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])\n    deps = itertools.chain.from_iterable(deps)\n    deps = list(deps)",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "targets",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "targets = {t['id']: [os.path.relpath(f) for f in t['filename']]\n           for t in introspect['targets']}\ntestsuites = defaultdict(Suite)\nfor test in introspect['tests']:\n    process_tests(test, targets, testsuites)\nemit_prolog(testsuites, 'check')\nfor name, suite in testsuites.items():\n    emit_suite(name, suite, 'check')\nbenchsuites = defaultdict(Suite)\nfor test in introspect['benchmarks']:",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "testsuites",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "testsuites = defaultdict(Suite)\nfor test in introspect['tests']:\n    process_tests(test, targets, testsuites)\nemit_prolog(testsuites, 'check')\nfor name, suite in testsuites.items():\n    emit_suite(name, suite, 'check')\nbenchsuites = defaultdict(Suite)\nfor test in introspect['benchmarks']:\n    process_tests(test, targets, benchsuites)\nemit_prolog(benchsuites, 'bench')",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "benchsuites",
        "kind": 5,
        "importPath": "qemu.build.scripts.mtest2make",
        "description": "qemu.build.scripts.mtest2make",
        "peekOfCode": "benchsuites = defaultdict(Suite)\nfor test in introspect['benchmarks']:\n    process_tests(test, targets, benchsuites)\nemit_prolog(benchsuites, 'bench')\nfor name, suite in benchsuites.items():\n    emit_suite(name, suite, 'bench')",
        "detail": "qemu.build.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "signcode",
        "kind": 2,
        "importPath": "qemu.build.scripts.nsis",
        "description": "qemu.build.scripts.nsis",
        "peekOfCode": "def signcode(path):\n    cmd = os.environ.get(\"SIGNCODE\")\n    if not cmd:\n        return\n    subprocess.run([cmd, path])\ndef find_deps(exe_or_dll, search_path, analyzed_deps):\n    deps = [exe_or_dll]\n    output = subprocess.check_output([\"objdump\", \"-p\", exe_or_dll], text=True)\n    output = output.split(\"\\n\")\n    for line in output:",
        "detail": "qemu.build.scripts.nsis",
        "documentation": {}
    },
    {
        "label": "find_deps",
        "kind": 2,
        "importPath": "qemu.build.scripts.nsis",
        "description": "qemu.build.scripts.nsis",
        "peekOfCode": "def find_deps(exe_or_dll, search_path, analyzed_deps):\n    deps = [exe_or_dll]\n    output = subprocess.check_output([\"objdump\", \"-p\", exe_or_dll], text=True)\n    output = output.split(\"\\n\")\n    for line in output:\n        if not line.lstrip().startswith(\"DLL Name: \"):\n            continue\n        dep = line.split(\"DLL Name: \")[1].strip()\n        if dep in analyzed_deps:\n            continue",
        "detail": "qemu.build.scripts.nsis",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.nsis",
        "description": "qemu.build.scripts.nsis",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"QEMU NSIS build helper.\")\n    parser.add_argument(\"outfile\")\n    parser.add_argument(\"prefix\")\n    parser.add_argument(\"srcdir\")\n    parser.add_argument(\"dlldir\")\n    parser.add_argument(\"cpu\")\n    parser.add_argument(\"nsisargs\", nargs=\"*\")\n    args = parser.parse_args()\n    # canonicalize the Windows native prefix path",
        "detail": "qemu.build.scripts.nsis",
        "documentation": {}
    },
    {
        "label": "do_probe",
        "kind": 2,
        "importPath": "qemu.build.scripts.probe-gdb-support",
        "description": "qemu.build.scripts.probe-gdb-support",
        "peekOfCode": "def do_probe(gdb):\n    try:\n        gdb_out = check_output([gdb,\n                               \"-ex\", \"set architecture\",\n                               \"-ex\", \"quit\"], stderr=STDOUT, encoding=\"utf-8\")\n    except (OSError) as e:\n        sys.exit(e)\n    except CalledProcessError as e:\n        sys.exit(f'{e}. Output:\\n\\n{e.output}')\n    found_gdb_archs = re.search(r'Valid arguments are (.*)', gdb_out)",
        "detail": "qemu.build.scripts.probe-gdb-support",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.probe-gdb-support",
        "description": "qemu.build.scripts.probe-gdb-support",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description='Probe GDB Architectures')\n    parser.add_argument('gdb', help='Path to GDB binary.')\n    args = parser.parse_args()\n    supported = do_probe(args.gdb)\n    print(\" \".join(supported))\nif __name__ == '__main__':\n    main()",
        "detail": "qemu.build.scripts.probe-gdb-support",
        "documentation": {}
    },
    {
        "label": "MAP",
        "kind": 5,
        "importPath": "qemu.build.scripts.probe-gdb-support",
        "description": "qemu.build.scripts.probe-gdb-support",
        "peekOfCode": "MAP = {\n    \"alpha\" : [\"alpha\"],\n    \"aarch64\" : [\"aarch64\", \"aarch64_be\"],\n    \"armv7\": [\"arm\"],\n    \"armv8-a\" : [\"aarch64\", \"aarch64_be\"],\n    \"avr\" : [\"avr\"],\n    # no hexagon in upstream gdb\n    \"hppa1.0\" : [\"hppa\"],\n    \"i386\" : [\"i386\"],\n    \"i386:x86-64\" : [\"x86_64\"],",
        "detail": "qemu.build.scripts.probe-gdb-support",
        "documentation": {}
    },
    {
        "label": "tmatch",
        "kind": 2,
        "importPath": "qemu.build.scripts.python_qmp_updater",
        "description": "qemu.build.scripts.python_qmp_updater",
        "peekOfCode": "def tmatch(template: str, text: str,\n           padding: str, res: str) -> Optional[re.Match[str]]:\n    return re.match(template.format(padding=padding, res=res), text,\n                    flags=re.MULTILINE)\ndef find_closing_brace(text: str, start: int) -> int:\n    \"\"\"\n    Having '(' at text[start] search for pairing ')' and return its index.\n    \"\"\"\n    assert text[start] == '('\n    height = 1",
        "detail": "qemu.build.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "find_closing_brace",
        "kind": 2,
        "importPath": "qemu.build.scripts.python_qmp_updater",
        "description": "qemu.build.scripts.python_qmp_updater",
        "peekOfCode": "def find_closing_brace(text: str, start: int) -> int:\n    \"\"\"\n    Having '(' at text[start] search for pairing ')' and return its index.\n    \"\"\"\n    assert text[start] == '('\n    height = 1\n    for i in range(start + 1, len(text)):\n        if text[i] == '(':\n            height += 1\n        elif text[i] == ')':",
        "detail": "qemu.build.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "update",
        "kind": 2,
        "importPath": "qemu.build.scripts.python_qmp_updater",
        "description": "qemu.build.scripts.python_qmp_updater",
        "peekOfCode": "def update(text: str) -> str:\n    result = ''\n    while True:\n        m = start_reg.search(text)\n        if m is None:\n            result += text\n            break\n        result += text[:m.start()]\n        args_ind = m.end()\n        args_end = find_closing_brace(text, args_ind - 1)",
        "detail": "qemu.build.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "start_reg",
        "kind": 5,
        "importPath": "qemu.build.scripts.python_qmp_updater",
        "description": "qemu.build.scripts.python_qmp_updater",
        "peekOfCode": "start_reg = re.compile(r'^(?P<padding> *)(?P<res>\\w+) = (?P<vm>.*).qmp\\(',\n                       flags=re.MULTILINE)\nsuccess_reg_templ = re.sub('\\n *', '', r\"\"\"\n    (\\n*{padding}(?P<comment>\\#.*$))?\n    \\n*{padding}\n    (\n        self.assert_qmp\\({res},\\ 'return',\\ {{}}\\)\n    |\n        assert\\ {res}\\['return'\\]\\ ==\\ {{}}\n    |",
        "detail": "qemu.build.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "success_reg_templ",
        "kind": 5,
        "importPath": "qemu.build.scripts.python_qmp_updater",
        "description": "qemu.build.scripts.python_qmp_updater",
        "peekOfCode": "success_reg_templ = re.sub('\\n *', '', r\"\"\"\n    (\\n*{padding}(?P<comment>\\#.*$))?\n    \\n*{padding}\n    (\n        self.assert_qmp\\({res},\\ 'return',\\ {{}}\\)\n    |\n        assert\\ {res}\\['return'\\]\\ ==\\ {{}}\n    |\n        assert\\ {res}\\ ==\\ {{'return':\\ {{}}}}\n    |",
        "detail": "qemu.build.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "some_check_templ",
        "kind": 5,
        "importPath": "qemu.build.scripts.python_qmp_updater",
        "description": "qemu.build.scripts.python_qmp_updater",
        "peekOfCode": "some_check_templ = re.sub('\\n *', '', r\"\"\"\n    (\\n*{padding}(?P<comment>\\#.*$))?\n    \\s*self.assert_qmp\\({res},\"\"\")\ndef tmatch(template: str, text: str,\n           padding: str, res: str) -> Optional[re.Match[str]]:\n    return re.match(template.format(padding=padding, res=res), text,\n                    flags=re.MULTILINE)\ndef find_closing_brace(text: str, start: int) -> int:\n    \"\"\"\n    Having '(' at text[start] search for pairing ')' and return its index.",
        "detail": "qemu.build.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "bitmap_set",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):\n    return d * math.ceil(num / d)",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "bitmap_is_set",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):\n    return d * math.ceil(num / d)\n# Holes in the input file contain only zeroes so we can skip them and\n# save time. This function returns the indexes of the clusters that",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "bitmap_iterator",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):\n    return d * math.ceil(num / d)\n# Holes in the input file contain only zeroes so we can skip them and\n# save time. This function returns the indexes of the clusters that\n# are known to contain data. Those are the ones that we need to read.\ndef clusters_with_data(fd, cluster_size):",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "align_up",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def align_up(num, d):\n    return d * math.ceil(num / d)\n# Holes in the input file contain only zeroes so we can skip them and\n# save time. This function returns the indexes of the clusters that\n# are known to contain data. Those are the ones that we need to read.\ndef clusters_with_data(fd, cluster_size):\n    data_to = 0\n    while True:\n        try:\n            data_from = os.lseek(fd, data_to, os.SEEK_DATA)",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "clusters_with_data",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def clusters_with_data(fd, cluster_size):\n    data_to = 0\n    while True:\n        try:\n            data_from = os.lseek(fd, data_to, os.SEEK_DATA)\n            data_to = align_up(os.lseek(fd, data_from, os.SEEK_HOLE), cluster_size)\n            for idx in range(data_from // cluster_size, data_to // cluster_size):\n                yield idx\n        except OSError as err:\n            if err.errno == errno.ENXIO:  # End of file reached",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "get_input_as_raw_file",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def get_input_as_raw_file(input_file, input_format):\n    if input_format == \"raw\":\n        yield input_file\n        return\n    try:\n        temp_dir = tempfile.mkdtemp()\n        pid_file = os.path.join(temp_dir, \"pid\")\n        raw_file = os.path.join(temp_dir, \"raw\")\n        open(raw_file, \"wb\").close()\n        ret = subprocess.run(",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "write_features",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def write_features(cluster, offset, data_file_name):\n    if data_file_name is not None:\n        encoded_name = data_file_name.encode(\"utf-8\")\n        padded_name_len = align_up(len(encoded_name), 8)\n        struct.pack_into(f\">II{padded_name_len}s\", cluster, offset,\n                         QCOW2_DATA_FILE_NAME_STRING,\n                         len(encoded_name),\n                         encoded_name)\n        offset += 8 + padded_name_len\n    qcow2_features = [",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "write_qcow2_content",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def write_qcow2_content(input_file, cluster_size, refcount_bits, data_file_name, data_file_raw):\n    # Some basic values\n    l1_entries_per_table = cluster_size // 8\n    l2_entries_per_table = cluster_size // 8\n    refcounts_per_table  = cluster_size // 8\n    refcounts_per_block  = cluster_size * 8 // refcount_bits\n    # Virtual disk size, number of data clusters and L1 entries\n    disk_size = align_up(os.path.getsize(input_file), 512)\n    total_data_clusters = math.ceil(disk_size / cluster_size)\n    l1_entries = math.ceil(total_data_clusters / l2_entries_per_table)",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "def main():\n    # Command-line arguments\n    parser = argparse.ArgumentParser(\n        description=\"This program converts a QEMU disk image to qcow2 \"\n        \"and writes it to the standard output\"\n    )\n    parser.add_argument(\"input_file\", help=\"name of the input file\")\n    parser.add_argument(\n        \"-f\",\n        dest=\"input_format\",",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_DEFAULT_CLUSTER_SIZE",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_DEFAULT_CLUSTER_SIZE = 65536\nQCOW2_DEFAULT_REFCOUNT_BITS = 16\nQCOW2_FEATURE_NAME_TABLE = 0x6803F857\nQCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_DEFAULT_REFCOUNT_BITS",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_DEFAULT_REFCOUNT_BITS = 16\nQCOW2_FEATURE_NAME_TABLE = 0x6803F857\nQCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_FEATURE_NAME_TABLE",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_FEATURE_NAME_TABLE = 0x6803F857\nQCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_DATA_FILE_NAME_STRING",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_V3_HEADER_LENGTH",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_INCOMPAT_DATA_FILE_BIT",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW_OFLAG_COPIED",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QEMU_STORAGE_DAEMON",
        "kind": 5,
        "importPath": "qemu.build.scripts.qcow2-to-stdout",
        "description": "qemu.build.scripts.qcow2-to-stdout",
        "peekOfCode": "QEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):",
        "detail": "qemu.build.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QemuCommand",
        "kind": 6,
        "importPath": "qemu.build.scripts.qemu-gdb",
        "description": "qemu.build.scripts.qemu-gdb",
        "peekOfCode": "class QemuCommand(gdb.Command):\n    '''Prefix for QEMU debug support commands'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE, True)\nQemuCommand()\ncoroutine.CoroutineCommand()\nmtree.MtreeCommand()\naio.HandlersCommand()\ntcg.TCGLockStatusCommand()",
        "detail": "qemu.build.scripts.qemu-gdb",
        "documentation": {}
    },
    {
        "label": "extract_symbols",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemu-plugin-symbols",
        "description": "qemu.build.scripts.qemu-plugin-symbols",
        "peekOfCode": "def extract_symbols(plugin_header):\n    with open(plugin_header) as file:\n        content = file.read()\n    # Remove QEMU_PLUGIN_API macro definition.\n    content = content.replace('#define QEMU_PLUGIN_API', '')\n    expected = content.count('QEMU_PLUGIN_API')\n    # Find last word between QEMU_PLUGIN_API and (, matching on several lines.\n    # We use *? non-greedy quantifier.\n    syms = re.findall(r'QEMU_PLUGIN_API.*?(\\w+)\\s*\\(', content, re.DOTALL)\n    syms.sort()",
        "detail": "qemu.build.scripts.qemu-plugin-symbols",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.qemu-plugin-symbols",
        "description": "qemu.build.scripts.qemu-plugin-symbols",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description='Extract QEMU plugin symbols')\n    parser.add_argument('plugin_header', help='Path to QEMU plugin header.')\n    args = parser.parse_args()\n    syms = extract_symbols(args.plugin_header)\n    print('{')\n    for s in syms:\n        print(\"  {};\".format(s))\n    print('};')\nif __name__ == '__main__':",
        "detail": "qemu.build.scripts.qemu-plugin-symbols",
        "documentation": {}
    },
    {
        "label": "sha",
        "kind": 5,
        "importPath": "qemu.build.scripts.qemu-stamp",
        "description": "qemu.build.scripts.qemu-stamp",
        "peekOfCode": "sha = hashlib.sha1()\nis_file = False\nfor arg in sys.argv[1:]:\n    if arg == '--':\n        is_file = True\n        continue\n    if is_file:\n        with open(arg, 'rb') as f:\n            for chunk in iter(lambda: f.read(65536), b''):\n                sha.update(chunk)",
        "detail": "qemu.build.scripts.qemu-stamp",
        "documentation": {}
    },
    {
        "label": "is_file",
        "kind": 5,
        "importPath": "qemu.build.scripts.qemu-stamp",
        "description": "qemu.build.scripts.qemu-stamp",
        "peekOfCode": "is_file = False\nfor arg in sys.argv[1:]:\n    if arg == '--':\n        is_file = True\n        continue\n    if is_file:\n        with open(arg, 'rb') as f:\n            for chunk in iter(lambda: f.read(65536), b''):\n                sha.update(chunk)\n    else:",
        "detail": "qemu.build.scripts.qemu-stamp",
        "documentation": {}
    },
    {
        "label": "print_cocci_rule",
        "kind": 2,
        "importPath": "qemu.build.scripts.qom-cast-macro-clean-cocci-gen",
        "description": "qemu.build.scripts.qom-cast-macro-clean-cocci-gen",
        "peekOfCode": "def print_cocci_rule(qom_typedef, qom_cast_macro):\n    print(f'''@@\ntypedef {qom_typedef};\n{qom_typedef} *obj;\n@@\n-    {qom_cast_macro}(obj)\n+    obj\n''')\npatterns = [\n    r'DECLARE_INSTANCE_CHECKER\\((\\w+),\\W*(\\w+),\\W*TYPE_\\w+\\)',",
        "detail": "qemu.build.scripts.qom-cast-macro-clean-cocci-gen",
        "documentation": {}
    },
    {
        "label": "patterns",
        "kind": 5,
        "importPath": "qemu.build.scripts.qom-cast-macro-clean-cocci-gen",
        "description": "qemu.build.scripts.qom-cast-macro-clean-cocci-gen",
        "peekOfCode": "patterns = [\n    r'DECLARE_INSTANCE_CHECKER\\((\\w+),\\W*(\\w+),\\W*TYPE_\\w+\\)',\n    r'DECLARE_OBJ_CHECKERS\\((\\w+),\\W*\\w+,\\W*(\\w+),\\W*TYPE_\\w+\\)',\n    r'OBJECT_DECLARE_TYPE\\((\\w+),\\W*\\w+,\\W*(\\w+)\\)',\n    r'OBJECT_DECLARE_SIMPLE_TYPE\\((\\w+),\\W*(\\w+)\\)',\n    r'INTERFACE_CHECK\\((\\w+),\\W*\\(\\w+\\),\\W*TYPE_(\\w+)\\)',\n]\nfor fn in sys.argv[1:]:\n    try:\n        content = open(fn, 'rt').read()",
        "detail": "qemu.build.scripts.qom-cast-macro-clean-cocci-gen",
        "documentation": {}
    },
    {
        "label": "LibvirtGuest",
        "kind": 6,
        "importPath": "qemu.build.scripts.render_block_graph",
        "description": "qemu.build.scripts.render_block_graph",
        "peekOfCode": "class LibvirtGuest():\n    def __init__(self, name):\n        self.name = name\n    def cmd(self, cmd):\n        # only supports qmp commands without parameters\n        m = {'execute': cmd}\n        ar = ['virsh', 'qemu-monitor-command', self.name, json.dumps(m)]\n        reply = json.loads(subprocess.check_output(ar))\n        if 'error' in reply:\n            raise QMPError(reply)",
        "detail": "qemu.build.scripts.render_block_graph",
        "documentation": {}
    },
    {
        "label": "perm",
        "kind": 2,
        "importPath": "qemu.build.scripts.render_block_graph",
        "description": "qemu.build.scripts.render_block_graph",
        "peekOfCode": "def perm(arr):\n    s = 'w' if 'write' in arr else '_'\n    s += 'r' if 'consistent-read' in arr else '_'\n    s += 'u' if 'write-unchanged' in arr else '_'\n    s += 's' if 'resize' in arr else '_'\n    return s\ndef render_block_graph(qmp, filename, format='png'):\n    '''\n    Render graph in text (dot) representation into \"@filename\" and\n    representation in @format into \"@filename.@format\"",
        "detail": "qemu.build.scripts.render_block_graph",
        "documentation": {}
    },
    {
        "label": "render_block_graph",
        "kind": 2,
        "importPath": "qemu.build.scripts.render_block_graph",
        "description": "qemu.build.scripts.render_block_graph",
        "peekOfCode": "def render_block_graph(qmp, filename, format='png'):\n    '''\n    Render graph in text (dot) representation into \"@filename\" and\n    representation in @format into \"@filename.@format\"\n    '''\n    bds_nodes = qmp.cmd('query-named-block-nodes')\n    bds_nodes = {n['node-name']: n for n in bds_nodes}\n    job_nodes = qmp.cmd('query-block-jobs')\n    job_nodes = {n['device']: n for n in job_nodes}\n    block_graph = qmp.cmd('x-debug-query-block-graph')",
        "detail": "qemu.build.scripts.render_block_graph",
        "documentation": {}
    },
    {
        "label": "ReplayState",
        "kind": 6,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "class ReplayState(object):\n    def __init__(self):\n        self.event = -1\n        self.event_count = 0\n        self.already_read = False\n        self.current_checkpoint = 0\n        self.checkpoint = 0\n    def set_event(self, ev):\n        self.event = ev\n        self.event_count += 1",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_byte",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def read_byte(fin):\n    \"Read a single byte\"\n    return struct.unpack('>B', fin.read(1))[0]\ndef read_event(fin):\n    \"Read a single byte event, but save some state\"\n    if replay_state.already_read:\n        return replay_state.get_event()\n    else:\n        replay_state.set_event(read_byte(fin))\n        return replay_state.event",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_event",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def read_event(fin):\n    \"Read a single byte event, but save some state\"\n    if replay_state.already_read:\n        return replay_state.get_event()\n    else:\n        replay_state.set_event(read_byte(fin))\n        return replay_state.event\ndef read_word(fin):\n    \"Read a 16 bit word\"\n    return struct.unpack('>H', fin.read(2))[0]",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_word",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def read_word(fin):\n    \"Read a 16 bit word\"\n    return struct.unpack('>H', fin.read(2))[0]\ndef read_dword(fin):\n    \"Read a 32 bit word\"\n    return struct.unpack('>I', fin.read(4))[0]\ndef read_qword(fin):\n    \"Read a 64 bit word\"\n    return struct.unpack('>Q', fin.read(8))[0]\ndef read_array(fin):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_dword",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def read_dword(fin):\n    \"Read a 32 bit word\"\n    return struct.unpack('>I', fin.read(4))[0]\ndef read_qword(fin):\n    \"Read a 64 bit word\"\n    return struct.unpack('>Q', fin.read(8))[0]\ndef read_array(fin):\n    \"Read a sized array\"\n    size = read_dword(fin)\n    data = fin.read(size)",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_qword",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def read_qword(fin):\n    \"Read a 64 bit word\"\n    return struct.unpack('>Q', fin.read(8))[0]\ndef read_array(fin):\n    \"Read a sized array\"\n    size = read_dword(fin)\n    data = fin.read(size)\n    return data\n# Generic decoder structure\nDecoder = namedtuple(\"Decoder\", \"eid name fn\")",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_array",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def read_array(fin):\n    \"Read a sized array\"\n    size = read_dword(fin)\n    data = fin.read(size)\n    return data\n# Generic decoder structure\nDecoder = namedtuple(\"Decoder\", \"eid name fn\")\ndef call_decode(table, index, dumpfile):\n    \"Search decode table for next step\"\n    decoder = next((d for d in table if d.eid == index), None)",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "call_decode",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def call_decode(table, index, dumpfile):\n    \"Search decode table for next step\"\n    decoder = next((d for d in table if d.eid == index), None)\n    if not decoder:\n        print(\"Could not decode index: %d\" % (index))\n        print(\"Entry is: %s\" % (decoder))\n        print(\"Decode Table is:\\n%s\" % (table))\n        raise(Exception(\"unknown event\"))\n    else:\n        return decoder.fn(decoder.eid, decoder.name, dumpfile)",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "print_event",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def print_event(eid, name, string=None, event_count=None):\n    \"Print event with count\"\n    if not event_count:\n        event_count = replay_state.event_count\n    if string:\n        print(\"%d:%s(%d) %s\" % (event_count, name, eid, string))\n    else:\n        print(\"%d:%s(%d)\" % (event_count, name, eid))\n# Decoders for each event type\ndef decode_unimp(eid, name, _unused_dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_unimp",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_unimp(eid, name, _unused_dumpfile):\n    \"Unimplemented decoder, will trigger exit\"\n    print(\"%s not handled - will now stop\" % (name))\n    raise(Exception(\"unhandled event\"))\ndef decode_plain(eid, name, _unused_dumpfile):\n    \"Plain events without additional data\"\n    print_event(eid, name, \"no data\")\n    return True\n# Checkpoint decoder\ndef swallow_async_qword(eid, name, dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_plain",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_plain(eid, name, _unused_dumpfile):\n    \"Plain events without additional data\"\n    print_event(eid, name, \"no data\")\n    return True\n# Checkpoint decoder\ndef swallow_async_qword(eid, name, dumpfile):\n    \"Swallow a qword of data without looking at it\"\n    step_id = read_qword(dumpfile)\n    print(\"  %s(%d) @ %d\" % (name, eid, step_id))\n    return True",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "swallow_async_qword",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def swallow_async_qword(eid, name, dumpfile):\n    \"Swallow a qword of data without looking at it\"\n    step_id = read_qword(dumpfile)\n    print(\"  %s(%d) @ %d\" % (name, eid, step_id))\n    return True\ndef swallow_bytes(eid, name, dumpfile, nr):\n    \"\"\"Swallow nr bytes of data without looking at it\"\"\"\n    dumpfile.seek(nr, os.SEEK_CUR)\ntotal_insns = 0\ndef decode_instruction(eid, name, dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "swallow_bytes",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def swallow_bytes(eid, name, dumpfile, nr):\n    \"\"\"Swallow nr bytes of data without looking at it\"\"\"\n    dumpfile.seek(nr, os.SEEK_CUR)\ntotal_insns = 0\ndef decode_instruction(eid, name, dumpfile):\n    global total_insns\n    ins_diff = read_dword(dumpfile)\n    total_insns += ins_diff\n    print_event(eid, name, \"+ %d -> %d\" % (ins_diff, total_insns))\n    return True",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_instruction",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_instruction(eid, name, dumpfile):\n    global total_insns\n    ins_diff = read_dword(dumpfile)\n    total_insns += ins_diff\n    print_event(eid, name, \"+ %d -> %d\" % (ins_diff, total_insns))\n    return True\ndef decode_interrupt(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_exception(eid, name, dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_interrupt",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_interrupt(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_exception(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\n# v12 does away with the additional event byte and encodes it in the main type\n# Between v8 and v9, REPLAY_ASYNC_BH_ONESHOT was added, but we don't decode\n# those versions so leave it out.\nasync_decode_table = [ Decoder(0, \"REPLAY_ASYNC_EVENT_BH\", swallow_async_qword),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_exception",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_exception(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\n# v12 does away with the additional event byte and encodes it in the main type\n# Between v8 and v9, REPLAY_ASYNC_BH_ONESHOT was added, but we don't decode\n# those versions so leave it out.\nasync_decode_table = [ Decoder(0, \"REPLAY_ASYNC_EVENT_BH\", swallow_async_qword),\n                       Decoder(1, \"REPLAY_ASYNC_INPUT\", decode_unimp),\n                       Decoder(2, \"REPLAY_ASYNC_INPUT_SYNC\", decode_unimp),\n                       Decoder(3, \"REPLAY_ASYNC_CHAR_READ\", decode_unimp),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_old",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_async_old(eid, name, dumpfile):\n    \"\"\"Decode an ASYNC event (pre-v8)\"\"\"\n    print_event(eid, name)\n    async_event_kind = read_byte(dumpfile)\n    async_event_checkpoint = read_byte(dumpfile)\n    if async_event_checkpoint != replay_state.current_checkpoint:\n        print(\"  mismatch between checkpoint %d and async data %d\" % (\n            replay_state.current_checkpoint, async_event_checkpoint))\n        return True\n    return call_decode(async_decode_table, async_event_kind, dumpfile)",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_bh",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_async_bh(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_bh_oneshot(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_char_read(eid, name, dumpfile):\n    char_id = read_byte(dumpfile)",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_bh_oneshot",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_async_bh_oneshot(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_char_read(eid, name, dumpfile):\n    char_id = read_byte(dumpfile)\n    size = read_dword(dumpfile)\n    print_event(eid, name, \"device:%x chars:%s\" % (char_id, dumpfile.read(size)))\n    return True\ndef decode_async_block(eid, name, dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_char_read",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_async_char_read(eid, name, dumpfile):\n    char_id = read_byte(dumpfile)\n    size = read_dword(dumpfile)\n    print_event(eid, name, \"device:%x chars:%s\" % (char_id, dumpfile.read(size)))\n    return True\ndef decode_async_block(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_net(eid, name, dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_block",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_async_block(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_net(eid, name, dumpfile):\n    net_id = read_byte(dumpfile)\n    flags = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    print_event(eid, name, \"net:%x flags:%x bytes:%d\" % (net_id, flags, size))",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_net",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_async_net(eid, name, dumpfile):\n    net_id = read_byte(dumpfile)\n    flags = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    print_event(eid, name, \"net:%x flags:%x bytes:%d\" % (net_id, flags, size))\n    return True\ndef decode_shutdown(eid, name, dumpfile):\n    print_event(eid, name)\n    return True",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_shutdown",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_shutdown(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_char_write(eid, name, dumpfile):\n    res = read_dword(dumpfile)\n    offset = read_dword(dumpfile)\n    print_event(eid, name, \"%d -> %d\" % (offset, res))\n    return True\ndef decode_audio_out(eid, name, dumpfile):\n    audio_data = read_dword(dumpfile)",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_char_write",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_char_write(eid, name, dumpfile):\n    res = read_dword(dumpfile)\n    offset = read_dword(dumpfile)\n    print_event(eid, name, \"%d -> %d\" % (offset, res))\n    return True\ndef decode_audio_out(eid, name, dumpfile):\n    audio_data = read_dword(dumpfile)\n    print_event(eid, name, \"%d\" % (audio_data))\n    return True\ndef decode_random(eid, name, dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_audio_out",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_audio_out(eid, name, dumpfile):\n    audio_data = read_dword(dumpfile)\n    print_event(eid, name, \"%d\" % (audio_data))\n    return True\ndef decode_random(eid, name, dumpfile):\n    ret = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    if (ret):\n        print_event(eid, name, \"%d bytes (getrandom failed)\" % (size))",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_random",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_random(eid, name, dumpfile):\n    ret = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    if (ret):\n        print_event(eid, name, \"%d bytes (getrandom failed)\" % (size))\n    else:\n        print_event(eid, name, \"%d bytes\" % (size))\n    return True\ndef decode_clock(eid, name, dumpfile):",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_clock",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_clock(eid, name, dumpfile):\n    clock_data = read_qword(dumpfile)\n    print_event(eid, name, \"0x%x\" % (clock_data))\n    return True\ndef __decode_checkpoint(eid, name, dumpfile, old):\n    \"\"\"Decode a checkpoint.\n    Checkpoints contain a series of async events with their own specific data.\n    \"\"\"\n    replay_state.set_checkpoint()\n    # save event count as we peek ahead",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_checkpoint_old",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_checkpoint_old(eid, name, dumpfile):\n    return __decode_checkpoint(eid, name, dumpfile, False)\ndef decode_checkpoint(eid, name, dumpfile):\n    return __decode_checkpoint(eid, name, dumpfile, True)\ndef decode_checkpoint_init(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_checkpoint",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_checkpoint(eid, name, dumpfile):\n    return __decode_checkpoint(eid, name, dumpfile, True)\ndef decode_checkpoint_init(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False\n# pre-MTTCG merge\nv5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_checkpoint_init",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_checkpoint_init(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False\n# pre-MTTCG merge\nv5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_end",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False\n# pre-MTTCG merge\nv5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_CHAR_WRITE\", decode_char_write),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def parse_arguments():\n    \"Grab arguments for script\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-f\", \"--file\", help='record/replay dump to read from',\n                        required=True)\n    return parser.parse_args()\ndef decode_file(filename):\n    \"Decode a record/replay dump\"\n    dumpfile = open(filename, \"rb\")\n    dumpsize = path.getsize(filename)",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_file",
        "kind": 2,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "def decode_file(filename):\n    \"Decode a record/replay dump\"\n    dumpfile = open(filename, \"rb\")\n    dumpsize = path.getsize(filename)\n    # read and throwaway the header\n    version = read_dword(dumpfile)\n    junk = read_qword(dumpfile)\n    # see REPLAY_VERSION\n    print(\"HEADER: version 0x%x\" % (version))\n    if version == 0xe0200c:",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "replay_state",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "replay_state = ReplayState()\n# Simple read functions that mirror replay-internal.c\n# The file-stream is big-endian and manually written out a byte at a time.\ndef read_byte(fin):\n    \"Read a single byte\"\n    return struct.unpack('>B', fin.read(1))[0]\ndef read_event(fin):\n    \"Read a single byte event, but save some state\"\n    if replay_state.already_read:\n        return replay_state.get_event()",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "Decoder = namedtuple(\"Decoder\", \"eid name fn\")\ndef call_decode(table, index, dumpfile):\n    \"Search decode table for next step\"\n    decoder = next((d for d in table if d.eid == index), None)\n    if not decoder:\n        print(\"Could not decode index: %d\" % (index))\n        print(\"Entry is: %s\" % (decoder))\n        print(\"Decode Table is:\\n%s\" % (table))\n        raise(Exception(\"unknown event\"))\n    else:",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "total_insns",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "total_insns = 0\ndef decode_instruction(eid, name, dumpfile):\n    global total_insns\n    ins_diff = read_dword(dumpfile)\n    total_insns += ins_diff\n    print_event(eid, name, \"+ %d -> %d\" % (ins_diff, total_insns))\n    return True\ndef decode_interrupt(eid, name, dumpfile):\n    print_event(eid, name)\n    return True",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "async_decode_table",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "async_decode_table = [ Decoder(0, \"REPLAY_ASYNC_EVENT_BH\", swallow_async_qword),\n                       Decoder(1, \"REPLAY_ASYNC_INPUT\", decode_unimp),\n                       Decoder(2, \"REPLAY_ASYNC_INPUT_SYNC\", decode_unimp),\n                       Decoder(3, \"REPLAY_ASYNC_CHAR_READ\", decode_unimp),\n                       Decoder(4, \"REPLAY_ASYNC_EVENT_BLOCK\", decode_unimp),\n                       Decoder(5, \"REPLAY_ASYNC_EVENT_NET\", decode_unimp),\n]\n# See replay_read_events/replay_read_event\ndef decode_async_old(eid, name, dumpfile):\n    \"\"\"Decode an ASYNC event (pre-v8)\"\"\"",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v5_event_table",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "v5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_CHAR_WRITE\", decode_char_write),\n                  Decoder(6, \"EVENT_CHAR_READ_ALL\", decode_unimp),\n                  Decoder(7, \"EVENT_CHAR_READ_ALL_ERROR\", decode_unimp),\n                  Decoder(8, \"EVENT_CLOCK_HOST\", decode_clock),\n                  Decoder(9, \"EVENT_CLOCK_VIRTUAL_RT\", decode_clock),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v6_event_table",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "v6_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_CHAR_WRITE\", decode_char_write),\n                  Decoder(6, \"EVENT_CHAR_READ_ALL\", decode_unimp),\n                  Decoder(7, \"EVENT_CHAR_READ_ALL_ERROR\", decode_unimp),\n                  Decoder(8, \"EVENT_AUDIO_OUT\", decode_audio_out),\n                  Decoder(9, \"EVENT_AUDIO_IN\", decode_unimp),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v7_event_table",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "v7_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_unimp),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_SHUTDOWN_HOST_ERR\", decode_unimp),\n                  Decoder(6, \"EVENT_SHUTDOWN_HOST_QMP\", decode_unimp),\n                  Decoder(7, \"EVENT_SHUTDOWN_HOST_SIGNAL\", decode_unimp),\n                  Decoder(8, \"EVENT_SHUTDOWN_HOST_UI\", decode_unimp),\n                  Decoder(9, \"EVENT_SHUTDOWN_GUEST_SHUTDOWN\", decode_unimp),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v12_event_table",
        "kind": 5,
        "importPath": "qemu.build.scripts.replay-dump",
        "description": "qemu.build.scripts.replay-dump",
        "peekOfCode": "v12_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_exception),\n                  Decoder(3, \"EVENT_ASYNC_BH\", decode_async_bh),\n                  Decoder(4, \"EVENT_ASYNC_BH_ONESHOT\", decode_async_bh_oneshot),\n                  Decoder(5, \"EVENT_ASYNC_INPUT\", decode_unimp),\n                  Decoder(6, \"EVENT_ASYNC_INPUT_SYNC\", decode_unimp),\n                  Decoder(7, \"EVENT_ASYNC_CHAR_READ\", decode_async_char_read),\n                  Decoder(8, \"EVENT_ASYNC_BLOCK\", decode_async_block),\n                  Decoder(9, \"EVENT_ASYNC_NET\", decode_async_net),",
        "detail": "qemu.build.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.shaderinclude",
        "description": "qemu.build.scripts.shaderinclude",
        "peekOfCode": "def main(args):\n    file_path = args[1]\n    basename = os.path.basename(file_path)\n    varname = basename.replace('-', '_').replace('.', '_')\n    with os.fdopen(sys.stdout.fileno(), \"wt\", closefd=False, newline='\\n') as stdout:\n        with open(file_path, \"r\", encoding='utf-8') as file:\n            print(f'static GLchar {varname}_src[] =', file=stdout)\n            for line in file:\n                line = line.rstrip()\n                print(f'    \"{line}\\\\n\"', file=stdout)",
        "detail": "qemu.build.scripts.shaderinclude",
        "documentation": {}
    },
    {
        "label": "fin",
        "kind": 5,
        "importPath": "qemu.build.scripts.signrom",
        "description": "qemu.build.scripts.signrom",
        "peekOfCode": "fin = open(sys.argv[1], 'rb')\nfout = open(sys.argv[2], 'wb')\nmagic = fin.read(2)\nif magic != b'\\x55\\xaa':\n    sys.exit(\"%s: option ROM does not begin with magic 55 aa\" % sys.argv[1])\nsize_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:",
        "detail": "qemu.build.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "fout",
        "kind": 5,
        "importPath": "qemu.build.scripts.signrom",
        "description": "qemu.build.scripts.signrom",
        "peekOfCode": "fout = open(sys.argv[2], 'wb')\nmagic = fin.read(2)\nif magic != b'\\x55\\xaa':\n    sys.exit(\"%s: option ROM does not begin with magic 55 aa\" % sys.argv[1])\nsize_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))",
        "detail": "qemu.build.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "magic",
        "kind": 5,
        "importPath": "qemu.build.scripts.signrom",
        "description": "qemu.build.scripts.signrom",
        "peekOfCode": "magic = fin.read(2)\nif magic != b'\\x55\\xaa':\n    sys.exit(\"%s: option ROM does not begin with magic 55 aa\" % sys.argv[1])\nsize_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)",
        "detail": "qemu.build.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "size_byte",
        "kind": 5,
        "importPath": "qemu.build.scripts.signrom",
        "description": "qemu.build.scripts.signrom",
        "peekOfCode": "size_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)\nelif len(data) < size:\n    # Add padding if necessary, rounding the whole input to a multiple of\n    # 512 bytes according to the third byte of the input.",
        "detail": "qemu.build.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "qemu.build.scripts.signrom",
        "description": "qemu.build.scripts.signrom",
        "peekOfCode": "data = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)\nelif len(data) < size:\n    # Add padding if necessary, rounding the whole input to a multiple of\n    # 512 bytes according to the third byte of the input.\n    # size-1 because a final byte is added below to store the checksum.\n    data = data.ljust(size-1, b'\\0')",
        "detail": "qemu.build.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "qemu.build.scripts.signrom",
        "description": "qemu.build.scripts.signrom",
        "peekOfCode": "size = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)\nelif len(data) < size:\n    # Add padding if necessary, rounding the whole input to a multiple of\n    # 512 bytes according to the third byte of the input.\n    # size-1 because a final byte is added below to store the checksum.\n    data = data.ljust(size-1, b'\\0')\nelse:",
        "detail": "qemu.build.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "checksum",
        "kind": 5,
        "importPath": "qemu.build.scripts.signrom",
        "description": "qemu.build.scripts.signrom",
        "peekOfCode": "checksum = 0\nfor b in data:\n    checksum = (checksum - b) & 255\nfout.write(struct.pack('B', checksum))\nfin.close()\nfout.close()",
        "detail": "qemu.build.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "SimpleException",
        "kind": 6,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "class SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')\n    return struct.unpack(hfmt, hdr)\ndef get_mapping(fobj):",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "Analyzer",
        "kind": 6,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "class Analyzer:\n    \"\"\"[Deprecated. Refer to Analyzer2 instead.]\n    A trace file analyzer which processes trace records.\n    An analyzer can be passed to run() or process().  The begin() method is\n    invoked, then each trace record is processed, and finally the end() method\n    is invoked. When Analyzer is used as a context-manager (using the `with`\n    statement), begin() and end() are called automatically.\n    If a method matching a trace event name exists, it is invoked to process\n    that trace record.  Otherwise the catchall() method is invoked.\n    Example:",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "Analyzer2",
        "kind": 6,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "class Analyzer2(Analyzer):\n    \"\"\"A trace file analyzer which processes trace records.\n    An analyzer can be passed to run() or process().  The begin() method is\n    invoked, then each trace record is processed, and finally the end() method\n    is invoked. When Analyzer is used as a context-manager (using the `with`\n    statement), begin() and end() are called automatically.\n    If a method matching a trace event name exists, it is invoked to process\n    that trace record.  Otherwise the catchall() method is invoked.\n    The methods are called with a set of keyword-arguments. These can be ignored\n    using `**kwargs` or defined like any keyword-argument.",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_header",
        "kind": 2,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "def read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')\n    return struct.unpack(hfmt, hdr)\ndef get_mapping(fobj):\n    (event_id, ) = struct.unpack('=Q', fobj.read(8))\n    (len, ) = struct.unpack('=L', fobj.read(4))",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "get_mapping",
        "kind": 2,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "def get_mapping(fobj):\n    (event_id, ) = struct.unpack('=Q', fobj.read(8))\n    (len, ) = struct.unpack('=L', fobj.read(4))\n    name = fobj.read(len).decode()\n    return (event_id, name)\ndef read_record(fobj):\n    \"\"\"Deserialize a trace record from a file into a tuple (event_num, timestamp, pid, args).\"\"\"\n    event_id, timestamp_ns, record_length, record_pid = read_header(fobj, rec_header_fmt)\n    args_payload = fobj.read(record_length - rec_header_fmt_len)\n    return (event_id, timestamp_ns, record_pid, args_payload)",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_record",
        "kind": 2,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "def read_record(fobj):\n    \"\"\"Deserialize a trace record from a file into a tuple (event_num, timestamp, pid, args).\"\"\"\n    event_id, timestamp_ns, record_length, record_pid = read_header(fobj, rec_header_fmt)\n    args_payload = fobj.read(record_length - rec_header_fmt_len)\n    return (event_id, timestamp_ns, record_pid, args_payload)\ndef read_trace_header(fobj):\n    \"\"\"Read and verify trace file header\"\"\"\n    _header_event_id, _header_magic, log_version = read_header(fobj, log_header_fmt)\n    if _header_event_id != header_event_id:\n        raise ValueError(f'Not a valid trace file, header id {_header_event_id} != {header_event_id}')",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_trace_header",
        "kind": 2,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "def read_trace_header(fobj):\n    \"\"\"Read and verify trace file header\"\"\"\n    _header_event_id, _header_magic, log_version = read_header(fobj, log_header_fmt)\n    if _header_event_id != header_event_id:\n        raise ValueError(f'Not a valid trace file, header id {_header_event_id} != {header_event_id}')\n    if _header_magic != header_magic:\n        raise ValueError(f'Not a valid trace file, header magic {_header_magic} != {header_magic}')\n    if log_version not in [0, 2, 3, 4]:\n        raise ValueError(f'Unknown version {log_version} of tracelog format!')\n    if log_version != 4:",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_trace_records",
        "kind": 2,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "def read_trace_records(events, fobj, read_header):\n    \"\"\"Deserialize trace records from a file, yielding record tuples (event, event_num, timestamp, pid, arg1, ..., arg6).\n    Args:\n        event_mapping (str -> Event): events dict, indexed by name\n        fobj (file): input file\n        read_header (bool): whether headers were read from fobj\n    \"\"\"\n    frameinfo = inspect.getframeinfo(inspect.currentframe())\n    dropped_event = Event.build(\"Dropped_Event(uint64_t num_events_dropped)\",\n                                frameinfo.lineno + 1, frameinfo.filename)",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "def process(events, log, analyzer, read_header=True):\n    \"\"\"Invoke an analyzer on each event in a log.\n    Args:\n        events (file-object or list or str): events list or file-like object or file path as str to read event data from\n        log (file-object or str): file-like object or file path as str to read log data from\n        analyzer (Analyzer): Instance of Analyzer to interpret the event data\n        read_header (bool, optional): Whether to read header data from the log data. Defaults to True.\n    \"\"\"\n    if isinstance(events, str):\n        with open(events, 'r') as f:",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "def run(analyzer):\n    \"\"\"Execute an analyzer on a trace file given on the command-line.\n    This function is useful as a driver for simple analysis scripts.  More\n    advanced scripts will want to call process() instead.\"\"\"\n    try:\n        # NOTE: See built-in `argparse` module for a more robust cli interface\n        *no_header, trace_event_path, trace_file_path = sys.argv[1:]\n        assert no_header == [] or no_header == ['--no-header'], 'Invalid no-header argument'\n    except (AssertionError, ValueError):\n        raise SimpleException(f'usage: {sys.argv[0]} [--no-header] <trace-events> <trace-file>\\n')",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "__all__ = ['Analyzer', 'Analyzer2', 'process', 'run']\n# This is the binary format that the QEMU \"simple\" trace backend\n# emits. There is no specification documentation because the format is\n# not guaranteed to be stable. Trace files must be parsed with the\n# same trace-events-all file and the same simpletrace.py file that\n# QEMU was built with.\nheader_event_id = 0xffffffffffffffff\nheader_magic    = 0xf2b177cb0aa429b4\ndropped_event_id = 0xfffffffffffffffe\nrecord_type_mapping = 0",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "header_event_id",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "header_event_id = 0xffffffffffffffff\nheader_magic    = 0xf2b177cb0aa429b4\ndropped_event_id = 0xfffffffffffffffe\nrecord_type_mapping = 0\nrecord_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "dropped_event_id",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "dropped_event_id = 0xfffffffffffffffe\nrecord_type_mapping = 0\nrecord_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "record_type_mapping",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "record_type_mapping = 0\nrecord_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "record_type_event",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "record_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "log_header_fmt",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "log_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "rec_header_fmt",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "rec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "rec_header_fmt_len",
        "kind": 5,
        "importPath": "qemu.build.scripts.simpletrace",
        "description": "qemu.build.scripts.simpletrace",
        "peekOfCode": "rec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')\n    return struct.unpack(hfmt, hdr)",
        "detail": "qemu.build.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "destdir_join",
        "kind": 2,
        "importPath": "qemu.build.scripts.symlink-install-tree",
        "description": "qemu.build.scripts.symlink-install-tree",
        "peekOfCode": "def destdir_join(d1: str, d2: str) -> str:\n    if not d1:\n        return d2\n    # c:\\destdir + c:\\prefix must produce c:\\destdir\\prefix\n    return str(PurePath(d1, *PurePath(d2).parts[1:]))\nintrospect = os.environ.get('MESONINTROSPECT')\nout = subprocess.run([*shlex.split(introspect), '--installed'],\n                     stdout=subprocess.PIPE, check=True).stdout\nfor source, dest in json.loads(out).items():\n    bundle_dest = destdir_join('qemu-bundle', dest)",
        "detail": "qemu.build.scripts.symlink-install-tree",
        "documentation": {}
    },
    {
        "label": "introspect",
        "kind": 5,
        "importPath": "qemu.build.scripts.symlink-install-tree",
        "description": "qemu.build.scripts.symlink-install-tree",
        "peekOfCode": "introspect = os.environ.get('MESONINTROSPECT')\nout = subprocess.run([*shlex.split(introspect), '--installed'],\n                     stdout=subprocess.PIPE, check=True).stdout\nfor source, dest in json.loads(out).items():\n    bundle_dest = destdir_join('qemu-bundle', dest)\n    path = os.path.dirname(bundle_dest)\n    try:\n        os.makedirs(path, exist_ok=True)\n    except BaseException as e:\n        print(f'error making directory {path}', file=sys.stderr)",
        "detail": "qemu.build.scripts.symlink-install-tree",
        "documentation": {}
    },
    {
        "label": "out",
        "kind": 5,
        "importPath": "qemu.build.scripts.symlink-install-tree",
        "description": "qemu.build.scripts.symlink-install-tree",
        "peekOfCode": "out = subprocess.run([*shlex.split(introspect), '--installed'],\n                     stdout=subprocess.PIPE, check=True).stdout\nfor source, dest in json.loads(out).items():\n    bundle_dest = destdir_join('qemu-bundle', dest)\n    path = os.path.dirname(bundle_dest)\n    try:\n        os.makedirs(path, exist_ok=True)\n    except BaseException as e:\n        print(f'error making directory {path}', file=sys.stderr)\n        raise e",
        "detail": "qemu.build.scripts.symlink-install-tree",
        "documentation": {}
    },
    {
        "label": "error_opt",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool",
        "description": "qemu.build.scripts.tracetool",
        "peekOfCode": "def error_opt(msg = None):\n    if msg is not None:\n        error_write(\"Error: \" + msg + \"\\n\")\n    backend_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                                for n,d in tracetool.backend.get_list() ])\n    format_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                               for n,d in tracetool.format.get_list() ])\n    error_write(\"\"\"\\\nUsage: %(script)s --format=<format> --backends=<backends> [<options>] <trace-events> ... <output>\nBackends:",
        "detail": "qemu.build.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.tracetool",
        "description": "qemu.build.scripts.tracetool",
        "peekOfCode": "def main(args):\n    global _SCRIPT\n    _SCRIPT = args[0]\n    long_opts = [\"backends=\", \"format=\", \"help\", \"list-backends\",\n                 \"check-backends\", \"group=\"]\n    long_opts += [\"binary=\", \"probe-prefix=\"]\n    try:\n        opts, args = getopt.getopt(args[1:], \"\", long_opts)\n    except getopt.GetoptError as err:\n        error_opt(str(err))",
        "detail": "qemu.build.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool",
        "description": "qemu.build.scripts.tracetool",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport sys\nimport getopt\nfrom tracetool import error_write, out, out_open\nimport tracetool.backend\nimport tracetool.format\n_SCRIPT = \"\"\ndef error_opt(msg = None):\n    if msg is not None:",
        "detail": "qemu.build.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "_SCRIPT",
        "kind": 5,
        "importPath": "qemu.build.scripts.tracetool",
        "description": "qemu.build.scripts.tracetool",
        "peekOfCode": "_SCRIPT = \"\"\ndef error_opt(msg = None):\n    if msg is not None:\n        error_write(\"Error: \" + msg + \"\\n\")\n    backend_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                                for n,d in tracetool.backend.get_list() ])\n    format_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                               for n,d in tracetool.format.get_list() ])\n    error_write(\"\"\"\\\nUsage: %(script)s --format=<format> --backends=<backends> [<options>] <trace-events> ... <output>",
        "detail": "qemu.build.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "write_setup_dir",
        "kind": 2,
        "importPath": "qemu.build.scripts.u2f-setup-gen",
        "description": "qemu.build.scripts.u2f-setup-gen",
        "peekOfCode": "def write_setup_dir(dirpath: str, privkey_pem: bytes, cert_pem: bytes,\n                    entropy: bytes, counter: int) -> None:\n    \"\"\"\n    Write the setup directory.\n    Args:\n        dirpath: The directory path.\n        key_pem: The private key PEM.\n        cert_pem: The certificate PEM.\n        entropy: The 48 bytes of entropy.\n        counter: The counter value.",
        "detail": "qemu.build.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "generate_ec_key_pair",
        "kind": 2,
        "importPath": "qemu.build.scripts.u2f-setup-gen",
        "description": "qemu.build.scripts.u2f-setup-gen",
        "peekOfCode": "def generate_ec_key_pair() -> Tuple[str, str]:\n    \"\"\"\n    Generate an ec key pair.\n    Returns:\n        The private and public key PEM.\n    \"\"\"\n    # Key generation\n    privkey = ec.generate_private_key(ec.SECP256R1, default_backend())\n    pubkey = privkey.public_key()\n    # PEM serialization",
        "detail": "qemu.build.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "generate_certificate",
        "kind": 2,
        "importPath": "qemu.build.scripts.u2f-setup-gen",
        "description": "qemu.build.scripts.u2f-setup-gen",
        "peekOfCode": "def generate_certificate(privkey_pem: str, pubkey_pem: str) -> str:\n    \"\"\"\n    Generate a x509 certificate from a key pair.\n    Args:\n        privkey_pem: The private key PEM.\n        pubkey_pem: The public key PEM.\n    Returns:\n        The certificate PEM.\n    \"\"\"\n    # Convert key pair",
        "detail": "qemu.build.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "generate_setup_dir",
        "kind": 2,
        "importPath": "qemu.build.scripts.u2f-setup-gen",
        "description": "qemu.build.scripts.u2f-setup-gen",
        "peekOfCode": "def generate_setup_dir(dirpath: str) -> None:\n    \"\"\"\n    Generates the setup directory.\n    Args:\n        dirpath: The directory path.\n    \"\"\"\n    # Key pair\n    privkey_pem, pubkey_pem = generate_ec_key_pair()\n    # Certificate\n    certificate_pem = generate_certificate(privkey_pem, pubkey_pem)",
        "detail": "qemu.build.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.u2f-setup-gen",
        "description": "qemu.build.scripts.u2f-setup-gen",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    Main function\n    \"\"\"\n    # Dir path\n    if len(sys.argv) != 2:\n        sys.stderr.write(f'Usage: {sys.argv[0]} <setup_dir>\\n')\n        exit(2)\n    dirpath = sys.argv[1]\n    # Dir non existence",
        "detail": "qemu.build.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "filter_lines_set",
        "kind": 2,
        "importPath": "qemu.build.scripts.undefsym",
        "description": "qemu.build.scripts.undefsym",
        "peekOfCode": "def filter_lines_set(stdout, from_staticlib):\n    linesSet = set()\n    for line in stdout.splitlines():\n        tokens = line.split(b' ')\n        if len(tokens) >= 2:\n            if from_staticlib and tokens[1] == b'U':\n                continue\n            if not from_staticlib and tokens[1] != b'U':\n                continue\n            new_line = b'-Wl,-u,' + tokens[0]",
        "detail": "qemu.build.scripts.undefsym",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.undefsym",
        "description": "qemu.build.scripts.undefsym",
        "peekOfCode": "def main(args):\n    if len(args) <= 3:\n        sys.exit(0)\n    nm = args[1]\n    staticlib = args[2]\n    pc = subprocess.run([nm, \"-P\", \"-g\", staticlib], stdout=subprocess.PIPE)\n    if pc.returncode != 0:\n        sys.exit(1)\n    staticlib_syms = filter_lines_set(pc.stdout, True)\n    shared_modules = args[3:]",
        "detail": "qemu.build.scripts.undefsym",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.build.scripts.userfaultfd-wrlat",
        "description": "qemu.build.scripts.userfaultfd-wrlat",
        "peekOfCode": "def usage():\n    print(\"USAGE: %s [interval [count]]\" % argv[0])\n    exit()\n# define BPF program\nbpf_text = \"\"\"\n#include <uapi/linux/ptrace.h>\n#include <linux/mm.h>\nBPF_HASH(ev_start, u32, u64);\nBPF_HISTOGRAM(ev_delta_hist, u64);\n/* Trace UFFD page fault start event. */",
        "detail": "qemu.build.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "bpf_text",
        "kind": 5,
        "importPath": "qemu.build.scripts.userfaultfd-wrlat",
        "description": "qemu.build.scripts.userfaultfd-wrlat",
        "peekOfCode": "bpf_text = \"\"\"\n#include <uapi/linux/ptrace.h>\n#include <linux/mm.h>\nBPF_HASH(ev_start, u32, u64);\nBPF_HISTOGRAM(ev_delta_hist, u64);\n/* Trace UFFD page fault start event. */\nstatic void do_event_start()\n{\n    /* Using \"(u32)\" to drop group ID which is upper 32 bits */\n    u32 tid = (u32) bpf_get_current_pid_tgid();",
        "detail": "qemu.build.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "interval",
        "kind": 5,
        "importPath": "qemu.build.scripts.userfaultfd-wrlat",
        "description": "qemu.build.scripts.userfaultfd-wrlat",
        "peekOfCode": "interval = 10\ncount = -1\nif len(argv) > 1:\n    try:\n        interval = int(argv[1])\n        if interval == 0:\n            raise\n        if len(argv) > 2:\n            count = int(argv[2])\n    except:    # also catches -h, --help",
        "detail": "qemu.build.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "qemu.build.scripts.userfaultfd-wrlat",
        "description": "qemu.build.scripts.userfaultfd-wrlat",
        "peekOfCode": "count = -1\nif len(argv) > 1:\n    try:\n        interval = int(argv[1])\n        if interval == 0:\n            raise\n        if len(argv) > 2:\n            count = int(argv[2])\n    except:    # also catches -h, --help\n        usage()",
        "detail": "qemu.build.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "qemu.build.scripts.userfaultfd-wrlat",
        "description": "qemu.build.scripts.userfaultfd-wrlat",
        "peekOfCode": "b = BPF(text=bpf_text)\n# attach KRPOBEs\nb.attach_kprobe(event=\"handle_userfault\", fn_name=\"probe_handle_userfault\")\nb.attach_kretprobe(event=\"handle_userfault\", fn_name=\"retprobe_handle_userfault\")\n# header\nprint(\"Tracing UFFD-WP write fault latency... Hit Ctrl-C to end.\")\n# output\nloop = 0\ndo_exit = 0\nwhile (1):",
        "detail": "qemu.build.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "loop",
        "kind": 5,
        "importPath": "qemu.build.scripts.userfaultfd-wrlat",
        "description": "qemu.build.scripts.userfaultfd-wrlat",
        "peekOfCode": "loop = 0\ndo_exit = 0\nwhile (1):\n    if count > 0:\n        loop += 1\n        if loop > count:\n            exit()\n    try:\n        sleep(interval)\n    except KeyboardInterrupt:",
        "detail": "qemu.build.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "do_exit",
        "kind": 5,
        "importPath": "qemu.build.scripts.userfaultfd-wrlat",
        "description": "qemu.build.scripts.userfaultfd-wrlat",
        "peekOfCode": "do_exit = 0\nwhile (1):\n    if count > 0:\n        loop += 1\n        if loop > count:\n            exit()\n    try:\n        sleep(interval)\n    except KeyboardInterrupt:\n        pass; do_exit = 1",
        "detail": "qemu.build.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "bump_taint",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def bump_taint():\n    global taint\n    # Ensure we don't wrap around or reset to 0 -- the shell only has\n    # an 8-bit return value.\n    if taint < 255:\n        taint = taint + 1\ndef check_fields_match(name, s_field, d_field):\n    if s_field == d_field:\n        return True\n    # Some fields changed names between qemu versions.  This list",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_fields_match",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_fields_match(name, s_field, d_field):\n    if s_field == d_field:\n        return True\n    # Some fields changed names between qemu versions.  This list\n    # is used to allow such changes in each section / description.\n    changed_names = {\n        'apic': ['timer', 'timer_expiry'],\n        'e1000': ['dev', 'parent_obj'],\n        'ehci': ['dev', 'pcidev'],\n        'I440FX': ['dev', 'parent_obj'],",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "get_changed_sec_name",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def get_changed_sec_name(sec):\n    # Section names can change -- see commit 292b1634 for an example.\n    changes = {\n        \"ICH9 LPC\": \"ICH9-LPC\",\n        \"e1000-82540em\": \"e1000\",\n    }\n    for item in changes:\n        if item == sec:\n            return changes[item]\n        if changes[item] == sec:",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "exists_in_substruct",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def exists_in_substruct(fields, item):\n    # Some QEMU versions moved a few fields inside a substruct.  This\n    # kept the on-wire format the same.  This function checks if\n    # something got shifted inside a substruct.  For example, the\n    # change in commit 1f42d22233b4f3d1a2933ff30e8d6a6d9ee2d08f\n    if not \"Description\" in fields:\n        return False\n    if not \"Fields\" in fields[\"Description\"]:\n        return False\n    substruct_fields = fields[\"Description\"][\"Fields\"]",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "size_total",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def size_total(entry):\n    size = entry[\"size\"]\n    if \"num\" not in entry:\n        return size\n    return size * entry[\"num\"]\ndef check_fields(src_fields, dest_fields, desc, sec):\n    # This function checks for all the fields in a section.  If some\n    # fields got embedded into a substruct, this function will also\n    # attempt to check inside the substruct.\n    d_iter = iter(dest_fields)",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_fields",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_fields(src_fields, dest_fields, desc, sec):\n    # This function checks for all the fields in a section.  If some\n    # fields got embedded into a substruct, this function will also\n    # attempt to check inside the substruct.\n    d_iter = iter(dest_fields)\n    s_iter = iter(src_fields)\n    # Using these lists as stacks to store previous value of s_iter\n    # and d_iter, so that when time comes to exit out of a substruct,\n    # we can go back one level up and continue from where we left off.\n    s_iter_list = []",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_subsections",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_subsections(src_sub, dest_sub, desc, sec):\n    for s_item in src_sub:\n        found = False\n        for d_item in dest_sub:\n            if s_item[\"name\"] != d_item[\"name\"]:\n                continue\n            found = True\n            check_descriptions(s_item, d_item, sec)\n        if not found:\n            print(\"Section \\\"\" + sec + \"\\\", Description \\\"\" + desc + \"\\\":\", end=' ')",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_description_in_list",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_description_in_list(s_item, d_item, sec, desc):\n    if not \"Description\" in s_item:\n        return\n    if not \"Description\" in d_item:\n        print(\"Section \\\"\" + sec + \"\\\", Description \\\"\" + desc + \"\\\",\", end=' ')\n        print(\"Field \\\"\" + s_item[\"field\"] + \"\\\": missing description\")\n        bump_taint()\n        return\n    check_descriptions(s_item[\"Description\"], d_item[\"Description\"], sec)\ndef check_descriptions(src_desc, dest_desc, sec):",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_descriptions",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_descriptions(src_desc, dest_desc, sec):\n    check_version(src_desc, dest_desc, sec, src_desc[\"name\"])\n    if not check_fields_match(sec, src_desc[\"name\"], dest_desc[\"name\"]):\n        print(\"Section \\\"\" + sec + \"\\\":\", end=' ')\n        print(\"Description \\\"\" + src_desc[\"name\"] + \"\\\"\", end=' ')\n        print(\"missing, got \\\"\" + dest_desc[\"name\"] + \"\\\" instead; skipping\")\n        bump_taint()\n        return\n    for f in src_desc:\n        if not f in dest_desc:",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_version",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_version(s, d, sec, desc=None):\n    if s[\"version_id\"] > d[\"version_id\"]:\n        print(\"Section \\\"\" + sec + \"\\\"\", end=' ')\n        if desc:\n            print(\"Description \\\"\" + desc + \"\\\":\", end=' ')\n        print(\"version error:\", s[\"version_id\"], \">\", d[\"version_id\"])\n        bump_taint()\n    if not \"minimum_version_id\" in d:\n        return\n    if s[\"version_id\"] < d[\"minimum_version_id\"]:",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_size",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_size(s, d, sec, desc=None, field=None):\n    if s[\"size\"] != d[\"size\"]:\n        print(\"Section \\\"\" + sec + \"\\\"\", end=' ')\n        if desc:\n            print(\"Description \\\"\" + desc + \"\\\"\", end=' ')\n        if field:\n            print(\"Field \\\"\" + field + \"\\\"\", end=' ')\n        print(\"size mismatch:\", s[\"size\"], \",\", d[\"size\"])\n        bump_taint()\ndef check_machine_type(s, d):",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_machine_type",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def check_machine_type(s, d):\n    if s[\"Name\"] != d[\"Name\"]:\n        print(\"Warning: checking incompatible machine types:\", end=' ')\n        print(\"\\\"\" + s[\"Name\"] + \"\\\", \\\"\" + d[\"Name\"] + \"\\\"\")\ndef main():\n    help_text = \"Parse JSON-formatted vmstate dumps from QEMU in files SRC and DEST.  Checks whether migration from SRC to DEST QEMU versions would break based on the VMSTATE information contained within the JSON outputs.  The JSON output is created from a QEMU invocation with the -dump-vmstate parameter and a filename argument to it.  Other parameters to QEMU do not matter, except the -M (machine type) parameter.\"\n    parser = argparse.ArgumentParser(description=help_text)\n    parser.add_argument('-s', '--src', type=argparse.FileType('r'),\n                        required=True,\n                        help='json dump from src qemu')",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "def main():\n    help_text = \"Parse JSON-formatted vmstate dumps from QEMU in files SRC and DEST.  Checks whether migration from SRC to DEST QEMU versions would break based on the VMSTATE information contained within the JSON outputs.  The JSON output is created from a QEMU invocation with the -dump-vmstate parameter and a filename argument to it.  Other parameters to QEMU do not matter, except the -M (machine type) parameter.\"\n    parser = argparse.ArgumentParser(description=help_text)\n    parser.add_argument('-s', '--src', type=argparse.FileType('r'),\n                        required=True,\n                        help='json dump from src qemu')\n    parser.add_argument('-d', '--dest', type=argparse.FileType('r'),\n                        required=True,\n                        help='json dump from dest qemu')\n    parser.add_argument('--reverse', required=False, default=False,",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "taint",
        "kind": 5,
        "importPath": "qemu.build.scripts.vmstate-static-checker",
        "description": "qemu.build.scripts.vmstate-static-checker",
        "peekOfCode": "taint = 0\ndef bump_taint():\n    global taint\n    # Ensure we don't wrap around or reset to 0 -- the shell only has\n    # an 8-bit return value.\n    if taint < 255:\n        taint = taint + 1\ndef check_fields_match(name, s_field, d_field):\n    if s_field == d_field:\n        return True",
        "detail": "qemu.build.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "TestXmlPreprocess",
        "kind": 6,
        "importPath": "qemu.build.scripts.xml-preprocess-test",
        "description": "qemu.build.scripts.xml-preprocess-test",
        "peekOfCode": "class TestXmlPreprocess(unittest.TestCase):\n    \"\"\"Tests for xml-preprocess.Preprocessor\"\"\"\n    def test_preprocess_xml(self):\n        with tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as temp_file:\n            temp_file.write(\"<root></root>\")\n            temp_file_name = temp_file.name\n        result = xmlpp.preprocess_xml(temp_file_name)\n        self.assertEqual(result, \"<root></root>\")\n        os.remove(temp_file_name)\n    def test_save_xml(self):",
        "detail": "qemu.build.scripts.xml-preprocess-test",
        "documentation": {}
    },
    {
        "label": "xmlpp",
        "kind": 5,
        "importPath": "qemu.build.scripts.xml-preprocess-test",
        "description": "qemu.build.scripts.xml-preprocess-test",
        "peekOfCode": "xmlpp = importlib.import_module(\"xml-preprocess\")\nclass TestXmlPreprocess(unittest.TestCase):\n    \"\"\"Tests for xml-preprocess.Preprocessor\"\"\"\n    def test_preprocess_xml(self):\n        with tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as temp_file:\n            temp_file.write(\"<root></root>\")\n            temp_file_name = temp_file.name\n        result = xmlpp.preprocess_xml(temp_file_name)\n        self.assertEqual(result, \"<root></root>\")\n        os.remove(temp_file_name)",
        "detail": "qemu.build.scripts.xml-preprocess-test",
        "documentation": {}
    },
    {
        "label": "Preprocessor",
        "kind": 6,
        "importPath": "qemu.build.scripts.xml-preprocess",
        "description": "qemu.build.scripts.xml-preprocess",
        "peekOfCode": "class Preprocessor():\n    \"\"\"This class holds the XML preprocessing state\"\"\"\n    def __init__(self):\n        self.sys_vars = {\n            \"ARCH\": platform.architecture()[0],\n            \"SOURCE\": os.path.abspath(__file__),\n            \"CURRENT\": os.getcwd(),\n        }\n        self.cus_vars = {}\n    def _pp_include(self, xml_str: str) -> str:",
        "detail": "qemu.build.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "preprocess_xml",
        "kind": 2,
        "importPath": "qemu.build.scripts.xml-preprocess",
        "description": "qemu.build.scripts.xml-preprocess",
        "peekOfCode": "def preprocess_xml(path: str) -> str:\n    with open(path, \"r\", encoding=\"utf-8\") as original_file:\n        input_xml = original_file.read()\n        proc = Preprocessor()\n        return proc.preprocess(input_xml)\ndef save_xml(xml_str: str, path: Optional[str]):\n    xml = minidom.parseString(xml_str)\n    with open(path, \"w\", encoding=\"utf-8\") if path else sys.stdout as output_file:\n        output_file.write(xml.toprettyxml())\ndef main():",
        "detail": "qemu.build.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "save_xml",
        "kind": 2,
        "importPath": "qemu.build.scripts.xml-preprocess",
        "description": "qemu.build.scripts.xml-preprocess",
        "peekOfCode": "def save_xml(xml_str: str, path: Optional[str]):\n    xml = minidom.parseString(xml_str)\n    with open(path, \"w\", encoding=\"utf-8\") if path else sys.stdout as output_file:\n        output_file.write(xml.toprettyxml())\ndef main():\n    if len(sys.argv) < 2:\n        print(\"Usage: xml-preprocessor input.xml [output.xml]\")\n        sys.exit(1)\n    output_file = None\n    if len(sys.argv) == 3:",
        "detail": "qemu.build.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.build.scripts.xml-preprocess",
        "description": "qemu.build.scripts.xml-preprocess",
        "peekOfCode": "def main():\n    if len(sys.argv) < 2:\n        print(\"Usage: xml-preprocessor input.xml [output.xml]\")\n        sys.exit(1)\n    output_file = None\n    if len(sys.argv) == 3:\n        output_file = sys.argv[2]\n    input_file = sys.argv[1]\n    output_xml = preprocess_xml(input_file)\n    save_xml(output_xml, output_file)",
        "detail": "qemu.build.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "CompatField",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "class CompatField(docfields.Field):\n    if MAKE_XREF_WORKAROUND:\n        make_xref = _compat_make_xref\nclass CompatGroupedField(docfields.GroupedField):\n    if MAKE_XREF_WORKAROUND:\n        make_xref = _compat_make_xref\nclass CompatTypedField(docfields.TypedField):\n    if MAKE_XREF_WORKAROUND:\n        make_xref = _compat_make_xref\n# ################################################################",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "CompatGroupedField",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "class CompatGroupedField(docfields.GroupedField):\n    if MAKE_XREF_WORKAROUND:\n        make_xref = _compat_make_xref\nclass CompatTypedField(docfields.TypedField):\n    if MAKE_XREF_WORKAROUND:\n        make_xref = _compat_make_xref\n# ################################################################\n# Nested parsing error location fix for Sphinx 5.3.0 < x < 6.2.0 #\n# ################################################################\n# When we require Sphinx 4.x, the TYPE_CHECKING hack where we avoid",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "CompatTypedField",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "class CompatTypedField(docfields.TypedField):\n    if MAKE_XREF_WORKAROUND:\n        make_xref = _compat_make_xref\n# ################################################################\n# Nested parsing error location fix for Sphinx 5.3.0 < x < 6.2.0 #\n# ################################################################\n# When we require Sphinx 4.x, the TYPE_CHECKING hack where we avoid\n# subscripting ObjectDescription at runtime can be removed in favor of\n# just always subscripting the class.\n# When we require Sphinx > 6.2.0, the rest of this compatibility hack",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "ParserFix",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "class ParserFix(_BaseClass):\n    _temp_content: StringList\n    _temp_offset: int\n    _temp_node: Optional[addnodes.desc_content]\n    def before_content(self) -> None:\n        # Work around a sphinx bug and parse the content ourselves.\n        self._temp_content = self.content\n        self._temp_offset = self.content_offset\n        self._temp_node = None\n        if SOURCE_LOCATION_FIX:",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "nested_parse_with_titles",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "def nested_parse_with_titles(\n    directive: SphinxDirective, content_node: Element\n) -> None:\n    \"\"\"\n    This helper preserves error parsing context across sphinx versions.\n    \"\"\"\n    # necessary so that the child nodes get the right source/line set\n    content_node.document = directive.state.document\n    try:\n        # Modern sphinx (6.2.0+) supports proper offsetting for",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "MAKE_XREF_WORKAROUND",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "MAKE_XREF_WORKAROUND = sphinx.version_info[:3] < (4, 1, 0)\nSpaceNode: Callable[[str], Node]\nKeywordNode: Callable[[str, str], Node]\nif sphinx.version_info[:3] >= (4, 0, 0):\n    SpaceNode = addnodes.desc_sig_space\n    KeywordNode = addnodes.desc_sig_keyword\nelse:\n    SpaceNode = Text\n    KeywordNode = addnodes.desc_annotation\ndef nested_parse_with_titles(",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "SOURCE_LOCATION_FIX",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "SOURCE_LOCATION_FIX = (5, 3, 0) <= sphinx.version_info[:3] < (6, 2, 0)\nSignature = str\nif TYPE_CHECKING:\n    _BaseClass = ObjectDescription[Signature]\nelse:\n    _BaseClass = ObjectDescription\nclass ParserFix(_BaseClass):\n    _temp_content: StringList\n    _temp_offset: int\n    _temp_node: Optional[addnodes.desc_content]",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "Signature",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.compat",
        "description": "qemu.docs.sphinx.compat",
        "peekOfCode": "Signature = str\nif TYPE_CHECKING:\n    _BaseClass = ObjectDescription[Signature]\nelse:\n    _BaseClass = ObjectDescription\nclass ParserFix(_BaseClass):\n    _temp_content: StringList\n    _temp_offset: int\n    _temp_node: Optional[addnodes.desc_content]\n    def before_content(self) -> None:",
        "detail": "qemu.docs.sphinx.compat",
        "documentation": {}
    },
    {
        "label": "DBusDoc",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdoc",
        "description": "qemu.docs.sphinx.dbusdoc",
        "peekOfCode": "class DBusDoc:\n    def __init__(self, sphinx_directive, dbusfile):\n        self._cur_doc = None\n        self._sphinx_directive = sphinx_directive\n        self._dbusfile = dbusfile\n        self._top_node = nodes.section()\n        self.result = StringList()\n        self.indent = \"\"\n    def add_line(self, line: str, *lineno: int) -> None:\n        \"\"\"Append one line of generated reST to the output.\"\"\"",
        "detail": "qemu.docs.sphinx.dbusdoc",
        "documentation": {}
    },
    {
        "label": "DBusDocDirective",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdoc",
        "description": "qemu.docs.sphinx.dbusdoc",
        "peekOfCode": "class DBusDocDirective(SphinxDirective):\n    \"\"\"Extract documentation from the specified D-Bus XML file\"\"\"\n    has_content = True\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n    def run(self):\n        reporter = self.state.document.reporter\n        try:\n            source, lineno = reporter.get_source_and_line(self.lineno)  # type: ignore",
        "detail": "qemu.docs.sphinx.dbusdoc",
        "documentation": {}
    },
    {
        "label": "parse_generated_content",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.dbusdoc",
        "description": "qemu.docs.sphinx.dbusdoc",
        "peekOfCode": "def parse_generated_content(state: RSTState, content: StringList) -> List[Node]:\n    \"\"\"Parse a generated content by Documenter.\"\"\"\n    with switch_source_input(state, content):\n        node = nodes.paragraph()\n        node.document = state.document\n        state.nested_parse(content, 0, node)\n        return node.children\nclass DBusDocDirective(SphinxDirective):\n    \"\"\"Extract documentation from the specified D-Bus XML file\"\"\"\n    has_content = True",
        "detail": "qemu.docs.sphinx.dbusdoc",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.dbusdoc",
        "description": "qemu.docs.sphinx.dbusdoc",
        "peekOfCode": "def setup(app: Sphinx) -> Dict[str, Any]:\n    \"\"\"Register dbus-doc directive with Sphinx\"\"\"\n    app.add_config_value(\"dbusdoc_srctree\", None, \"env\")\n    app.add_directive(\"dbus-doc\", DBusDocDirective)\n    dbusdomain.setup(app)\n    return dict(version=__version__, parallel_read_safe=True, parallel_write_safe=True)",
        "detail": "qemu.docs.sphinx.dbusdoc",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.dbusdoc",
        "description": "qemu.docs.sphinx.dbusdoc",
        "peekOfCode": "logger = logging.getLogger(__name__)\n__version__ = \"1.0\"\nclass DBusDoc:\n    def __init__(self, sphinx_directive, dbusfile):\n        self._cur_doc = None\n        self._sphinx_directive = sphinx_directive\n        self._dbusfile = dbusfile\n        self._top_node = nodes.section()\n        self.result = StringList()\n        self.indent = \"\"",
        "detail": "qemu.docs.sphinx.dbusdoc",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.dbusdoc",
        "description": "qemu.docs.sphinx.dbusdoc",
        "peekOfCode": "__version__ = \"1.0\"\nclass DBusDoc:\n    def __init__(self, sphinx_directive, dbusfile):\n        self._cur_doc = None\n        self._sphinx_directive = sphinx_directive\n        self._dbusfile = dbusfile\n        self._top_node = nodes.section()\n        self.result = StringList()\n        self.indent = \"\"\n    def add_line(self, line: str, *lineno: int) -> None:",
        "detail": "qemu.docs.sphinx.dbusdoc",
        "documentation": {}
    },
    {
        "label": "DBusDescription",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusDescription(ObjectDescription[str]):\n    \"\"\"Base class for DBus objects\"\"\"\n    option_spec: OptionSpec = ObjectDescription.option_spec.copy()\n    option_spec.update(\n        {\n            \"deprecated\": directives.flag,\n        }\n    )\n    def get_index_text(self, modname: str, name: str) -> str:\n        \"\"\"Return the text for the index entry of the object.\"\"\"",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusInterface",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusInterface(DBusDescription):\n    \"\"\"\n    Implementation of ``dbus:interface``.\n    \"\"\"\n    def get_index_text(self, ifacename: str, name: str) -> str:\n        return ifacename\n    def before_content(self) -> None:\n        self.env.ref_context[\"dbus:interface\"] = self.arguments[0]\n    def after_content(self) -> None:\n        self.env.ref_context.pop(\"dbus:interface\")",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusMember",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusMember(DBusDescription):\n    signal = False\nclass DBusMethod(DBusMember):\n    \"\"\"\n    Implementation of ``dbus:method``.\n    \"\"\"\n    option_spec: OptionSpec = DBusMember.option_spec.copy()\n    option_spec.update(\n        {\n            \"noreply\": directives.flag,",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusMethod",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusMethod(DBusMember):\n    \"\"\"\n    Implementation of ``dbus:method``.\n    \"\"\"\n    option_spec: OptionSpec = DBusMember.option_spec.copy()\n    option_spec.update(\n        {\n            \"noreply\": directives.flag,\n        }\n    )",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusSignal",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusSignal(DBusMethod):\n    \"\"\"\n    Implementation of ``dbus:signal``.\n    \"\"\"\n    doc_field_types: List[Field] = [\n        TypedField(\n            \"arg\",\n            label=_(\"Arguments\"),\n            names=(\"arg\",),\n            rolename=\"arg\",",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusProperty",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusProperty(DBusMember):\n    \"\"\"\n    Implementation of ``dbus:property``.\n    \"\"\"\n    option_spec: OptionSpec = DBusMember.option_spec.copy()\n    option_spec.update(\n        {\n            \"type\": directives.unchanged,\n            \"readonly\": directives.flag,\n            \"writeonly\": directives.flag,",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusXRef",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusXRef(XRefRole):\n    def process_link(self, env, refnode, has_explicit_title, title, target):\n        refnode[\"dbus:interface\"] = env.ref_context.get(\"dbus:interface\")\n        if not has_explicit_title:\n            title = title.lstrip(\".\")  # only has a meaning for the target\n            target = target.lstrip(\"~\")  # only has a meaning for the title\n            # if the first character is a tilde, don't display the module/class\n            # parts of the contents\n            if title[0:1] == \"~\":\n                title = title[1:]",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusIndex",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusIndex(Index):\n    \"\"\"\n    Index subclass to provide a D-Bus interfaces index.\n    \"\"\"\n    name = \"dbusindex\"\n    localname = _(\"D-Bus Interfaces Index\")\n    shortname = _(\"dbus\")\n    def generate(\n        self, docnames: Iterable[str] = None\n    ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "ObjectEntry",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class ObjectEntry(NamedTuple):\n    docname: str\n    node_id: str\n    objtype: str\nclass DBusDomain(Domain):\n    \"\"\"\n    Implementation of the D-Bus domain.\n    \"\"\"\n    name = \"dbus\"\n    label = \"D-Bus\"",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "DBusDomain",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "class DBusDomain(Domain):\n    \"\"\"\n    Implementation of the D-Bus domain.\n    \"\"\"\n    name = \"dbus\"\n    label = \"D-Bus\"\n    object_types: Dict[str, ObjType] = {\n        \"interface\": ObjType(_(\"interface\"), \"iface\", \"obj\"),\n        \"method\": ObjType(_(\"method\"), \"meth\", \"obj\"),\n        \"signal\": ObjType(_(\"signal\"), \"sig\", \"obj\"),",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.dbusdomain",
        "description": "qemu.docs.sphinx.dbusdomain",
        "peekOfCode": "def setup(app):\n    app.add_domain(DBusDomain)\n    app.add_config_value(\"dbus_index_common_prefix\", [], \"env\")",
        "detail": "qemu.docs.sphinx.dbusdomain",
        "documentation": {}
    },
    {
        "label": "Annotation",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "class Annotation:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.annotations = []\n        self.since = \"\"\nclass Arg:\n    def __init__(self, name, signature):\n        self.name = name\n        self.signature = signature",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "Arg",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "class Arg:\n    def __init__(self, name, signature):\n        self.name = name\n        self.signature = signature\n        self.annotations = []\n        self.doc_string = \"\"\n        self.since = \"\"\nclass Method:\n    def __init__(self, name, h_type_implies_unix_fd=True):\n        self.name = name",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "Method",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "class Method:\n    def __init__(self, name, h_type_implies_unix_fd=True):\n        self.name = name\n        self.h_type_implies_unix_fd = h_type_implies_unix_fd\n        self.in_args = []\n        self.out_args = []\n        self.annotations = []\n        self.doc_string = \"\"\n        self.since = \"\"\n        self.deprecated = False",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "Signal",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "class Signal:\n    def __init__(self, name):\n        self.name = name\n        self.args = []\n        self.annotations = []\n        self.doc_string = \"\"\n        self.since = \"\"\n        self.deprecated = False\nclass Property:\n    def __init__(self, name, signature, access):",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "Property",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "class Property:\n    def __init__(self, name, signature, access):\n        self.name = name\n        self.signature = signature\n        self.access = access\n        self.annotations = []\n        self.arg = Arg(\"value\", self.signature)\n        self.arg.annotations = self.annotations\n        self.readable = False\n        self.writable = False",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "Interface",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "class Interface:\n    def __init__(self, name):\n        self.name = name\n        self.methods = []\n        self.signals = []\n        self.properties = []\n        self.annotations = []\n        self.doc_string = \"\"\n        self.doc_string_brief = \"\"\n        self.since = \"\"",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "DBusXMLParser",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "class DBusXMLParser:\n    STATE_TOP = \"top\"\n    STATE_NODE = \"node\"\n    STATE_INTERFACE = \"interface\"\n    STATE_METHOD = \"method\"\n    STATE_SIGNAL = \"signal\"\n    STATE_PROPERTY = \"property\"\n    STATE_ARG = \"arg\"\n    STATE_ANNOTATION = \"annotation\"\n    STATE_IGNORED = \"ignored\"",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "parse_dbus_xml",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.dbusparser",
        "description": "qemu.docs.sphinx.dbusparser",
        "peekOfCode": "def parse_dbus_xml(xml_data):\n    parser = DBusXMLParser(xml_data, True)\n    return parser.parsed_interfaces",
        "detail": "qemu.docs.sphinx.dbusparser",
        "documentation": {}
    },
    {
        "label": "get_infiles",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.depfile",
        "description": "qemu.docs.sphinx.depfile",
        "peekOfCode": "def get_infiles(env):\n    for x in env.found_docs:\n        yield str(env.doc2path(x))\n        yield from ((os.path.join(env.srcdir, dep)\n                    for dep in env.dependencies[x]))\n    for mod in sys.modules.values():\n        if hasattr(mod, '__file__'):\n            if mod.__file__:\n                yield mod.__file__\n    # this is perhaps going to include unused files:",
        "detail": "qemu.docs.sphinx.depfile",
        "documentation": {}
    },
    {
        "label": "write_depfile",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.depfile",
        "description": "qemu.docs.sphinx.depfile",
        "peekOfCode": "def write_depfile(app, exception):\n    if exception:\n        return\n    env = app.env\n    if not env.config.depfile:\n        return\n    # Using a directory as the output file does not work great because\n    # its timestamp does not necessarily change when the contents change.\n    # So create a timestamp file.\n    if env.config.depfile_stamp:",
        "detail": "qemu.docs.sphinx.depfile",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.depfile",
        "description": "qemu.docs.sphinx.depfile",
        "peekOfCode": "def setup(app):\n    app.add_config_value('depfile', None, 'env')\n    app.add_config_value('depfile_stamp', None, 'env')\n    app.connect('build-finished', write_depfile)\n    return dict(\n        version = __version__,\n        parallel_read_safe = True,\n        parallel_write_safe = True\n    )",
        "detail": "qemu.docs.sphinx.depfile",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.depfile",
        "description": "qemu.docs.sphinx.depfile",
        "peekOfCode": "__version__ = '1.0'\ndef get_infiles(env):\n    for x in env.found_docs:\n        yield str(env.doc2path(x))\n        yield from ((os.path.join(env.srcdir, dep)\n                    for dep in env.dependencies[x]))\n    for mod in sys.modules.values():\n        if hasattr(mod, '__file__'):\n            if mod.__file__:\n                yield mod.__file__",
        "detail": "qemu.docs.sphinx.depfile",
        "documentation": {}
    },
    {
        "label": "FakeDBusDocDirective",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.fakedbusdoc",
        "description": "qemu.docs.sphinx.fakedbusdoc",
        "peekOfCode": "class FakeDBusDocDirective(Directive):\n    has_content = True\n    required_arguments = 1\n    def run(self):\n        return []\ndef setup(app: Sphinx) -> Dict[str, Any]:\n    \"\"\"Register a fake dbus-doc directive with Sphinx\"\"\"\n    app.add_directive(\"dbus-doc\", FakeDBusDocDirective)\n    return dict(\n        parallel_read_safe = True,",
        "detail": "qemu.docs.sphinx.fakedbusdoc",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.fakedbusdoc",
        "description": "qemu.docs.sphinx.fakedbusdoc",
        "peekOfCode": "def setup(app: Sphinx) -> Dict[str, Any]:\n    \"\"\"Register a fake dbus-doc directive with Sphinx\"\"\"\n    app.add_directive(\"dbus-doc\", FakeDBusDocDirective)\n    return dict(\n        parallel_read_safe = True,\n        parallel_write_safe = True\n    )",
        "detail": "qemu.docs.sphinx.fakedbusdoc",
        "documentation": {}
    },
    {
        "label": "HxState",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "class HxState(Enum):\n    CTEXT = 1\n    RST = 2\ndef serror(file, lnum, errtext):\n    \"\"\"Raise an exception giving a user-friendly syntax error message\"\"\"\n    raise ExtensionError('%s line %d: syntax error: %s' % (file, lnum, errtext))\ndef parse_directive(line):\n    \"\"\"Return first word of line, if any\"\"\"\n    return re.split(r'\\W', line)[0]\ndef parse_defheading(file, lnum, line):",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "HxtoolDocDirective",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "class HxtoolDocDirective(Directive):\n    \"\"\"Extract rST fragments from the specified .hx file\"\"\"\n    required_argument = 1\n    optional_arguments = 1\n    option_spec = {\n        'hxfile': directives.unchanged_required\n    }\n    has_content = False\n    def run(self):\n        env = self.state.document.settings.env",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "serror",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "def serror(file, lnum, errtext):\n    \"\"\"Raise an exception giving a user-friendly syntax error message\"\"\"\n    raise ExtensionError('%s line %d: syntax error: %s' % (file, lnum, errtext))\ndef parse_directive(line):\n    \"\"\"Return first word of line, if any\"\"\"\n    return re.split(r'\\W', line)[0]\ndef parse_defheading(file, lnum, line):\n    \"\"\"Handle a DEFHEADING directive\"\"\"\n    # The input should be \"DEFHEADING(some string)\", though note that\n    # the 'some string' could be the empty string. If the string is",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "parse_directive",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "def parse_directive(line):\n    \"\"\"Return first word of line, if any\"\"\"\n    return re.split(r'\\W', line)[0]\ndef parse_defheading(file, lnum, line):\n    \"\"\"Handle a DEFHEADING directive\"\"\"\n    # The input should be \"DEFHEADING(some string)\", though note that\n    # the 'some string' could be the empty string. If the string is\n    # empty we ignore the directive -- these are used only to add\n    # blank lines in the plain-text content of the --help output.\n    #",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "parse_defheading",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "def parse_defheading(file, lnum, line):\n    \"\"\"Handle a DEFHEADING directive\"\"\"\n    # The input should be \"DEFHEADING(some string)\", though note that\n    # the 'some string' could be the empty string. If the string is\n    # empty we ignore the directive -- these are used only to add\n    # blank lines in the plain-text content of the --help output.\n    #\n    # Return the heading text. We strip out any trailing ':' for\n    # consistency with other headings in the rST documentation.\n    match = re.match(r'DEFHEADING\\((.*?):?\\)', line)",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "parse_archheading",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "def parse_archheading(file, lnum, line):\n    \"\"\"Handle an ARCHHEADING directive\"\"\"\n    # The input should be \"ARCHHEADING(some string, other arg)\",\n    # though note that the 'some string' could be the empty string.\n    # As with DEFHEADING, empty string ARCHHEADINGs will be ignored.\n    #\n    # Return the heading text. We strip out any trailing ':' for\n    # consistency with other headings in the rST documentation.\n    match = re.match(r'ARCHHEADING\\((.*?):?,.*\\)', line)\n    if match is None:",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "parse_srst",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "def parse_srst(file, lnum, line):\n    \"\"\"Handle an SRST directive\"\"\"\n    # The input should be either \"SRST\", or \"SRST(label)\".\n    match = re.match(r'SRST(\\((.*?)\\))?', line)\n    if match is None:\n        serror(file, lnum, \"Invalid SRST line\")\n    return match.group(2)\nclass HxtoolDocDirective(Directive):\n    \"\"\"Extract rST fragments from the specified .hx file\"\"\"\n    required_argument = 1",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "def setup(app):\n    \"\"\" Register hxtool-doc directive with Sphinx\"\"\"\n    app.add_config_value('hxtool_srctree', None, 'env')\n    app.add_directive('hxtool-doc', HxtoolDocDirective)\n    return dict(\n        version = __version__,\n        parallel_read_safe = True,\n        parallel_write_safe = True\n    )",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.hxtool",
        "description": "qemu.docs.sphinx.hxtool",
        "peekOfCode": "__version__ = '1.0'\n# We parse hx files with a state machine which may be in one of two\n# states: reading the C code fragment, or inside a rST fragment.\nclass HxState(Enum):\n    CTEXT = 1\n    RST = 2\ndef serror(file, lnum, errtext):\n    \"\"\"Raise an exception giving a user-friendly syntax error message\"\"\"\n    raise ExtensionError('%s line %d: syntax error: %s' % (file, lnum, errtext))\ndef parse_directive(line):",
        "detail": "qemu.docs.sphinx.hxtool",
        "documentation": {}
    },
    {
        "label": "KernelDocDirective",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.kerneldoc",
        "description": "qemu.docs.sphinx.kerneldoc",
        "peekOfCode": "class KernelDocDirective(Directive):\n    \"\"\"Extract kernel-doc comments from the specified file\"\"\"\n    required_argument = 1\n    optional_arguments = 4\n    option_spec = {\n        'doc': directives.unchanged_required,\n        'functions': directives.unchanged,\n        'export': directives.unchanged,\n        'internal': directives.unchanged,\n    }",
        "detail": "qemu.docs.sphinx.kerneldoc",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.kerneldoc",
        "description": "qemu.docs.sphinx.kerneldoc",
        "peekOfCode": "def setup(app):\n    app.add_config_value('kerneldoc_bin', None, 'env')\n    app.add_config_value('kerneldoc_srctree', None, 'env')\n    app.add_config_value('kerneldoc_verbosity', 1, 'env')\n    app.add_config_value('kerneldoc_werror', 0, 'env')\n    app.add_directive('kernel-doc', KernelDocDirective)\n    return dict(\n        version = __version__,\n        parallel_read_safe = True,\n        parallel_write_safe = True",
        "detail": "qemu.docs.sphinx.kerneldoc",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.kerneldoc",
        "description": "qemu.docs.sphinx.kerneldoc",
        "peekOfCode": "logger = logging.getLogger('kerneldoc')\nclass KernelDocDirective(Directive):\n    \"\"\"Extract kernel-doc comments from the specified file\"\"\"\n    required_argument = 1\n    optional_arguments = 4\n    option_spec = {\n        'doc': directives.unchanged_required,\n        'functions': directives.unchanged,\n        'export': directives.unchanged,\n        'internal': directives.unchanged,",
        "detail": "qemu.docs.sphinx.kerneldoc",
        "documentation": {}
    },
    {
        "label": "ObjectEntry",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class ObjectEntry(NamedTuple):\n    docname: str\n    node_id: str\n    objtype: str\n    aliased: bool\nclass QAPIXRefRole(XRefRole):\n    def process_link(\n        self,\n        env: BuildEnvironment,\n        refnode: Element,",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIXRefRole",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIXRefRole(XRefRole):\n    def process_link(\n        self,\n        env: BuildEnvironment,\n        refnode: Element,\n        has_explicit_title: bool,\n        title: str,\n        target: str,\n    ) -> tuple[str, str]:\n        refnode[\"qapi:namespace\"] = env.ref_context.get(\"qapi:namespace\")",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIDescription",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIDescription(ParserFix):\n    \"\"\"\n    Generic QAPI description.\n    This is meant to be an abstract class, not instantiated\n    directly. This class handles the abstract details of indexing, the\n    TOC, and reference targets for QAPI descriptions.\n    \"\"\"\n    def handle_signature(self, sig: str, signode: desc_signature) -> Signature:\n        # Do nothing. The return value here is the \"name\" of the entity\n        # being documented; for QAPI, this is the same as the",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIObject",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIObject(QAPIDescription):\n    \"\"\"\n    Description of a generic QAPI object.\n    It's not used directly, but is instead subclassed by specific directives.\n    \"\"\"\n    # Inherit some standard options from Sphinx's ObjectDescription\n    option_spec: OptionSpec = (  # type:ignore[misc]\n        ObjectDescription.option_spec.copy()\n    )\n    option_spec.update(",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "SpecialTypedField",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class SpecialTypedField(CompatTypedField):\n    def make_field(self, *args: Any, **kwargs: Any) -> nodes.field:\n        ret = super().make_field(*args, **kwargs)\n        # Look for the characteristic \" -- \" text node that Sphinx\n        # inserts for each TypedField entry ...\n        for node in ret.traverse(lambda n: str(n) == \" -- \"):\n            par = node.parent\n            if par.children[0].astext() != \"q_dummy\":\n                continue\n            # If the first node's text is q_dummy, this is a dummy",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPICommand",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPICommand(QAPIObject):\n    \"\"\"Description of a QAPI Command.\"\"\"\n    doc_field_types = QAPIObject.doc_field_types.copy()\n    doc_field_types.extend(\n        [\n            # :arg TypeName ArgName: descr\n            SpecialTypedField(\n                \"argument\",\n                label=_(\"Arguments\"),\n                names=(\"arg\",),",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIEnum",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIEnum(QAPIObject):\n    \"\"\"Description of a QAPI Enum.\"\"\"\n    doc_field_types = QAPIObject.doc_field_types.copy()\n    doc_field_types.extend(\n        [\n            # :value name: descr\n            CompatGroupedField(\n                \"value\",\n                label=_(\"Values\"),\n                names=(\"value\",),",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIAlternate",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIAlternate(QAPIObject):\n    \"\"\"Description of a QAPI Alternate.\"\"\"\n    doc_field_types = QAPIObject.doc_field_types.copy()\n    doc_field_types.extend(\n        [\n            # :alt type name: descr\n            CompatTypedField(\n                \"alternative\",\n                label=_(\"Alternatives\"),\n                names=(\"alt\",),",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIObjectWithMembers",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIObjectWithMembers(QAPIObject):\n    \"\"\"Base class for Events/Structs/Unions\"\"\"\n    doc_field_types = QAPIObject.doc_field_types.copy()\n    doc_field_types.extend(\n        [\n            # :member type name: descr\n            SpecialTypedField(\n                \"member\",\n                label=_(\"Members\"),\n                names=(\"memb\",),",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIEvent",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIEvent(QAPIObjectWithMembers):\n    # pylint: disable=too-many-ancestors\n    \"\"\"Description of a QAPI Event.\"\"\"\nclass QAPIJSONObject(QAPIObjectWithMembers):\n    # pylint: disable=too-many-ancestors\n    \"\"\"Description of a QAPI Object: structs and unions.\"\"\"\nclass QAPIModule(QAPIDescription):\n    \"\"\"\n    Directive to mark description of a new module.\n    This directive doesn't generate any special formatting, and is just",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIJSONObject",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIJSONObject(QAPIObjectWithMembers):\n    # pylint: disable=too-many-ancestors\n    \"\"\"Description of a QAPI Object: structs and unions.\"\"\"\nclass QAPIModule(QAPIDescription):\n    \"\"\"\n    Directive to mark description of a new module.\n    This directive doesn't generate any special formatting, and is just\n    a pass-through for the content body. Named section titles are\n    allowed in the content body.\n    Use this directive to create entries for the QAPI module in the",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIModule",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIModule(QAPIDescription):\n    \"\"\"\n    Directive to mark description of a new module.\n    This directive doesn't generate any special formatting, and is just\n    a pass-through for the content body. Named section titles are\n    allowed in the content body.\n    Use this directive to create entries for the QAPI module in the\n    global index and the QAPI index; as well as to associate subsequent\n    definitions with the module they are defined in for purposes of\n    search and QAPI index organization.",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPINamespace",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPINamespace(SphinxDirective):\n    has_content = False\n    required_arguments = 1\n    def run(self) -> List[Node]:\n        namespace = self.arguments[0].strip()\n        self.env.ref_context[\"qapi:namespace\"] = namespace\n        return []\nclass QAPIIndex(Index):\n    \"\"\"\n    Index subclass to provide the QAPI definition index.",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIIndex",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIIndex(Index):\n    \"\"\"\n    Index subclass to provide the QAPI definition index.\n    \"\"\"\n    # pylint: disable=too-few-public-methods\n    name = \"index\"\n    localname = _(\"QAPI Index\")\n    shortname = _(\"QAPI Index\")\n    namespace = \"\"\n    def generate(",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "QAPIDomain",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "class QAPIDomain(Domain):\n    \"\"\"QAPI language domain.\"\"\"\n    name = \"qapi\"\n    label = \"QAPI\"\n    # This table associates cross-reference object types (key) with an\n    # ObjType instance, which defines the valid cross-reference roles\n    # for each object type.\n    #\n    # e.g., the :qapi:type: cross-reference role can refer to enum,\n    # struct, union, or alternate objects; but :qapi:obj: can refer to",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "def setup(app: Sphinx) -> Dict[str, Any]:\n    app.setup_extension(\"sphinx.directives\")\n    app.add_config_value(\n        \"qapi_allowed_fields\",\n        set(),\n        \"env\",  # Setting impacts parsing phase\n        types=set,\n    )\n    app.add_config_value(\n        \"qapi_namespaces\",",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.qapi_domain",
        "description": "qemu.docs.sphinx.qapi_domain",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef _unpack_field(\n    field: nodes.Node,\n) -> Tuple[nodes.field_name, nodes.field_body]:\n    \"\"\"\n    docutils helper: unpack a field node in a type-safe manner.\n    \"\"\"\n    assert isinstance(field, nodes.field)\n    assert len(field.children) == 2\n    assert isinstance(field.children[0], nodes.field_name)",
        "detail": "qemu.docs.sphinx.qapi_domain",
        "documentation": {}
    },
    {
        "label": "Transmogrifier",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "class Transmogrifier:\n    # pylint: disable=too-many-public-methods\n    # Field names used for different entity types:\n    field_types = {\n        \"enum\": \"value\",\n        \"struct\": \"memb\",\n        \"union\": \"memb\",\n        \"event\": \"memb\",\n        \"command\": \"arg\",\n        \"alternate\": \"alt\",",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenDepVisitor",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "class QAPISchemaGenDepVisitor(QAPISchemaVisitor):\n    \"\"\"A QAPI schema visitor which adds Sphinx dependencies each module\n    This class calls the Sphinx note_dependency() function to tell Sphinx\n    that the generated documentation output depends on the input\n    schema file associated with each module in the QAPI input.\n    \"\"\"\n    def __init__(self, env: Any, qapidir: str) -> None:\n        self._env = env\n        self._qapidir = qapidir\n    def visit_module(self, name: str) -> None:",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "NestedDirective",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "class NestedDirective(SphinxDirective):\n    def run(self) -> Sequence[nodes.Node]:\n        raise NotImplementedError\n    def do_parse(self, rstlist: StringList, node: nodes.Node) -> None:\n        \"\"\"\n        Parse rST source lines and add them to the specified node\n        Take the list of rST source lines rstlist, parse them as\n        rST, and add the resulting docutils nodes as children of node.\n        The nodes are parsed in a way that allows them to include\n        subheadings (titles) without confusing the rendering of",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "QAPIDocDirective",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "class QAPIDocDirective(NestedDirective):\n    \"\"\"Extract documentation from the specified QAPI .json file\"\"\"\n    required_argument = 1\n    optional_arguments = 1\n    option_spec = {\n        \"qapifile\": directives.unchanged_required,\n        \"namespace\": directives.unchanged,\n        \"transmogrify\": directives.flag,\n    }\n    has_content = False",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "QMPExample",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "class QMPExample(CodeBlock, NestedDirective):\n    \"\"\"\n    Custom admonition for QMP code examples.\n    When the :annotated: option is present, the body of this directive\n    is parsed as normal rST, but with any '::' code blocks set to use\n    the QMP lexer. Code blocks must be explicitly written by the user,\n    but this allows for intermingling explanatory paragraphs with\n    arbitrary rST syntax and code blocks for more involved examples.\n    When :annotated: is absent, the directive body is treated as a\n    simple standalone QMP code block literal.",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "def setup(app: Sphinx) -> ExtensionMetadata:\n    \"\"\"Register qapi-doc directive with Sphinx\"\"\"\n    app.setup_extension(\"qapi_domain\")\n    app.add_config_value(\"qapidoc_srctree\", None, \"env\")\n    app.add_directive(\"qapi-doc\", QAPIDocDirective)\n    app.add_directive(\"qmp-example\", QMPExample)\n    return {\n        \"version\": __version__,\n        \"parallel_read_safe\": True,\n        \"parallel_write_safe\": True,",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "__version__ = \"2.0\"\nfrom contextlib import contextmanager\nimport os\nfrom pathlib import Path\nimport re\nimport sys\nfrom typing import TYPE_CHECKING\nfrom docutils import nodes\nfrom docutils.parsers.rst import directives\nfrom docutils.statemachine import StringList",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.docs.sphinx.qapidoc",
        "description": "qemu.docs.sphinx.qapidoc",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass Transmogrifier:\n    # pylint: disable=too-many-public-methods\n    # Field names used for different entity types:\n    field_types = {\n        \"enum\": \"value\",\n        \"struct\": \"memb\",\n        \"union\": \"memb\",\n        \"event\": \"memb\",\n        \"command\": \"arg\",",
        "detail": "qemu.docs.sphinx.qapidoc",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenRSTVisitor",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qapidoc_legacy",
        "description": "qemu.docs.sphinx.qapidoc_legacy",
        "peekOfCode": "class QAPISchemaGenRSTVisitor(QAPISchemaVisitor):\n    \"\"\"A QAPI schema visitor which generates docutils/Sphinx nodes\n    This class builds up a tree of docutils/Sphinx nodes corresponding\n    to documentation for the various QAPI objects. To use it, first\n    create a QAPISchemaGenRSTVisitor object, and call its\n    visit_begin() method.  Then you can call one of the two methods\n    'freeform' (to add documentation for a freeform documentation\n    chunk) or 'symbol' (to add documentation for a QAPI symbol). These\n    will cause the visitor to build up the tree of document\n    nodes. Once you've added all the documentation via 'freeform' and",
        "detail": "qemu.docs.sphinx.qapidoc_legacy",
        "documentation": {}
    },
    {
        "label": "dedent",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.qapidoc_legacy",
        "description": "qemu.docs.sphinx.qapidoc_legacy",
        "peekOfCode": "def dedent(text: str) -> str:\n    # Adjust indentation to make description text parse as paragraph.\n    lines = text.splitlines(True)\n    if re.match(r\"\\s+\", lines[0]):\n        # First line is indented; description started on the line after\n        # the name. dedent the whole block.\n        return textwrap.dedent(text)\n    # Descr started on same line. Dedent line 2+.\n    return lines[0] + textwrap.dedent(\"\".join(lines[1:]))\nclass QAPISchemaGenRSTVisitor(QAPISchemaVisitor):",
        "detail": "qemu.docs.sphinx.qapidoc_legacy",
        "documentation": {}
    },
    {
        "label": "QMPExampleMarkersLexer",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qmp_lexer",
        "description": "qemu.docs.sphinx.qmp_lexer",
        "peekOfCode": "class QMPExampleMarkersLexer(RegexLexer):\n    \"\"\"\n    QMPExampleMarkersLexer lexes QMP example annotations.\n    This lexer adds support for directionality flow and elision indicators.\n    \"\"\"\n    tokens = {\n        'root': [\n            (r'-> ', token.Generic.Prompt),\n            (r'<- ', token.Generic.Prompt),\n            (r'\\.{3}( .* \\.{3})?', token.Comment.Multiline),",
        "detail": "qemu.docs.sphinx.qmp_lexer",
        "documentation": {}
    },
    {
        "label": "QMPExampleLexer",
        "kind": 6,
        "importPath": "qemu.docs.sphinx.qmp_lexer",
        "description": "qemu.docs.sphinx.qmp_lexer",
        "peekOfCode": "class QMPExampleLexer(DelegatingLexer):\n    \"\"\"QMPExampleLexer lexes annotated QMP examples.\"\"\"\n    def __init__(self, **options):\n        super(QMPExampleLexer, self).__init__(JsonLexer, QMPExampleMarkersLexer,\n                                              token.Error, **options)\ndef setup(sphinx):\n    \"\"\"For use by the Sphinx extensions API.\"\"\"\n    try:\n        sphinx.require_sphinx('2.1')\n        sphinx.add_lexer('QMP', QMPExampleLexer)",
        "detail": "qemu.docs.sphinx.qmp_lexer",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "qemu.docs.sphinx.qmp_lexer",
        "description": "qemu.docs.sphinx.qmp_lexer",
        "peekOfCode": "def setup(sphinx):\n    \"\"\"For use by the Sphinx extensions API.\"\"\"\n    try:\n        sphinx.require_sphinx('2.1')\n        sphinx.add_lexer('QMP', QMPExampleLexer)\n    except errors.VersionRequirementError:\n        sphinx.add_lexer('QMP', QMPExampleLexer())\n    return dict(\n        parallel_read_safe = True,\n        parallel_write_safe = True",
        "detail": "qemu.docs.sphinx.qmp_lexer",
        "documentation": {}
    },
    {
        "label": "needs_sphinx",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "needs_sphinx = '3.4.3'\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'depfile',\n    'hxtool',\n    'kerneldoc',\n    'qapi_domain',\n    'qapidoc',",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "extensions = [\n    'depfile',\n    'hxtool',\n    'kerneldoc',\n    'qapi_domain',\n    'qapidoc',\n    'qmp_lexer',\n]\nif sphinx.version_info[:3] > (4, 0, 0):\n    tags.add('sphinx4')",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "templates_path = [os.path.join(qemu_docdir, '_templates')]\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n# The master toctree document.\nmaster_doc = 'index'\n# Interpret `single-backticks` to be a cross-reference to any kind of\n# referenceable object. Unresolvable or ambiguous references will emit a",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "source_suffix = '.rst'\n# The master toctree document.\nmaster_doc = 'index'\n# Interpret `single-backticks` to be a cross-reference to any kind of\n# referenceable object. Unresolvable or ambiguous references will emit a\n# warning at build time.\ndefault_role = 'any'\n# General information about the project.\nproject = u'QEMU'\ncopyright = u'2025, The QEMU Project Developers'",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "master_doc = 'index'\n# Interpret `single-backticks` to be a cross-reference to any kind of\n# referenceable object. Unresolvable or ambiguous references will emit a\n# warning at build time.\ndefault_role = 'any'\n# General information about the project.\nproject = u'QEMU'\ncopyright = u'2025, The QEMU Project Developers'\nauthor = u'The QEMU Project Developers'\n# The version info for the project you're documenting, acts as replacement for",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "default_role",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "default_role = 'any'\n# General information about the project.\nproject = u'QEMU'\ncopyright = u'2025, The QEMU Project Developers'\nauthor = u'The QEMU Project Developers'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n# Extract this information from the VERSION file, for the benefit of\n# standalone Sphinx runs as used by readthedocs.org. Builds run from",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "project = u'QEMU'\ncopyright = u'2025, The QEMU Project Developers'\nauthor = u'The QEMU Project Developers'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n# Extract this information from the VERSION file, for the benefit of\n# standalone Sphinx runs as used by readthedocs.org. Builds run from\n# the Makefile will pass version and release on the sphinx-build\n# command line, which override this.",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "copyright = u'2025, The QEMU Project Developers'\nauthor = u'The QEMU Project Developers'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n# Extract this information from the VERSION file, for the benefit of\n# standalone Sphinx runs as used by readthedocs.org. Builds run from\n# the Makefile will pass version and release on the sphinx-build\n# command line, which override this.\ntry:",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "author = u'The QEMU Project Developers'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n# Extract this information from the VERSION file, for the benefit of\n# standalone Sphinx runs as used by readthedocs.org. Builds run from\n# the Makefile will pass version and release on the sphinx-build\n# command line, which override this.\ntry:\n    extracted_version = None",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "language",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "language = 'en'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# Sphinx defaults to warning about use of :option: for options not defined",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# Sphinx defaults to warning about use of :option: for options not defined\n# with \"option::\" in the document being processed. Turn that off.\nsuppress_warnings = [\"ref.option\"]\n# The rst_epilog fragment is effectively included in every rST file.\n# We use it to define substitutions based on build config that",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# Sphinx defaults to warning about use of :option: for options not defined\n# with \"option::\" in the document being processed. Turn that off.\nsuppress_warnings = [\"ref.option\"]\n# The rst_epilog fragment is effectively included in every rST file.\n# We use it to define substitutions based on build config that\n# can then be used in the documentation. The fallback if the\n# environment variable is not set is for the benefit of readthedocs",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "todo_include_todos = False\n# Sphinx defaults to warning about use of :option: for options not defined\n# with \"option::\" in the document being processed. Turn that off.\nsuppress_warnings = [\"ref.option\"]\n# The rst_epilog fragment is effectively included in every rST file.\n# We use it to define substitutions based on build config that\n# can then be used in the documentation. The fallback if the\n# environment variable is not set is for the benefit of readthedocs\n# style document building; our Makefile always sets the variable.\nconfdir = os.getenv('CONFDIR', \"/etc/qemu\")",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "suppress_warnings",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "suppress_warnings = [\"ref.option\"]\n# The rst_epilog fragment is effectively included in every rST file.\n# We use it to define substitutions based on build config that\n# can then be used in the documentation. The fallback if the\n# environment variable is not set is for the benefit of readthedocs\n# style document building; our Makefile always sets the variable.\nconfdir = os.getenv('CONFDIR', \"/etc/qemu\")\nrst_epilog = \".. |CONFDIR| replace:: ``\" + confdir + \"``\\n\"\n# We slurp in the defs.rst.inc and literally include it into rst_epilog,\n# because Sphinx's include:: directive doesn't work with absolute paths",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "confdir",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "confdir = os.getenv('CONFDIR', \"/etc/qemu\")\nrst_epilog = \".. |CONFDIR| replace:: ``\" + confdir + \"``\\n\"\n# We slurp in the defs.rst.inc and literally include it into rst_epilog,\n# because Sphinx's include:: directive doesn't work with absolute paths\n# and there isn't any one single relative path that will work for all\n# documents and for both via-make and direct sphinx-build invocation.\nwith open(os.path.join(qemu_docdir, 'defs.rst.inc')) as f:\n    rst_epilog += f.read()\n# Normally, the QAPI domain is picky about what field lists you use to\n# describe a QAPI entity. If you'd like to use arbitrary additional",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "rst_epilog",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "rst_epilog = \".. |CONFDIR| replace:: ``\" + confdir + \"``\\n\"\n# We slurp in the defs.rst.inc and literally include it into rst_epilog,\n# because Sphinx's include:: directive doesn't work with absolute paths\n# and there isn't any one single relative path that will work for all\n# documents and for both via-make and direct sphinx-build invocation.\nwith open(os.path.join(qemu_docdir, 'defs.rst.inc')) as f:\n    rst_epilog += f.read()\n# Normally, the QAPI domain is picky about what field lists you use to\n# describe a QAPI entity. If you'd like to use arbitrary additional\n# fields in source documentation, add them here.",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "qapi_allowed_fields",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "qapi_allowed_fields = {\n    \"see also\",\n}\n# Due to a limitation in Sphinx, we need to know which indices to\n# generate in advance. Adding a namespace here allows that generation.\nqapi_namespaces = {\n    \"QGA\",\n    \"QMP\",\n    \"QSD\",\n}",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "qapi_namespaces",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "qapi_namespaces = {\n    \"QGA\",\n    \"QMP\",\n    \"QSD\",\n}\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\ntry:",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_theme = 'sphinx_rtd_theme'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    \"style_nav_header_background\": \"#802400\",\n    \"navigation_with_keys\": True,\n}\nhtml_logo = os.path.join(qemu_docdir, \"../ui/icons/qemu_128x128.png\")\nhtml_favicon = os.path.join(qemu_docdir, \"../ui/icons/qemu_32x32.png\")",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_theme_options",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_theme_options = {\n    \"style_nav_header_background\": \"#802400\",\n    \"navigation_with_keys\": True,\n}\nhtml_logo = os.path.join(qemu_docdir, \"../ui/icons/qemu_128x128.png\")\nhtml_favicon = os.path.join(qemu_docdir, \"../ui/icons/qemu_32x32.png\")\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [os.path.join(qemu_docdir, \"sphinx-static\")]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_logo",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_logo = os.path.join(qemu_docdir, \"../ui/icons/qemu_128x128.png\")\nhtml_favicon = os.path.join(qemu_docdir, \"../ui/icons/qemu_32x32.png\")\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [os.path.join(qemu_docdir, \"sphinx-static\")]\nhtml_css_files = [\n    'theme_overrides.css',\n]\nhtml_js_files = [",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_favicon",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_favicon = os.path.join(qemu_docdir, \"../ui/icons/qemu_32x32.png\")\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [os.path.join(qemu_docdir, \"sphinx-static\")]\nhtml_css_files = [\n    'theme_overrides.css',\n]\nhtml_js_files = [\n    'custom.js',",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_static_path = [os.path.join(qemu_docdir, \"sphinx-static\")]\nhtml_css_files = [\n    'theme_overrides.css',\n]\nhtml_js_files = [\n    'custom.js',\n]\nhtml_context = {\n    \"source_url_prefix\": \"https://gitlab.com/qemu-project/qemu/-/blob/master/docs/\",\n    \"gitlab_user\": \"qemu-project\",",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_css_files",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_css_files = [\n    'theme_overrides.css',\n]\nhtml_js_files = [\n    'custom.js',\n]\nhtml_context = {\n    \"source_url_prefix\": \"https://gitlab.com/qemu-project/qemu/-/blob/master/docs/\",\n    \"gitlab_user\": \"qemu-project\",\n    \"gitlab_repo\": \"qemu\",",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_js_files",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_js_files = [\n    'custom.js',\n]\nhtml_context = {\n    \"source_url_prefix\": \"https://gitlab.com/qemu-project/qemu/-/blob/master/docs/\",\n    \"gitlab_user\": \"qemu-project\",\n    \"gitlab_repo\": \"qemu\",\n    \"gitlab_version\": \"master\",\n    \"conf_py_path\": \"/docs/\", # Path in the checkout to the docs root\n}",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_context",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_context = {\n    \"source_url_prefix\": \"https://gitlab.com/qemu-project/qemu/-/blob/master/docs/\",\n    \"gitlab_user\": \"qemu-project\",\n    \"gitlab_repo\": \"qemu\",\n    \"gitlab_version\": \"master\",\n    \"conf_py_path\": \"/docs/\", # Path in the checkout to the docs root\n}\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#html_sidebars = {}",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_sidebars",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "#html_sidebars = {}\n# Don't copy the rST source files to the HTML output directory,\n# and don't put links to the sources into the output HTML.\nhtml_copy_source = False\n# -- Options for HTMLHelp output ------------------------------------------\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'QEMUdoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_copy_source",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "html_copy_source = False\n# -- Options for HTMLHelp output ------------------------------------------\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'QEMUdoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "htmlhelp_basename = 'QEMUdoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "latex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "latex_documents = [\n    (master_doc, 'QEMU.tex', u'QEMU Documentation',\n     u'The QEMU Project Developers', 'manual'),\n]\n# -- Options for manual page output ---------------------------------------\n# Individual manual/conf.py can override this to create man pages\nman_pages = [\n    ('interop/qemu-ga', 'qemu-ga',\n     'QEMU Guest Agent',\n     ['Michael Roth <mdroth@linux.vnet.ibm.com>'], 8),",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "man_pages = [\n    ('interop/qemu-ga', 'qemu-ga',\n     'QEMU Guest Agent',\n     ['Michael Roth <mdroth@linux.vnet.ibm.com>'], 8),\n    ('interop/qemu-ga-ref', 'qemu-ga-ref',\n     'QEMU Guest Agent Protocol Reference',\n     [], 7),\n    ('interop/qemu-qmp-ref', 'qemu-qmp-ref',\n     'QEMU QMP Reference Manual',\n     [], 7),",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "man_make_section_directory",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "man_make_section_directory = False\n# We use paths starting from qemu_docdir here so that you can run\n# sphinx-build from anywhere and the kerneldoc extension can still\n# find everything.\nkerneldoc_bin = ['perl', os.path.join(qemu_docdir, '../scripts/kernel-doc')]\nkerneldoc_srctree = os.path.join(qemu_docdir, '..')\nhxtool_srctree = os.path.join(qemu_docdir, '..')\nqapidoc_srctree = os.path.join(qemu_docdir, '..')\ndbusdoc_srctree = os.path.join(qemu_docdir, '..')\ndbus_index_common_prefix = [\"org.qemu.\"]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "kerneldoc_bin",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "kerneldoc_bin = ['perl', os.path.join(qemu_docdir, '../scripts/kernel-doc')]\nkerneldoc_srctree = os.path.join(qemu_docdir, '..')\nhxtool_srctree = os.path.join(qemu_docdir, '..')\nqapidoc_srctree = os.path.join(qemu_docdir, '..')\ndbusdoc_srctree = os.path.join(qemu_docdir, '..')\ndbus_index_common_prefix = [\"org.qemu.\"]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "kerneldoc_srctree",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "kerneldoc_srctree = os.path.join(qemu_docdir, '..')\nhxtool_srctree = os.path.join(qemu_docdir, '..')\nqapidoc_srctree = os.path.join(qemu_docdir, '..')\ndbusdoc_srctree = os.path.join(qemu_docdir, '..')\ndbus_index_common_prefix = [\"org.qemu.\"]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "hxtool_srctree",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "hxtool_srctree = os.path.join(qemu_docdir, '..')\nqapidoc_srctree = os.path.join(qemu_docdir, '..')\ndbusdoc_srctree = os.path.join(qemu_docdir, '..')\ndbus_index_common_prefix = [\"org.qemu.\"]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "qapidoc_srctree",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "qapidoc_srctree = os.path.join(qemu_docdir, '..')\ndbusdoc_srctree = os.path.join(qemu_docdir, '..')\ndbus_index_common_prefix = [\"org.qemu.\"]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "dbusdoc_srctree",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "dbusdoc_srctree = os.path.join(qemu_docdir, '..')\ndbus_index_common_prefix = [\"org.qemu.\"]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "dbus_index_common_prefix",
        "kind": 5,
        "importPath": "qemu.docs.conf",
        "description": "qemu.docs.conf",
        "peekOfCode": "dbus_index_common_prefix = [\"org.qemu.\"]",
        "detail": "qemu.docs.conf",
        "documentation": {}
    },
    {
        "label": "ConsoleSocket",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.console_socket",
        "description": "qemu.python.qemu.machine.console_socket",
        "peekOfCode": "class ConsoleSocket(socket.socket):\n    \"\"\"\n    ConsoleSocket represents a socket attached to a char device.\n    :param address: An AF_UNIX path or address.\n    :param sock_fd: Optionally, an existing socket file descriptor.\n                    One of address or sock_fd must be specified.\n    :param file: Optionally, a filename to log to.\n    :param drain: Optionally, drains the socket and places the bytes\n                  into an in memory buffer for later processing.\n    \"\"\"",
        "detail": "qemu.python.qemu.machine.console_socket",
        "documentation": {}
    },
    {
        "label": "QEMUMachineError",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.machine",
        "description": "qemu.python.qemu.machine.machine",
        "peekOfCode": "class QEMUMachineError(Exception):\n    \"\"\"\n    Exception called when an error in QEMUMachine happens.\n    \"\"\"\nclass QEMUMachineAddDeviceError(QEMUMachineError):\n    \"\"\"\n    Exception raised when a request to add a device can not be fulfilled\n    The failures are caused by limitations, lack of information or conflicting\n    requests on the QEMUMachine methods.  This exception does not represent\n    failures reported by the QEMU binary itself.",
        "detail": "qemu.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachineAddDeviceError",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.machine",
        "description": "qemu.python.qemu.machine.machine",
        "peekOfCode": "class QEMUMachineAddDeviceError(QEMUMachineError):\n    \"\"\"\n    Exception raised when a request to add a device can not be fulfilled\n    The failures are caused by limitations, lack of information or conflicting\n    requests on the QEMUMachine methods.  This exception does not represent\n    failures reported by the QEMU binary itself.\n    \"\"\"\nclass VMLaunchFailure(QEMUMachineError):\n    \"\"\"\n    Exception raised when a VM launch was attempted, but failed.",
        "detail": "qemu.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "VMLaunchFailure",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.machine",
        "description": "qemu.python.qemu.machine.machine",
        "peekOfCode": "class VMLaunchFailure(QEMUMachineError):\n    \"\"\"\n    Exception raised when a VM launch was attempted, but failed.\n    \"\"\"\n    def __init__(self, exitcode: Optional[int],\n                 command: str, output: Optional[str]):\n        super().__init__(exitcode, command, output)\n        self.exitcode = exitcode\n        self.command = command\n        self.output = output",
        "detail": "qemu.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "AbnormalShutdown",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.machine",
        "description": "qemu.python.qemu.machine.machine",
        "peekOfCode": "class AbnormalShutdown(QEMUMachineError):\n    \"\"\"\n    Exception raised when a graceful shutdown was requested, but not performed.\n    \"\"\"\n_T = TypeVar('_T', bound='QEMUMachine')\nclass QEMUMachine:\n    \"\"\"\n    A QEMU VM.\n    Use this object as a context manager to ensure\n    the QEMU process terminates::",
        "detail": "qemu.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "QEMUMachine",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.machine",
        "description": "qemu.python.qemu.machine.machine",
        "peekOfCode": "class QEMUMachine:\n    \"\"\"\n    A QEMU VM.\n    Use this object as a context manager to ensure\n    the QEMU process terminates::\n        with VM(binary) as vm:\n            ...\n        # vm is guaranteed to be shut down here\n    \"\"\"\n    # pylint: disable=too-many-instance-attributes, too-many-public-methods",
        "detail": "qemu.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "qemu.python.qemu.machine.machine",
        "description": "qemu.python.qemu.machine.machine",
        "peekOfCode": "LOG = logging.getLogger(__name__)\nclass QEMUMachineError(Exception):\n    \"\"\"\n    Exception called when an error in QEMUMachine happens.\n    \"\"\"\nclass QEMUMachineAddDeviceError(QEMUMachineError):\n    \"\"\"\n    Exception raised when a request to add a device can not be fulfilled\n    The failures are caused by limitations, lack of information or conflicting\n    requests on the QEMUMachine methods.  This exception does not represent",
        "detail": "qemu.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "_T",
        "kind": 5,
        "importPath": "qemu.python.qemu.machine.machine",
        "description": "qemu.python.qemu.machine.machine",
        "peekOfCode": "_T = TypeVar('_T', bound='QEMUMachine')\nclass QEMUMachine:\n    \"\"\"\n    A QEMU VM.\n    Use this object as a context manager to ensure\n    the QEMU process terminates::\n        with VM(binary) as vm:\n            ...\n        # vm is guaranteed to be shut down here\n    \"\"\"",
        "detail": "qemu.python.qemu.machine.machine",
        "documentation": {}
    },
    {
        "label": "QEMUQtestProtocol",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.qtest",
        "description": "qemu.python.qemu.machine.qtest",
        "peekOfCode": "class QEMUQtestProtocol:\n    \"\"\"\n    QEMUQtestProtocol implements a connection to a qtest socket.\n    :param address: QEMU address, can be either a unix socket path (string)\n                    or a tuple in the form ( address, port ) for a TCP\n                    connection\n    :param sock: An existing socket can be provided as an alternative to\n                 an address. One of address or sock must be provided.\n    :param server: server mode, listens on the socket. Only meaningful\n                   in conjunction with an address and not an existing",
        "detail": "qemu.python.qemu.machine.qtest",
        "documentation": {}
    },
    {
        "label": "QEMUQtestMachine",
        "kind": 6,
        "importPath": "qemu.python.qemu.machine.qtest",
        "description": "qemu.python.qemu.machine.qtest",
        "peekOfCode": "class QEMUQtestMachine(QEMUMachine):\n    \"\"\"\n    A QEMU VM, with a qtest socket available.\n    \"\"\"\n    def __init__(self,\n                 binary: str,\n                 args: Sequence[str] = (),\n                 wrapper: Sequence[str] = (),\n                 name: Optional[str] = None,\n                 base_temp_dir: str = \"/var/tmp\",",
        "detail": "qemu.python.qemu.machine.qtest",
        "documentation": {}
    },
    {
        "label": "QMPError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.error",
        "description": "qemu.python.qemu.qmp.error",
        "peekOfCode": "class QMPError(Exception):\n    \"\"\"Abstract error class for all errors originating from this package.\"\"\"\nclass ProtocolError(QMPError):\n    \"\"\"\n    Abstract error class for protocol failures.\n    Semantically, these errors are generally the fault of either the\n    protocol server or as a result of a bug in this library.\n    :param error_message: Human-readable string describing the error.\n    \"\"\"\n    def __init__(self, error_message: str):",
        "detail": "qemu.python.qemu.qmp.error",
        "documentation": {}
    },
    {
        "label": "ProtocolError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.error",
        "description": "qemu.python.qemu.qmp.error",
        "peekOfCode": "class ProtocolError(QMPError):\n    \"\"\"\n    Abstract error class for protocol failures.\n    Semantically, these errors are generally the fault of either the\n    protocol server or as a result of a bug in this library.\n    :param error_message: Human-readable string describing the error.\n    \"\"\"\n    def __init__(self, error_message: str):\n        super().__init__(error_message)\n        #: Human-readable error message, without any prefix.",
        "detail": "qemu.python.qemu.qmp.error",
        "documentation": {}
    },
    {
        "label": "ListenerError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.events",
        "description": "qemu.python.qemu.qmp.events",
        "peekOfCode": "class ListenerError(QMPError):\n    \"\"\"\n    Generic error class for `EventListener`-related problems.\n    \"\"\"\nclass EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,\n    but it can be extended to provide more rigorous control.\n    :param names:",
        "detail": "qemu.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "EventListener",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.events",
        "description": "qemu.python.qemu.qmp.events",
        "peekOfCode": "class EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,\n    but it can be extended to provide more rigorous control.\n    :param names:\n        One or more names of events to listen for.\n        When not provided, listen for ALL events.\n    :param event_filter:\n        An optional event filtering function.",
        "detail": "qemu.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "Events",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.events",
        "description": "qemu.python.qemu.qmp.events",
        "peekOfCode": "class Events:\n    \"\"\"\n    Events is a mix-in class that adds event functionality to the QMP class.\n    It's designed specifically as a mix-in for `QMPClient`, and it\n    relies upon the class it is being mixed into having a 'logger'\n    property.\n    \"\"\"\n    def __init__(self) -> None:\n        self._listeners: List[EventListener] = []\n        #: Default, all-events `EventListener`.",
        "detail": "qemu.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "EventNames",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.events",
        "description": "qemu.python.qemu.qmp.events",
        "peekOfCode": "EventNames = Union[str, Iterable[str], None]\nEventFilter = Callable[[Message], bool]\nclass ListenerError(QMPError):\n    \"\"\"\n    Generic error class for `EventListener`-related problems.\n    \"\"\"\nclass EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,",
        "detail": "qemu.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "EventFilter",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.events",
        "description": "qemu.python.qemu.qmp.events",
        "peekOfCode": "EventFilter = Callable[[Message], bool]\nclass ListenerError(QMPError):\n    \"\"\"\n    Generic error class for `EventListener`-related problems.\n    \"\"\"\nclass EventListener:\n    \"\"\"\n    Selectively listens for events with runtime configurable filtering.\n    This class is designed to be directly usable for the most common cases,\n    but it can be extended to provide more rigorous control.",
        "detail": "qemu.python.qemu.qmp.events",
        "documentation": {}
    },
    {
        "label": "QMPBadPortError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.legacy",
        "description": "qemu.python.qemu.qmp.legacy",
        "peekOfCode": "class QMPBadPortError(QMPError):\n    \"\"\"\n    Unable to parse socket address: Port was non-numerical.\n    \"\"\"\nclass QEMUMonitorProtocol:\n    \"\"\"\n    Provide an API to connect to QEMU via QEMU Monitor Protocol (QMP)\n    and then allow to handle commands and events.\n    :param address:  QEMU address, can be a unix socket path (string), a tuple\n                     in the form ( address, port ) for a TCP connection, or an",
        "detail": "qemu.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QEMUMonitorProtocol",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.legacy",
        "description": "qemu.python.qemu.qmp.legacy",
        "peekOfCode": "class QEMUMonitorProtocol:\n    \"\"\"\n    Provide an API to connect to QEMU via QEMU Monitor Protocol (QMP)\n    and then allow to handle commands and events.\n    :param address:  QEMU address, can be a unix socket path (string), a tuple\n                     in the form ( address, port ) for a TCP connection, or an\n                     existing `socket.socket` object.\n    :param server:   Act as the socket server. (See 'accept')\n                     Not applicable when passing a socket directly.\n    :param nickname: Optional nickname used for logging.",
        "detail": "qemu.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPMessage",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.legacy",
        "description": "qemu.python.qemu.qmp.legacy",
        "peekOfCode": "QMPMessage = Dict[str, Any]\n#: QMPReturnValue is the 'return' value of a command.\nQMPReturnValue = object\n#: QMPObject is any object in a QMP message.\nQMPObject = Dict[str, object]\n# QMPMessage can be outgoing commands or incoming events/returns.\n# QMPReturnValue is usually a dict/json object, but due to QAPI's\n# 'command-returns-exceptions', it can actually be anything.\n#\n# {'return': {}} is a QMPMessage,",
        "detail": "qemu.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPReturnValue",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.legacy",
        "description": "qemu.python.qemu.qmp.legacy",
        "peekOfCode": "QMPReturnValue = object\n#: QMPObject is any object in a QMP message.\nQMPObject = Dict[str, object]\n# QMPMessage can be outgoing commands or incoming events/returns.\n# QMPReturnValue is usually a dict/json object, but due to QAPI's\n# 'command-returns-exceptions', it can actually be anything.\n#\n# {'return': {}} is a QMPMessage,\n# {} is the QMPReturnValue.\nclass QMPBadPortError(QMPError):",
        "detail": "qemu.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "QMPObject",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.legacy",
        "description": "qemu.python.qemu.qmp.legacy",
        "peekOfCode": "QMPObject = Dict[str, object]\n# QMPMessage can be outgoing commands or incoming events/returns.\n# QMPReturnValue is usually a dict/json object, but due to QAPI's\n# 'command-returns-exceptions', it can actually be anything.\n#\n# {'return': {}} is a QMPMessage,\n# {} is the QMPReturnValue.\nclass QMPBadPortError(QMPError):\n    \"\"\"\n    Unable to parse socket address: Port was non-numerical.",
        "detail": "qemu.python.qemu.qmp.legacy",
        "documentation": {}
    },
    {
        "label": "Message",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.message",
        "description": "qemu.python.qemu.qmp.message",
        "peekOfCode": "class Message(MutableMapping[str, object]):\n    \"\"\"\n    Represents a single QMP protocol message.\n    QMP uses JSON objects as its basic communicative unit; so this\n    Python object is a :py:obj:`~collections.abc.MutableMapping`. It may\n    be instantiated from either another mapping (like a `dict`), or from\n    raw `bytes` that still need to be deserialized.\n    Once instantiated, it may be treated like any other MutableMapping::\n        >>> msg = Message(b'{\"hello\": \"world\"}')\n        >>> assert msg['hello'] == 'world'",
        "detail": "qemu.python.qemu.qmp.message",
        "documentation": {}
    },
    {
        "label": "DeserializationError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.message",
        "description": "qemu.python.qemu.qmp.message",
        "peekOfCode": "class DeserializationError(ProtocolError):\n    \"\"\"\n    A QMP message was not understood as JSON.\n    When this Exception is raised, ``__cause__`` will be set to the\n    `json.JSONDecodeError` Exception, which can be interrogated for\n    further details.\n    :param error_message: Human-readable string describing the error.\n    :param raw: The raw `bytes` that prompted the failure.\n    \"\"\"\n    def __init__(self, error_message: str, raw: bytes):",
        "detail": "qemu.python.qemu.qmp.message",
        "documentation": {}
    },
    {
        "label": "UnexpectedTypeError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.message",
        "description": "qemu.python.qemu.qmp.message",
        "peekOfCode": "class UnexpectedTypeError(ProtocolError):\n    \"\"\"\n    A QMP message was JSON, but not a JSON object.\n    :param error_message: Human-readable string describing the error.\n    :param value: The deserialized JSON value that wasn't an object.\n    \"\"\"\n    def __init__(self, error_message: str, value: object):\n        super().__init__(error_message)\n        #: The JSON value that was expected to be an object.\n        self.value: object = value",
        "detail": "qemu.python.qemu.qmp.message",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.models",
        "description": "qemu.python.qemu.qmp.models",
        "peekOfCode": "class Model:\n    \"\"\"\n    Abstract data model, representing some QMP object of some kind.\n    :param raw: The raw object to be validated.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        self._raw = raw\n    def _check_key(self, key: str) -> None:",
        "detail": "qemu.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "Greeting",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.models",
        "description": "qemu.python.qemu.qmp.models",
        "peekOfCode": "class Greeting(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Server Greeting\".\n    :param raw: The raw Greeting object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'QMP' member",
        "detail": "qemu.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "QMPGreeting",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.models",
        "description": "qemu.python.qemu.qmp.models",
        "peekOfCode": "class QMPGreeting(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Server Greeting\".\n    :param raw: The raw QMPGreeting object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'version' member",
        "detail": "qemu.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "ErrorResponse",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.models",
        "description": "qemu.python.qemu.qmp.models",
        "peekOfCode": "class ErrorResponse(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Error\".\n    :param raw: The raw ErrorResponse object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'error' member",
        "detail": "qemu.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "ErrorInfo",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.models",
        "description": "qemu.python.qemu.qmp.models",
        "peekOfCode": "class ErrorInfo(Model):\n    \"\"\"\n    Defined in qmp-spec.rst, section \"Error\".\n    :param raw: The raw ErrorInfo object.\n    :raise KeyError: If any required fields are absent.\n    :raise TypeError: If any required fields have the wrong type.\n    \"\"\"\n    def __init__(self, raw: Mapping[str, Any]):\n        super().__init__(raw)\n        #: 'class' member, with an underscore to avoid conflicts in Python.",
        "detail": "qemu.python.qemu.qmp.models",
        "documentation": {}
    },
    {
        "label": "Runstate",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "class Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.\n    RUNNING = 2\n    #: In the process of disconnecting.\n    #: Runstate may be returned to `IDLE` by calling `disconnect()`.",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "ConnectError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "class ConnectError(QMPError):\n    \"\"\"\n    Raised when the initial connection process has failed.\n    This Exception always wraps a \"root cause\" exception that can be\n    interrogated for additional information.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\n    def __init__(self, error_message: str, exc: Exception):\n        super().__init__(error_message)",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "StateError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "class StateError(QMPError):\n    \"\"\"\n    An API command (connect, execute, etc) was issued at an inappropriate time.\n    This error is raised when a command like\n    :py:meth:`~AsyncProtocol.connect()` is issued at an inappropriate\n    time.\n    :param error_message: Human-readable string describing the state violation.\n    :param state: The actual `Runstate` seen at the time of the violation.\n    :param required: The `Runstate` required to process this command.\n    \"\"\"",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "AsyncProtocol",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "class AsyncProtocol(Generic[T]):\n    \"\"\"\n    AsyncProtocol implements a generic async message-based protocol.\n    This protocol assumes the basic unit of information transfer between\n    client and server is a \"message\", the details of which are left up\n    to the implementation. It assumes the sending and receiving of these\n    messages is full-duplex and not necessarily correlated; i.e. it\n    supports asynchronous inbound messages.\n    It is designed to be extended by a specific protocol which provides\n    the implementations for how to read and send messages. These must be",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "require",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "def require(required_state: Runstate) -> Callable[[F], F]:\n    \"\"\"\n    Decorator: protect a method so it can only be run in a certain `Runstate`.\n    :param required_state: The `Runstate` required to invoke this method.\n    :raise StateError: When the required `Runstate` is not met.\n    \"\"\"\n    def _decorator(func: F) -> F:\n        # _decorator is the decorator that is built by calling the\n        # require() decorator factory; e.g.:\n        #",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "T = TypeVar('T')\n_U = TypeVar('_U')\n_TaskFN = Callable[[], Awaitable[None]]  # aka ``async def func() -> None``\nInternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "_U",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "_U = TypeVar('_U')\n_TaskFN = Callable[[], Awaitable[None]]  # aka ``async def func() -> None``\nInternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "_TaskFN",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "_TaskFN = Callable[[], Awaitable[None]]  # aka ``async def func() -> None``\nInternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "InternetAddrT",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "InternetAddrT = Tuple[str, int]\nUnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "UnixAddrT",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "UnixAddrT = str\nSocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.\n    RUNNING = 2",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "SocketAddrT",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "SocketAddrT = Union[UnixAddrT, InternetAddrT]\nclass Runstate(Enum):\n    \"\"\"Protocol session runstate.\"\"\"\n    #: Fully quiesced and disconnected.\n    IDLE = 0\n    #: In the process of connecting or establishing a session.\n    CONNECTING = 1\n    #: Fully connected and active session.\n    RUNNING = 2\n    #: In the process of disconnecting.",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.protocol",
        "description": "qemu.python.qemu.qmp.protocol",
        "peekOfCode": "F = TypeVar('F', bound=Callable[..., Any])  # pylint: disable=invalid-name\n# Don't Panic.\ndef require(required_state: Runstate) -> Callable[[F], F]:\n    \"\"\"\n    Decorator: protect a method so it can only be run in a certain `Runstate`.\n    :param required_state: The `Runstate` required to invoke this method.\n    :raise StateError: When the required `Runstate` is not met.\n    \"\"\"\n    def _decorator(func: F) -> F:\n        # _decorator is the decorator that is built by calling the",
        "detail": "qemu.python.qemu.qmp.protocol",
        "documentation": {}
    },
    {
        "label": "_WrappedProtocolError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class _WrappedProtocolError(ProtocolError):\n    \"\"\"\n    Abstract exception class for Protocol errors that wrap an Exception.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\n    def __init__(self, error_message: str, exc: Exception):\n        super().__init__(error_message)\n        self.exc = exc\n    def __str__(self) -> str:",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "GreetingError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class GreetingError(_WrappedProtocolError):\n    \"\"\"\n    An exception occurred during the Greeting phase.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\nclass NegotiationError(_WrappedProtocolError):\n    \"\"\"\n    An exception occurred during the Negotiation phase.\n    :param error_message: Human-readable string describing the error.",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "NegotiationError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class NegotiationError(_WrappedProtocolError):\n    \"\"\"\n    An exception occurred during the Negotiation phase.\n    :param error_message: Human-readable string describing the error.\n    :param exc: The root-cause exception.\n    \"\"\"\nclass ExecuteError(QMPError):\n    \"\"\"\n    Exception raised by `QMPClient.execute()` on RPC failure.\n    :param error_response: The RPC error response object.",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "ExecuteError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class ExecuteError(QMPError):\n    \"\"\"\n    Exception raised by `QMPClient.execute()` on RPC failure.\n    :param error_response: The RPC error response object.\n    :param sent: The sent RPC message that caused the failure.\n    :param received: The raw RPC error reply received.\n    \"\"\"\n    def __init__(self, error_response: ErrorResponse,\n                 sent: Message, received: Message):\n        super().__init__(error_response.error.desc)",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "ExecInterruptedError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class ExecInterruptedError(QMPError):\n    \"\"\"\n    Exception raised by `execute()` (et al) when an RPC is interrupted.\n    This error is raised when an `execute()` statement could not be\n    completed.  This can occur because the connection itself was\n    terminated before a reply was received.\n    The true cause of the interruption will be available via `disconnect()`.\n    \"\"\"\nclass _MsgProtocolError(ProtocolError):\n    \"\"\"",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "_MsgProtocolError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class _MsgProtocolError(ProtocolError):\n    \"\"\"\n    Abstract error class for protocol errors that have a `Message` object.\n    This Exception class is used for protocol errors where the `Message`\n    was mechanically understood, but was found to be inappropriate or\n    malformed.\n    :param error_message: Human-readable string describing the error.\n    :param msg: The QMP `Message` that caused the error.\n    \"\"\"\n    def __init__(self, error_message: str, msg: Message):",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "ServerParseError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class ServerParseError(_MsgProtocolError):\n    \"\"\"\n    The Server sent a `Message` indicating parsing failure.\n    i.e. A reply has arrived from the server, but it is missing the \"ID\"\n    field, indicating a parsing error.\n    :param error_message: Human-readable string describing the error.\n    :param msg: The QMP `Message` that caused the error.\n    \"\"\"\nclass BadReplyError(_MsgProtocolError):\n    \"\"\"",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "BadReplyError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class BadReplyError(_MsgProtocolError):\n    \"\"\"\n    An execution reply was successfully routed, but not understood.\n    If a QMP message is received with an 'id' field to allow it to be\n    routed, but is otherwise malformed, this exception will be raised.\n    A reply message is malformed if it is missing either the 'return' or\n    'error' keys, or if the 'error' value has missing keys or members of\n    the wrong type.\n    :param error_message: Human-readable string describing the error.\n    :param msg: The malformed reply that was received.",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "QMPClient",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_client",
        "description": "qemu.python.qemu.qmp.qmp_client",
        "peekOfCode": "class QMPClient(AsyncProtocol[Message], Events):\n    \"\"\"\n    Implements a QMP client connection.\n    QMP can be used to establish a connection as either the transport\n    client or server, though this class always acts as the QMP client.\n    :param name: Optional nickname for the connection, used for logging.\n    Basic script-style usage looks like this::\n      qmp = QMPClient('my_virtual_machine_name')\n      await qmp.connect(('127.0.0.1', 1234))\n      ...",
        "detail": "qemu.python.qemu.qmp.qmp_client",
        "documentation": {}
    },
    {
        "label": "QMPCompleter",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class QMPCompleter:\n    \"\"\"\n    QMPCompleter provides a readline library tab-complete behavior.\n    \"\"\"\n    # NB: Python 3.9+ will probably allow us to subclass list[str] directly,\n    # but pylint as of today does not know that List[str] is simply 'list'.\n    def __init__(self) -> None:\n        self._matches: List[str] = []\n    def append(self, value: str) -> None:\n        \"\"\"Append a new valid completion to the list of possibilities.\"\"\"",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "QMPShellError",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class QMPShellError(QMPError):\n    \"\"\"\n    QMP Shell Base error class.\n    \"\"\"\nclass FuzzyJSON(ast.NodeTransformer):\n    \"\"\"\n    This extension of ast.NodeTransformer filters literal \"true/false/null\"\n    values in a Python AST and replaces them by proper \"True/False/None\" values\n    that Python can properly evaluate.\n    \"\"\"",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "FuzzyJSON",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class FuzzyJSON(ast.NodeTransformer):\n    \"\"\"\n    This extension of ast.NodeTransformer filters literal \"true/false/null\"\n    values in a Python AST and replaces them by proper \"True/False/None\" values\n    that Python can properly evaluate.\n    \"\"\"\n    @classmethod\n    def visit_Name(cls,  # pylint: disable=invalid-name\n                   node: ast.Name) -> ast.AST:\n        \"\"\"",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "QMPShell",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class QMPShell(QEMUMonitorProtocol):\n    \"\"\"\n    QMPShell provides a basic readline-based QMP shell.\n    :param address: Address of the QMP server.\n    :param pretty: Pretty-print QMP messages.\n    :param verbose: Echo outgoing QMP messages to console.\n    \"\"\"\n    def __init__(self, address: SocketAddrT,\n                 pretty: bool = False,\n                 verbose: bool = False,",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "HMPShell",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "class HMPShell(QMPShell):\n    \"\"\"\n    HMPShell provides a basic readline-based HMP shell, tunnelled via QMP.\n    :param address: Address of the QMP server.\n    :param pretty: Pretty-print QMP messages.\n    :param verbose: Echo outgoing QMP messages to console.\n    \"\"\"\n    def __init__(self, address: SocketAddrT,\n                 pretty: bool = False,\n                 verbose: bool = False,",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "die",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "def die(msg: str) -> NoReturn:\n    \"\"\"Write an error to stderr, then exit with a return code of 1.\"\"\"\n    sys.stderr.write('ERROR: %s\\n' % msg)\n    sys.exit(1)\ndef main() -> None:\n    \"\"\"\n    qmp-shell entry point: parse command line arguments and start the REPL.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-H', '--hmp', action='store_true',",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    qmp-shell entry point: parse command line arguments and start the REPL.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-H', '--hmp', action='store_true',\n                        help='Use HMP interface')\n    parser.add_argument('-N', '--skip-negotiation', action='store_true',\n                        help='Skip negotiate (for qemu-ga)')\n    parser.add_argument('-v', '--verbose', action='store_true',",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "main_wrap",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "def main_wrap() -> None:\n    \"\"\"\n    qmp-shell-wrap entry point: parse command line arguments and\n    start the REPL.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-H', '--hmp', action='store_true',\n                        help='Use HMP interface')\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='Verbose (echo commands sent and received)')",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.qmp_shell",
        "description": "qemu.python.qemu.qmp.qmp_shell",
        "peekOfCode": "LOG = logging.getLogger(__name__)\nclass QMPCompleter:\n    \"\"\"\n    QMPCompleter provides a readline library tab-complete behavior.\n    \"\"\"\n    # NB: Python 3.9+ will probably allow us to subclass list[str] directly,\n    # but pylint as of today does not know that List[str] is simply 'list'.\n    def __init__(self) -> None:\n        self._matches: List[str] = []\n    def append(self, value: str) -> None:",
        "detail": "qemu.python.qemu.qmp.qmp_shell",
        "documentation": {}
    },
    {
        "label": "App",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class App(QMPClient):\n    \"\"\"\n    Implements the QMP TUI.\n    Initializes the widgets and starts the urwid event loop.\n    :param address:\n        Address of the server to connect to.\n    :param num_retries:\n        The number of times to retry before stopping to reconnect.\n    :param retry_delay:\n        The delay(sec) before each retry",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "StatusBar",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class StatusBar(urwid.Text):\n    \"\"\"\n    A simple statusbar modelled using the Text widget. The status can be\n    set using the set_text function. All text set is aligned to right.\n    :param text: Initial text to be displayed. Default is empty str.\n    \"\"\"\n    def __init__(self, text: str = ''):\n        super().__init__(text, align='right')\nclass Editor(urwid_readline.ReadlineEdit):\n    \"\"\"",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "Editor",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class Editor(urwid_readline.ReadlineEdit):\n    \"\"\"\n    A simple editor modelled using the urwid_readline.ReadlineEdit widget.\n    Mimcs GNU readline shortcuts and provides history support.\n    The readline shortcuts can be found below:\n    https://github.com/rr-/urwid_readline#features\n    Along with the readline features, this editor also has support for\n    history. Pressing the 'up'/'down' switches between the prev/next messages\n    available in the history.\n    Currently there is no support to save the history to a file. The history of",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "EditorWidget",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class EditorWidget(urwid.Filler):\n    \"\"\"\n    Wrapper around the editor widget.\n    The Editor is a flow widget and has to wrapped inside a box widget.\n    This class wraps the Editor inside filler widget.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        super().__init__(Editor(parent), valign='top')\nclass HistoryBox(urwid.ListBox):",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "HistoryBox",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class HistoryBox(urwid.ListBox):\n    \"\"\"\n    This widget is modelled using the ListBox widget, contains the list of\n    all messages both QMP messages and log messages to be shown in the TUI.\n    The messages are urwid.Text widgets. On every append of a message, the\n    focus is shifted to the last appended message.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        self.parent = parent",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "HistoryWindow",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class HistoryWindow(urwid.Frame):\n    \"\"\"\n    This window composes the HistoryBox and EditorWidget in a horizontal split.\n    By default the first focus is given to the history box.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        self.parent = parent\n        self.editor_widget = EditorWidget(parent)\n        self.editor = urwid.LineBox(self.editor_widget)",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "Window",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class Window(urwid.Frame):\n    \"\"\"\n    This window is the top most widget of the TUI and will contain other\n    windows. Each child of this widget is responsible for displaying a specific\n    functionality.\n    :param parent: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, parent: App) -> None:\n        self.parent = parent\n        footer = StatusBar()",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "TUILogHandler",
        "kind": 6,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "class TUILogHandler(Handler):\n    \"\"\"\n    This handler routes all the log messages to the TUI screen.\n    It is installed to the root logger to so that the log message from all\n    libraries begin used is routed to the screen.\n    :param tui: Reference to the TUI object.\n    \"\"\"\n    def __init__(self, tui: App) -> None:\n        super().__init__()\n        self.tui = tui",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "format_json",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "def format_json(msg: str) -> str:\n    \"\"\"\n    Formats valid/invalid multi-line JSON message into a single-line message.\n    Formatting is first tried using the standard json module. If that fails\n    due to an decoding error then a simple string manipulation is done to\n    achieve a single line JSON string.\n    Converting into single line is more aesthetically pleasing when looking\n    along with error messages.\n    Eg:\n    Input:",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "has_handler_type",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "def has_handler_type(logger: logging.Logger,\n                     handler_type: Type[Handler]) -> bool:\n    \"\"\"\n    The Logger class has no interface to check if a certain type of handler is\n    installed or not. So we provide an interface to do so.\n    :param logger:\n        Logger object\n    :param handler_type:\n        The type of the handler to be checked.\n    :return: returns True if handler of type `handler_type`.",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    Driver of the whole script, parses arguments, initialize the TUI and\n    the logger.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='QMP TUI')\n    parser.add_argument('qmp_server', help='Address of the QMP server. '\n                        'Format <UNIX socket path | TCP addr:port>')\n    parser.add_argument('--num-retries', type=int, default=10,\n                        help='Number of times to reconnect before giving up.')",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "palette",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.qmp_tui",
        "description": "qemu.python.qemu.qmp.qmp_tui",
        "peekOfCode": "palette = [\n    (Token.Punctuation, '', '', '', 'h15,bold', 'g7'),\n    (Token.Text, '', '', '', '', 'g7'),\n    (Token.Name.Tag, '', '', '', 'bold,#f88', 'g7'),\n    (Token.Literal.Number.Integer, '', '', '', '#fa0', 'g7'),\n    (Token.Literal.String.Double, '', '', '', '#6f6', 'g7'),\n    (Token.Keyword.Constant, '', '', '', '#6af', 'g7'),\n    ('DEBUG', '', '', '', '#ddf', 'g7'),\n    ('INFO', '', '', '', 'g100', 'g7'),\n    ('WARNING', '', '', '', '#ff6', 'g7'),",
        "detail": "qemu.python.qemu.qmp.qmp_tui",
        "documentation": {}
    },
    {
        "label": "upper_half",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "def upper_half(func: T) -> T:\n    \"\"\"\n    Do-nothing decorator that annotates a method as an \"upper-half\" method.\n    These methods must not call bottom-half functions directly, but can\n    schedule them to run.\n    \"\"\"\n    return func\ndef bottom_half(func: T) -> T:\n    \"\"\"\n    Do-nothing decorator that annotates a method as a \"bottom-half\" method.",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "bottom_half",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "def bottom_half(func: T) -> T:\n    \"\"\"\n    Do-nothing decorator that annotates a method as a \"bottom-half\" method.\n    These methods must take great care to handle their own exceptions whenever\n    possible. If they go unhandled, they will cause termination of the loop.\n    These methods do not, in general, have the ability to directly\n    report information to a callers context and will usually be\n    collected as a Task result instead.\n    They must not call upper-half functions directly.\n    \"\"\"",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "create_task",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "def create_task(coro: Coroutine[Any, Any, T],\n                loop: Optional[asyncio.AbstractEventLoop] = None\n                ) -> 'asyncio.Future[T]':\n    \"\"\"\n    Python 3.6-compatible `asyncio.create_task` wrapper.\n    :param coro: The coroutine to execute in a task.\n    :param loop: Optionally, the loop to create the task in.\n    :return: An `asyncio.Future` object.\n    \"\"\"\n    if sys.version_info >= (3, 7):",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "is_closing",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "def is_closing(writer: asyncio.StreamWriter) -> bool:\n    \"\"\"\n    Python 3.6-compatible `asyncio.StreamWriter.is_closing` wrapper.\n    :param writer: The `asyncio.StreamWriter` object.\n    :return: `True` if the writer is closing, or closed.\n    \"\"\"\n    if sys.version_info >= (3, 7):\n        return writer.is_closing()\n    # Python 3.6:\n    transport = writer.transport",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "asyncio_run",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "def asyncio_run(coro: Coroutine[Any, Any, T], *, debug: bool = False) -> T:\n    \"\"\"\n    Python 3.6-compatible `asyncio.run` wrapper.\n    :param coro: A coroutine to execute now.\n    :return: The return value from the coroutine.\n    \"\"\"\n    if sys.version_info >= (3, 7):\n        return asyncio.run(coro, debug=debug)\n    # Python 3.6\n    loop = asyncio.get_event_loop()",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "exception_summary",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "def exception_summary(exc: BaseException) -> str:\n    \"\"\"\n    Return a summary string of an arbitrary exception.\n    It will be of the form \"ExceptionType: Error Message\", if the error\n    string is non-empty, and just \"ExceptionType\" otherwise.\n    \"\"\"\n    name = type(exc).__qualname__\n    smod = type(exc).__module__\n    if smod not in (\"__main__\", \"builtins\"):\n        name = smod + '.' + name",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "pretty_traceback",
        "kind": 2,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "def pretty_traceback(prefix: str = \"  | \") -> str:\n    \"\"\"\n    Formats the current traceback, indented to provide visual distinction.\n    This is useful for printing a traceback within a traceback for\n    debugging purposes when encapsulating errors to deliver them up the\n    stack; when those errors are printed, this helps provide a nice\n    visual grouping to quickly identify the parts of the error that\n    belong to the inner exception.\n    :param prefix: The prefix to append to each line of the traceback.\n    :return: A string, formatted something like the following::",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.python.qemu.qmp.util",
        "description": "qemu.python.qemu.qmp.util",
        "peekOfCode": "T = TypeVar('T')\n# --------------------------\n# Section: Utility Functions\n# --------------------------\nasync def flush(writer: asyncio.StreamWriter) -> None:\n    \"\"\"\n    Utility function to ensure a StreamWriter is *fully* drained.\n    `asyncio.StreamWriter.drain` only promises we will return to below\n    the \"high-water mark\". This function ensures we flush the entire\n    buffer -- by setting the high water mark to 0 and then calling",
        "detail": "qemu.python.qemu.qmp.util",
        "documentation": {}
    },
    {
        "label": "list_accel",
        "kind": 2,
        "importPath": "qemu.python.qemu.utils.accel",
        "description": "qemu.python.qemu.utils.accel",
        "peekOfCode": "def list_accel(qemu_bin: str) -> List[str]:\n    \"\"\"\n    List accelerators enabled in the QEMU binary.\n    @param qemu_bin (str): path to the QEMU binary.\n    @raise Exception: if failed to run ``qemu -accel help``\n    @return a list of accelerator names.\n    \"\"\"\n    if not qemu_bin:\n        return []\n    try:",
        "detail": "qemu.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "kvm_available",
        "kind": 2,
        "importPath": "qemu.python.qemu.utils.accel",
        "description": "qemu.python.qemu.utils.accel",
        "peekOfCode": "def kvm_available(target_arch: Optional[str] = None,\n                  qemu_bin: Optional[str] = None) -> bool:\n    \"\"\"\n    Check if KVM is available using the following heuristic:\n      - Kernel module is present in the host;\n      - Target and host arches don't mismatch;\n      - KVM is enabled in the QEMU binary.\n    @param target_arch (str): target architecture\n    @param qemu_bin (str): path to the QEMU binary\n    @return True if kvm is available, otherwise False.",
        "detail": "qemu.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "tcg_available",
        "kind": 2,
        "importPath": "qemu.python.qemu.utils.accel",
        "description": "qemu.python.qemu.utils.accel",
        "peekOfCode": "def tcg_available(qemu_bin: str) -> bool:\n    \"\"\"\n    Check if TCG is available.\n    @param qemu_bin (str): path to the QEMU binary\n    \"\"\"\n    return 'tcg' in list_accel(qemu_bin)",
        "detail": "qemu.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "LOG",
        "kind": 5,
        "importPath": "qemu.python.qemu.utils.accel",
        "description": "qemu.python.qemu.utils.accel",
        "peekOfCode": "LOG = logging.getLogger(__name__)\n# Mapping host architecture to any additional architectures it can\n# support which often includes its 32 bit cousin.\nADDITIONAL_ARCHES = {\n    \"x86_64\": \"i386\",\n    \"aarch64\": \"armhf\",\n    \"ppc64le\": \"ppc64\",\n}\ndef list_accel(qemu_bin: str) -> List[str]:\n    \"\"\"",
        "detail": "qemu.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "ADDITIONAL_ARCHES",
        "kind": 5,
        "importPath": "qemu.python.qemu.utils.accel",
        "description": "qemu.python.qemu.utils.accel",
        "peekOfCode": "ADDITIONAL_ARCHES = {\n    \"x86_64\": \"i386\",\n    \"aarch64\": \"armhf\",\n    \"ppc64le\": \"ppc64\",\n}\ndef list_accel(qemu_bin: str) -> List[str]:\n    \"\"\"\n    List accelerators enabled in the QEMU binary.\n    @param qemu_bin (str): path to the QEMU binary.\n    @raise Exception: if failed to run ``qemu -accel help``",
        "detail": "qemu.python.qemu.utils.accel",
        "documentation": {}
    },
    {
        "label": "QemuGuestAgent",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qemu_ga_client",
        "description": "qemu.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "class QemuGuestAgent(QEMUMonitorProtocol):\n    def __getattr__(self, name: str) -> Callable[..., Any]:\n        def wrapper(**kwds: object) -> object:\n            return self.cmd('guest-' + name.replace('_', '-'), **kwds)\n        return wrapper\nclass QemuGuestAgentClient:\n    def __init__(self, address: SocketAddrT):\n        self.qga = QemuGuestAgent(address)\n        self.qga.connect(negotiate=False)\n    def sync(self, timeout: Optional[float] = 3) -> None:",
        "detail": "qemu.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "QemuGuestAgentClient",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qemu_ga_client",
        "description": "qemu.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "class QemuGuestAgentClient:\n    def __init__(self, address: SocketAddrT):\n        self.qga = QemuGuestAgent(address)\n        self.qga.connect(negotiate=False)\n    def sync(self, timeout: Optional[float] = 3) -> None:\n        # Avoid being blocked forever\n        if not self.ping(timeout):\n            raise EnvironmentError('Agent seems not alive')\n        uid = random.randint(0, (1 << 32) - 1)\n        while True:",
        "detail": "qemu.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "send_command",
        "kind": 2,
        "importPath": "qemu.python.qemu.utils.qemu_ga_client",
        "description": "qemu.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "def send_command(address: str, cmd: str, args: Sequence[str]) -> None:\n    if not os.path.exists(address):\n        print(f\"'{address}' not found. (Is QEMU running?)\")\n        sys.exit(1)\n    if cmd not in commands:\n        print('Invalid command: ' + cmd)\n        print('Available commands: ' + ', '.join(commands))\n        sys.exit(1)\n    try:\n        client = QemuGuestAgentClient(address)",
        "detail": "qemu.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.python.qemu.utils.qemu_ga_client",
        "description": "qemu.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "def main() -> None:\n    address = os.environ.get('QGA_CLIENT_ADDRESS')\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--address', action='store',\n                        default=address,\n                        help='Specify a ip:port pair or a unix socket path')\n    parser.add_argument('command', choices=commands)\n    parser.add_argument('args', nargs='*')\n    args = parser.parse_args()\n    if args.address is None:",
        "detail": "qemu.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "_cmd_powerdown",
        "kind": 5,
        "importPath": "qemu.python.qemu.utils.qemu_ga_client",
        "description": "qemu.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "_cmd_powerdown = _cmd_shutdown\ndef _cmd_halt(client: QemuGuestAgentClient, args: Sequence[str]) -> None:\n    assert not args\n    client.shutdown('halt')\ndef _cmd_reboot(client: QemuGuestAgentClient, args: Sequence[str]) -> None:\n    assert not args\n    client.shutdown('reboot')\ncommands = [m.replace('_cmd_', '') for m in dir() if '_cmd_' in m]\ndef send_command(address: str, cmd: str, args: Sequence[str]) -> None:\n    if not os.path.exists(address):",
        "detail": "qemu.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "commands",
        "kind": 5,
        "importPath": "qemu.python.qemu.utils.qemu_ga_client",
        "description": "qemu.python.qemu.utils.qemu_ga_client",
        "peekOfCode": "commands = [m.replace('_cmd_', '') for m in dir() if '_cmd_' in m]\ndef send_command(address: str, cmd: str, args: Sequence[str]) -> None:\n    if not os.path.exists(address):\n        print(f\"'{address}' not found. (Is QEMU running?)\")\n        sys.exit(1)\n    if cmd not in commands:\n        print('Invalid command: ' + cmd)\n        print('Available commands: ' + ', '.join(commands))\n        sys.exit(1)\n    try:",
        "detail": "qemu.python.qemu.utils.qemu_ga_client",
        "documentation": {}
    },
    {
        "label": "QOMSet",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qom",
        "description": "qemu.python.qemu.utils.qom",
        "peekOfCode": "class QOMSet(QOMCommand):\n    \"\"\"\n    QOM Command - Set a property to a given value.\n    usage: qom-set [-h] [--socket SOCKET] <path>.<property> <value>\n    Set a QOM property value\n    positional arguments:\n      <path>.<property>     QOM path and property, separated by a period '.'\n      <value>               new QOM property value\n    optional arguments:\n      -h, --help            show this help message and exit",
        "detail": "qemu.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "QOMGet",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qom",
        "description": "qemu.python.qemu.utils.qom",
        "peekOfCode": "class QOMGet(QOMCommand):\n    \"\"\"\n    QOM Command - Get a property's current value.\n    usage: qom-get [-h] [--socket SOCKET] <path>.<property>\n    Get a QOM property value\n    positional arguments:\n      <path>.<property>     QOM path and property, separated by a period '.'\n    optional arguments:\n      -h, --help            show this help message and exit\n      --socket SOCKET, -s SOCKET",
        "detail": "qemu.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "QOMList",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qom",
        "description": "qemu.python.qemu.utils.qom",
        "peekOfCode": "class QOMList(QOMCommand):\n    \"\"\"\n    QOM Command - List the properties at a given path.\n    usage: qom-list [-h] [--socket SOCKET] <path>\n    List QOM properties at a given path\n    positional arguments:\n      <path>                QOM path\n    optional arguments:\n      -h, --help            show this help message and exit\n      --socket SOCKET, -s SOCKET",
        "detail": "qemu.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "QOMTree",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qom",
        "description": "qemu.python.qemu.utils.qom",
        "peekOfCode": "class QOMTree(QOMCommand):\n    \"\"\"\n    QOM Command - Show the full tree below a given path.\n    usage: qom-tree [-h] [--socket SOCKET] [<path>]\n    Show QOM tree from a given path\n    positional arguments:\n      <path>                QOM path\n    optional arguments:\n      -h, --help            show this help message and exit\n      --socket SOCKET, -s SOCKET",
        "detail": "qemu.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.python.qemu.utils.qom",
        "description": "qemu.python.qemu.utils.qom",
        "peekOfCode": "def main() -> int:\n    \"\"\"QOM script main entry point.\"\"\"\n    parser = argparse.ArgumentParser(\n        description='Query and manipulate QOM data'\n    )\n    subparsers = parser.add_subparsers(\n        title='QOM commands',\n        dest='command'\n    )\n    for command in QOMCommand.__subclasses__():",
        "detail": "qemu.python.qemu.utils.qom",
        "documentation": {}
    },
    {
        "label": "ObjectPropertyInfo",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qom_common",
        "description": "qemu.python.qemu.utils.qom_common",
        "peekOfCode": "class ObjectPropertyInfo:\n    \"\"\"\n    Represents the return type from e.g. qom-list.\n    \"\"\"\n    def __init__(self, name: str, type_: str,\n                 description: Optional[str] = None,\n                 default_value: Optional[object] = None):\n        self.name = name\n        self.type = type_\n        self.description = description",
        "detail": "qemu.python.qemu.utils.qom_common",
        "documentation": {}
    },
    {
        "label": "QOMCommand",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qom_common",
        "description": "qemu.python.qemu.utils.qom_common",
        "peekOfCode": "class QOMCommand:\n    \"\"\"\n    Represents a QOM sub-command.\n    :param args: Parsed arguments, as returned from parser.parse_args.\n    \"\"\"\n    name: str\n    help: str\n    def __init__(self, args: argparse.Namespace):\n        if args.socket is None:\n            raise QMPError(\"No QMP socket path or address given\")",
        "detail": "qemu.python.qemu.utils.qom_common",
        "documentation": {}
    },
    {
        "label": "CommandT",
        "kind": 5,
        "importPath": "qemu.python.qemu.utils.qom_common",
        "description": "qemu.python.qemu.utils.qom_common",
        "peekOfCode": "CommandT = TypeVar('CommandT', bound='QOMCommand')\nclass QOMCommand:\n    \"\"\"\n    Represents a QOM sub-command.\n    :param args: Parsed arguments, as returned from parser.parse_args.\n    \"\"\"\n    name: str\n    help: str\n    def __init__(self, args: argparse.Namespace):\n        if args.socket is None:",
        "detail": "qemu.python.qemu.utils.qom_common",
        "documentation": {}
    },
    {
        "label": "QOMFuse",
        "kind": 6,
        "importPath": "qemu.python.qemu.utils.qom_fuse",
        "description": "qemu.python.qemu.utils.qom_fuse",
        "peekOfCode": "class QOMFuse(QOMCommand, Operations):\n    \"\"\"\n    QOMFuse implements both fuse.Operations and QOMCommand.\n    Operations implements the FS, and QOMCommand implements the CLI command.\n    \"\"\"\n    name = 'fuse'\n    help = 'Mount a QOM tree as a FUSE filesystem'\n    fuse: FUSE\n    @classmethod\n    def configure_parser(cls, parser: argparse.ArgumentParser) -> None:",
        "detail": "qemu.python.qemu.utils.qom_fuse",
        "documentation": {}
    },
    {
        "label": "fuse.fuse_python_api",
        "kind": 5,
        "importPath": "qemu.python.qemu.utils.qom_fuse",
        "description": "qemu.python.qemu.utils.qom_fuse",
        "peekOfCode": "fuse.fuse_python_api = (0, 2)\nclass QOMFuse(QOMCommand, Operations):\n    \"\"\"\n    QOMFuse implements both fuse.Operations and QOMCommand.\n    Operations implements the FS, and QOMCommand implements the CLI command.\n    \"\"\"\n    name = 'fuse'\n    help = 'Mount a QOM tree as a FUSE filesystem'\n    fuse: FUSE\n    @classmethod",
        "detail": "qemu.python.qemu.utils.qom_fuse",
        "documentation": {}
    },
    {
        "label": "Ouch",
        "kind": 6,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "class Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual\n    environment when invoked from inside of an existing virtual\n    environment by including packages from the parent.  Also,\n    \"ensurepip\" is replaced if possible with just recreating pip's\n    console_scripts inside the virtual environment.",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "QemuEnvBuilder",
        "kind": 6,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "class QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual\n    environment when invoked from inside of an existing virtual\n    environment by including packages from the parent.  Also,\n    \"ensurepip\" is replaced if possible with just recreating pip's\n    console_scripts inside the virtual environment.\n    Parameters for base class init:\n      - system_site_packages: bool = False",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "inside_a_venv",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def inside_a_venv() -> bool:\n    \"\"\"Returns True if it is executed inside of a virtual environment.\"\"\"\n    return sys.prefix != sys.base_prefix\nclass Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual\n    environment when invoked from inside of an existing virtual",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "need_ensurepip",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def need_ensurepip() -> bool:\n    \"\"\"\n    Tests for the presence of setuptools and pip.\n    :return: `True` if we do not detect both packages.\n    \"\"\"\n    # Don't try to actually import them, it's fraught with danger:\n    # https://github.com/pypa/setuptools/issues/2993\n    if find_spec(\"setuptools\") and find_spec(\"pip\"):\n        return False\n    return True",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "check_ensurepip",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def check_ensurepip() -> None:\n    \"\"\"\n    Check that we have ensurepip.\n    Raise a fatal exception with a helpful hint if it isn't available.\n    \"\"\"\n    if not find_spec(\"ensurepip\"):\n        msg = (\n            \"Python's ensurepip module is not found.\\n\"\n            \"It's normally part of the Python standard library, \"\n            \"maybe your distribution packages it separately?\\n\"",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "make_venv",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def make_venv(  # pylint: disable=too-many-arguments\n    env_dir: Union[str, Path],\n    system_site_packages: bool = False,\n    clear: bool = True,\n    symlinks: Optional[bool] = None,\n    with_pip: bool = True,\n) -> None:\n    \"\"\"\n    Create a venv using `QemuEnvBuilder`.\n    This is analogous to the `venv.create` module-level convenience",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "generate_console_scripts",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def generate_console_scripts(\n    packages: Sequence[str],\n    python_path: Optional[str] = None,\n    bin_path: Optional[str] = None,\n) -> None:\n    \"\"\"\n    Generate script shims for console_script entry points in @packages.\n    \"\"\"\n    if python_path is None:\n        python_path = sys.executable",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "pkgname_from_depspec",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def pkgname_from_depspec(dep_spec: str) -> str:\n    \"\"\"\n    Parse package name out of a PEP-508 depspec.\n    See https://peps.python.org/pep-0508/#names\n    \"\"\"\n    match = re.match(\n        r\"^([A-Z0-9]([A-Z0-9._-]*[A-Z0-9])?)\", dep_spec, re.IGNORECASE\n    )\n    if not match:\n        raise ValueError(",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "diagnose",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def diagnose(\n    dep_spec: str,\n    online: bool,\n    wheels_dir: Optional[Union[str, Path]],\n    prog: Optional[str],\n) -> Tuple[str, bool]:\n    \"\"\"\n    Offer a summary to the user as to why a package failed to be installed.\n    :param dep_spec: The package we tried to ensure, e.g. 'meson>=0.61.5'\n    :param online: Did we allow PyPI access?",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "pip_install",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def pip_install(\n    args: Sequence[str],\n    online: bool = False,\n    wheels_dir: Optional[Union[str, Path]] = None,\n) -> None:\n    \"\"\"\n    Use pip to install a package or package(s) as specified in @args.\n    \"\"\"\n    loud = bool(\n        os.environ.get(\"DEBUG\")",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "ensure_group",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def ensure_group(\n    file: str,\n    groups: Sequence[str],\n    online: bool = False,\n    wheels_dir: Optional[Union[str, Path]] = None,\n) -> None:\n    \"\"\"\n    Use pip to ensure we have the package specified by @dep_specs.\n    If the package is already installed, do nothing. If online and\n    wheels_dir are both provided, prefer packages found in wheels_dir",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "post_venv_setup",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def post_venv_setup() -> None:\n    \"\"\"\n    This is intended to be run *inside the venv* after it is created.\n    \"\"\"\n    logger.debug(\"post_venv_setup()\")\n    # Generate a 'pip' script so the venv is usable in a normal\n    # way from the CLI. This only happens when we inherited pip from a\n    # parent/system-site and haven't run ensurepip in some way.\n    generate_console_scripts([\"pip\"])\ndef _add_create_subcommand(subparsers: Any) -> None:",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "def main() -> int:\n    \"\"\"CLI interface to make_qemu_venv. See module docstring.\"\"\"\n    if os.environ.get(\"DEBUG\") or os.environ.get(\"GITLAB_CI\"):\n        # You're welcome.\n        logging.basicConfig(level=logging.DEBUG)\n    else:\n        if os.environ.get(\"V\"):\n            logging.basicConfig(level=logging.INFO)\n    parser = argparse.ArgumentParser(\n        prog=\"mkvenv\",",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "HAVE_DISTLIB",
        "kind": 5,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "HAVE_DISTLIB = True\ntry:\n    import distlib.scripts\n    import distlib.version\nexcept ImportError:\n    try:\n        # Reach into pip's cookie jar.  pylint and flake8 don't understand\n        # that these imports will be used via distlib.xxx.\n        from pip._vendor import distlib\n        import pip._vendor.distlib.scripts  # noqa, pylint: disable=unused-import",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "HAVE_TOMLLIB",
        "kind": 5,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "HAVE_TOMLLIB = True\ntry:\n    import tomllib\nexcept ImportError:\n    try:\n        import tomli as tomllib\n    except ImportError:\n        HAVE_TOMLLIB = False\n# Do not add any mandatory dependencies from outside the stdlib:\n# This script *must* be usable standalone!",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "DirType",
        "kind": 5,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "DirType = Union[str, bytes, \"os.PathLike[str]\", \"os.PathLike[bytes]\"]\nlogger = logging.getLogger(\"mkvenv\")\ndef inside_a_venv() -> bool:\n    \"\"\"Returns True if it is executed inside of a virtual environment.\"\"\"\n    return sys.prefix != sys.base_prefix\nclass Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.python.scripts.mkvenv",
        "description": "qemu.python.scripts.mkvenv",
        "peekOfCode": "logger = logging.getLogger(\"mkvenv\")\ndef inside_a_venv() -> bool:\n    \"\"\"Returns True if it is executed inside of a virtual environment.\"\"\"\n    return sys.prefix != sys.base_prefix\nclass Ouch(RuntimeError):\n    \"\"\"An Exception class we can't confuse with a builtin.\"\"\"\nclass QemuEnvBuilder(venv.EnvBuilder):\n    \"\"\"\n    An extension of venv.EnvBuilder for building QEMU's configure-time venv.\n    The primary difference is that it emulates a \"nested\" virtual",
        "detail": "qemu.python.scripts.mkvenv",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.python.scripts.vendor",
        "description": "qemu.python.scripts.vendor",
        "peekOfCode": "def main() -> int:\n    \"\"\"Run the vendoring utility. See module-level docstring.\"\"\"\n    loud = False\n    if os.environ.get(\"DEBUG\") or os.environ.get(\"V\"):\n        loud = True\n    # No options or anything for now, but I guess\n    # you'll figure that out when you run --help.\n    parser = argparse.ArgumentParser(\n        prog=\"vendor\",\n        description=\"QEMU python vendoring utility\",",
        "detail": "qemu.python.scripts.vendor",
        "documentation": {}
    },
    {
        "label": "NullProtocol",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class NullProtocol(AsyncProtocol[None]):\n    \"\"\"\n    NullProtocol is a test mockup of an AsyncProtocol implementation.\n    It adds a fake_session instance variable that enables a code path\n    that bypasses the actual connection logic, but still allows the\n    reader/writers to start.\n    Because the message type is defined as None, an asyncio.Event named\n    'trigger_input' is created that prohibits the reader from\n    incessantly being able to yield None; this event can be poked to\n    simulate an incoming message.",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "LineProtocol",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class LineProtocol(AsyncProtocol[str]):\n    def __init__(self, name=None):\n        super().__init__(name)\n        self.rx_history = []\n    async def _do_recv(self) -> str:\n        raw = await self._readline()\n        msg = raw.decode()\n        self.rx_history.append(msg)\n        return msg\n    def _do_send(self, msg: str) -> None:",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "Smoke",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class Smoke(avocado.Test):\n    def setUp(self):\n        self.proto = NullProtocol()\n    def test__repr__(self):\n        self.assertEqual(\n            repr(self.proto),\n            \"<NullProtocol runstate=IDLE>\"\n        )\n    def testRunstate(self):\n        self.assertEqual(",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "TestBase",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class TestBase(avocado.Test):\n    def setUp(self):\n        self.proto = NullProtocol(type(self).__name__)\n        self.assertEqual(self.proto.runstate, Runstate.IDLE)\n        self.runstate_watcher = None\n    def tearDown(self):\n        self.assertEqual(self.proto.runstate, Runstate.IDLE)\n    async def _asyncSetUp(self):\n        pass\n    async def _asyncTearDown(self):",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class State(TestBase):\n    @TestBase.async_test\n    async def testSuperfluousDisconnect(self):\n        \"\"\"\n        Test calling disconnect() while already disconnected.\n        \"\"\"\n        await self._watch_runstates(\n            Runstate.DISCONNECTING,\n            Runstate.IDLE,\n        )",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "Connect",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class Connect(TestBase):\n    \"\"\"\n    Tests primarily related to calling Connect().\n    \"\"\"\n    async def _bad_connection(self, family: str):\n        assert family in ('INET', 'UNIX')\n        if family == 'INET':\n            await self.proto.connect(('127.0.0.1', 0))\n        elif family == 'UNIX':\n            await self.proto.connect('/dev/null')",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "Accept",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class Accept(Connect):\n    \"\"\"\n    All of the same tests as Connect, but using the accept() interface.\n    \"\"\"\n    async def _bad_connection(self, family: str):\n        assert family in ('INET', 'UNIX')\n        if family == 'INET':\n            await self.proto.start_server_and_accept(('example.com', 1))\n        elif family == 'UNIX':\n            await self.proto.start_server_and_accept('/dev/null')",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "FakeSession",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class FakeSession(TestBase):\n    def setUp(self):\n        super().setUp()\n        self.proto.fake_session = True\n    async def _asyncSetUp(self):\n        await super()._asyncSetUp()\n        await self._watch_runstates(*self.GOOD_CONNECTION_STATES)\n    async def _asyncTearDown(self):\n        await self.proto.disconnect()\n        await super()._asyncTearDown()",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "SimpleSession",
        "kind": 6,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "class SimpleSession(TestBase):\n    def setUp(self):\n        super().setUp()\n        self.server = LineProtocol(type(self).__name__ + '-server')\n    async def _asyncSetUp(self):\n        await super()._asyncSetUp()\n        await self._watch_runstates(*self.GOOD_CONNECTION_STATES)\n    async def _asyncTearDown(self):\n        await self.proto.disconnect()\n        try:",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "run_as_task",
        "kind": 2,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "def run_as_task(coro, allow_cancellation=False):\n    \"\"\"\n    Run a given coroutine as a task.\n    Optionally, wrap it in a try..except block that allows this\n    coroutine to be canceled gracefully.\n    \"\"\"\n    async def _runner():\n        try:\n            await coro\n        except asyncio.CancelledError:",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "jammed_socket",
        "kind": 2,
        "importPath": "qemu.python.tests.protocol",
        "description": "qemu.python.tests.protocol",
        "peekOfCode": "def jammed_socket():\n    \"\"\"\n    Opens up a random unused TCP port on localhost, then jams it.\n    \"\"\"\n    socks = []\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind(('127.0.0.1', 0))\n        sock.listen(1)",
        "detail": "qemu.python.tests.protocol",
        "documentation": {}
    },
    {
        "label": "bdist_egg_guard",
        "kind": 6,
        "importPath": "qemu.python.setup",
        "description": "qemu.python.setup",
        "peekOfCode": "class bdist_egg_guard(bdist_egg.bdist_egg):\n    \"\"\"\n    Protect against bdist_egg from being executed\n    This prevents calling 'setup.py install' directly, as the 'install'\n    CLI option will invoke the deprecated bdist_egg hook. \"pip install\"\n    calls the more modern bdist_wheel hook, which is what we want.\n    \"\"\"\n    def run(self):\n        sys.exit(\n            'Installation directly via setup.py is not supported.\\n'",
        "detail": "qemu.python.setup",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.python.setup",
        "description": "qemu.python.setup",
        "peekOfCode": "def main():\n    \"\"\"\n    QEMU tooling installer\n    \"\"\"\n    # https://medium.com/@daveshawley/safely-using-setup-cfg-for-metadata-1babbe54c108\n    pkg_resources.require('setuptools>=39.2')\n    setuptools.setup(cmdclass={'bdist_egg': bdist_egg_guard})\nif __name__ == '__main__':\n    main()",
        "detail": "qemu.python.setup",
        "documentation": {}
    },
    {
        "label": "check_rebase",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def check_rebase():\n    \"\"\" detect 'git rebase -x edk2-build.py master' testbuilds \"\"\"\n    global rebase_prefix\n    global version_override\n    gitdir = '.git'\n    if os.path.isfile(gitdir):\n        with open(gitdir, 'r', encoding = 'utf-8') as f:\n            (unused, gitdir) = f.read().split()\n    if not os.path.exists(f'{gitdir}/rebase-merge/msgnum'):\n        return",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "get_coredir",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def get_coredir(cfg):\n    if cfg.has_option('global', 'core'):\n        return os.path.abspath(cfg['global']['core'])\n    return os.getcwd()\ndef get_toolchain(cfg, build):\n    if cfg.has_option(build, 'tool'):\n        return cfg[build]['tool']\n    if cfg.has_option('global', 'tool'):\n        return cfg['global']['tool']\n    return 'GCC5'",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "get_toolchain",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def get_toolchain(cfg, build):\n    if cfg.has_option(build, 'tool'):\n        return cfg[build]['tool']\n    if cfg.has_option('global', 'tool'):\n        return cfg['global']['tool']\n    return 'GCC5'\ndef get_version(cfg, silent = False):\n    coredir = get_coredir(cfg)\n    if version_override:\n        version = version_override",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "get_version",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def get_version(cfg, silent = False):\n    coredir = get_coredir(cfg)\n    if version_override:\n        version = version_override\n        if not silent:\n            print('')\n            print(f'### version [override]: {version}')\n        return version\n    if os.environ.get('RPM_PACKAGE_NAME'):\n        version = os.environ.get('RPM_PACKAGE_NAME')",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "pcd_string",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def pcd_string(name, value):\n    return f'{name}=L{value}\\\\0'\ndef pcd_version(cfg, silent = False):\n    version = get_version(cfg, silent)\n    if version is None:\n        return []\n    return [ '--pcd', pcd_string('PcdFirmwareVersionString', version) ]\ndef pcd_release_date():\n    if release_date is None:\n        return []",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "pcd_version",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def pcd_version(cfg, silent = False):\n    version = get_version(cfg, silent)\n    if version is None:\n        return []\n    return [ '--pcd', pcd_string('PcdFirmwareVersionString', version) ]\ndef pcd_release_date():\n    if release_date is None:\n        return []\n    return [ '--pcd', pcd_string('PcdFirmwareReleaseDateString', release_date) ]\ndef build_message(line, line2 = None, silent = False):",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "pcd_release_date",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def pcd_release_date():\n    if release_date is None:\n        return []\n    return [ '--pcd', pcd_string('PcdFirmwareReleaseDateString', release_date) ]\ndef build_message(line, line2 = None, silent = False):\n    if os.environ.get('TERM') in [ 'xterm', 'xterm-256color' ]:\n        # setxterm  title\n        start  = '\\x1b]2;'\n        end    = '\\x07'\n        print(f'{start}{rebase_prefix}{line}{end}', end = '')",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "build_message",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def build_message(line, line2 = None, silent = False):\n    if os.environ.get('TERM') in [ 'xterm', 'xterm-256color' ]:\n        # setxterm  title\n        start  = '\\x1b]2;'\n        end    = '\\x07'\n        print(f'{start}{rebase_prefix}{line}{end}', end = '')\n    if silent:\n        print(f'### {rebase_prefix}{line}', flush = True)\n    else:\n        print('')",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "build_run",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def build_run(cmdline, name, section, silent = False, nologs = False):\n    if silent:\n        logfile = f'{section}.log'\n        if nologs:\n            print(f'### building in silent mode [no log] ...', flush = True)\n        else:\n            print(f'### building in silent mode [{logfile}] ...', flush = True)\n        start = time.time()\n        result = subprocess.run(cmdline, check = False,\n                                stdout = subprocess.PIPE,",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "build_copy",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def build_copy(plat, tgt, toolchain, dstdir, copy):\n    srcdir = f'Build/{plat}/{tgt}_{toolchain}'\n    names = copy.split()\n    srcfile = names[0]\n    if len(names) > 1:\n        dstfile = names[1]\n    else:\n        dstfile = os.path.basename(srcfile)\n    print(f'# copy: {srcdir} / {srcfile}  =>  {dstdir} / {dstfile}')\n    src = srcdir + '/' + srcfile",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "pad_file",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def pad_file(dstdir, pad):\n    args = pad.split()\n    if len(args) < 2:\n        raise RuntimeError(f'missing arg for pad ({args})')\n    name = args[0]\n    size = args[1]\n    cmdline = [\n        'truncate',\n        '--size', size,\n        dstdir + '/' + name,",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "build_one",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def build_one(cfg, build, jobs = None, silent = False, nologs = False):\n    b = cfg[build]\n    cmdline  = [ 'build' ]\n    cmdline += [ '-t', get_toolchain(cfg, build) ]\n    cmdline += [ '-p', b['conf'] ]\n    if (b['conf'].startswith('OvmfPkg/') or\n        b['conf'].startswith('ArmVirtPkg/')):\n        cmdline += pcd_version(cfg, silent)\n        cmdline += pcd_release_date()\n    if jobs:",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "build_basetools",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def build_basetools(silent = False, nologs = False):\n    build_message('building: BaseTools', silent = silent)\n    basedir = os.environ['EDK_TOOLS_PATH']\n    cmdline = [ 'make', '-C', basedir ]\n    build_run(cmdline, 'BaseTools', 'build.basetools', silent, nologs)\ndef binary_exists(name):\n    for pdir in os.environ['PATH'].split(':'):\n        if os.path.exists(pdir + '/' + name):\n            return True\n    return False",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "binary_exists",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def binary_exists(name):\n    for pdir in os.environ['PATH'].split(':'):\n        if os.path.exists(pdir + '/' + name):\n            return True\n    return False\ndef prepare_env(cfg, silent = False):\n    \"\"\" mimic Conf/BuildEnv.sh \"\"\"\n    workspace = os.getcwd()\n    packages = [ workspace, ]\n    path = os.environ['PATH'].split(':')",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "prepare_env",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def prepare_env(cfg, silent = False):\n    \"\"\" mimic Conf/BuildEnv.sh \"\"\"\n    workspace = os.getcwd()\n    packages = [ workspace, ]\n    path = os.environ['PATH'].split(':')\n    dirs = [\n        'BaseTools/Bin/Linux-x86_64',\n        'BaseTools/BinWrappers/PosixLike'\n    ]\n    if cfg.has_option('global', 'pkgs'):",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "build_list",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def build_list(cfg):\n    for build in cfg.sections():\n        if not build.startswith('build.'):\n            continue\n        name = build.lstrip('build.')\n        desc = 'no description'\n        if 'desc' in cfg[build]:\n            desc = cfg[build]['desc']\n        print(f'# {name:20s} - {desc}')\ndef main():",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(prog = 'edk2-build',\n                                     description = 'edk2 build helper script')\n    parser.add_argument('-c', '--config', dest = 'configfile',\n                        type = str, default = '.edk2.builds', metavar = 'FILE',\n                        help = 'read configuration from FILE (default: .edk2.builds)')\n    parser.add_argument('-C', '--directory', dest = 'directory', type = str,\n                        help = 'change to DIR before building', metavar = 'DIR')\n    parser.add_argument('-j', '--jobs', dest = 'jobs', type = str,\n                        help = 'allow up to JOBS parallel build jobs',",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "version_override",
        "kind": 5,
        "importPath": "qemu.roms.edk2-build",
        "description": "qemu.roms.edk2-build",
        "peekOfCode": "version_override = None\nrelease_date     = None\n# pylint: disable=unused-variable\ndef check_rebase():\n    \"\"\" detect 'git rebase -x edk2-build.py master' testbuilds \"\"\"\n    global rebase_prefix\n    global version_override\n    gitdir = '.git'\n    if os.path.isfile(gitdir):\n        with open(gitdir, 'r', encoding = 'utf-8') as f:",
        "detail": "qemu.roms.edk2-build",
        "documentation": {}
    },
    {
        "label": "Patch",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]\n    replacement: str\nIdentifierType = Literal['type', 'symbol', 'include', 'constant']\nclass RequiredIdentifier(NamedTuple):\n    type: IdentifierType",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "RequiredIdentifier",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class RequiredIdentifier(NamedTuple):\n    type: IdentifierType\n    name: str\nclass FileMatch:\n    \"\"\"Base class for regex matches\n    Subclasses just need to set the `regexp` class attribute\n    \"\"\"\n    regexp: Optional[str] = None\n    def __init__(self, f: 'FileInfo', m: Match) -> None:\n        self.file: 'FileInfo' = f",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileMatch",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FileMatch:\n    \"\"\"Base class for regex matches\n    Subclasses just need to set the `regexp` class attribute\n    \"\"\"\n    regexp: Optional[str] = None\n    def __init__(self, f: 'FileInfo', m: Match) -> None:\n        self.file: 'FileInfo' = f\n        self.match: Match[str] = m\n    @property\n    def name(self) -> str:",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FullMatch",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FullMatch(FileMatch):\n    \"\"\"Regexp that will match all contents of string\n    Useful when used with group_match()\n    \"\"\"\n    regexp = r'(?s).*' # (?s) is re.DOTALL\ndef all_subclasses(c: Type[FileMatch]) -> Iterable[Type[FileMatch]]:\n    for sc in c.__subclasses__():\n        yield sc\n        yield from all_subclasses(sc)\ndef match_class_dict() -> Dict[str, Type[FileMatch]]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "PatchingError",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class PatchingError(Exception):\n    pass\nclass OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'\n    \"\"\"\n    r = StringIO()",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "OverLappingPatchesError",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'\n    \"\"\"\n    r = StringIO()\n    last = 0\n    def patch_sort_key(item: Tuple[int, Patch]) -> Tuple[int, int, int]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "RegexpScanner",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class RegexpScanner:\n    def __init__(self) -> None:\n        self.match_index: Dict[Type[Any], List[FileMatch]] = {}\n        self.match_name_index: Dict[Tuple[Type[Any], str, str], Optional[FileMatch]] = {}\n    def _matches_of_type(self, klass: Type[Any]) -> Iterable[FileMatch]:\n        raise NotImplementedError()\n    def matches_of_type(self, t: Type[T]) -> List[T]:\n        if t not in self.match_index:\n            self.match_index[t] = list(self._matches_of_type(t))\n        return self.match_index[t] # type: ignore",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileInfo",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FileInfo(RegexpScanner):\n    filename: Path\n    original_content: Optional[str] = None\n    def __init__(self, files: 'FileList', filename: os.PathLike, force:bool=False) -> None:\n        super().__init__()\n        self.allfiles = files\n        self.filename = Path(filename)\n        self.patches: List[Patch] = []\n        self.force = force\n    def __repr__(self) -> str:",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "FileList",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "class FileList(RegexpScanner):\n    def __init__(self):\n        super().__init__()\n        self.files: List[FileInfo] = []\n    def extend(self, *args, **kwargs):\n        self.files.extend(*args, **kwargs)\n    def __iter__(self):\n        return iter(self.files)\n    def _matches_of_type(self, klass: Type[Any]) -> Iterable[FileMatch]:\n        return chain(*(f._matches_of_type(klass) for f in self.files))",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "all_subclasses",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def all_subclasses(c: Type[FileMatch]) -> Iterable[Type[FileMatch]]:\n    for sc in c.__subclasses__():\n        yield sc\n        yield from all_subclasses(sc)\ndef match_class_dict() -> Dict[str, Type[FileMatch]]:\n    d = dict((t.__name__, t) for t in all_subclasses(FileMatch))\n    return d\ndef names(matches: Iterable[FileMatch]) -> Iterable[str]:\n    return [m.name for m in matches]\nclass PatchingError(Exception):",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "match_class_dict",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def match_class_dict() -> Dict[str, Type[FileMatch]]:\n    d = dict((t.__name__, t) for t in all_subclasses(FileMatch))\n    return d\ndef names(matches: Iterable[FileMatch]) -> Iterable[str]:\n    return [m.name for m in matches]\nclass PatchingError(Exception):\n    pass\nclass OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def names(matches: Iterable[FileMatch]) -> Iterable[str]:\n    return [m.name for m in matches]\nclass PatchingError(Exception):\n    pass\nclass OverLappingPatchesError(PatchingError):\n    pass\ndef apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "apply_patches",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "def apply_patches(s: str, patches: Iterable[Patch]) -> str:\n    \"\"\"Apply a sequence of patches to string\n    >>> apply_patches('abcdefg', [Patch(2,2,'xxx'), Patch(0, 1, 'yy')])\n    'yybxxxcdefg'\n    \"\"\"\n    r = StringIO()\n    last = 0\n    def patch_sort_key(item: Tuple[int, Patch]) -> Tuple[int, int, int]:\n        \"\"\"Patches are sorted by byte position,\n        patches at the same byte position are applied in the order",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "WARN = logger.warning\nERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "ERROR",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "ERROR = logger.error\nfrom .utils import *\nT = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]\n    replacement: str",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "T = TypeVar('T')\nclass Patch(NamedTuple):\n    # start inside file.original_content\n    start: int\n    # end position inside file.original_content\n    end: int\n    # replacement string for file.original_content[start:end]\n    replacement: str\nIdentifierType = Literal['type', 'symbol', 'include', 'constant']\nclass RequiredIdentifier(NamedTuple):",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "IdentifierType",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.patching",
        "description": "qemu.scripts.codeconverter.codeconverter.patching",
        "peekOfCode": "IdentifierType = Literal['type', 'symbol', 'include', 'constant']\nclass RequiredIdentifier(NamedTuple):\n    type: IdentifierType\n    name: str\nclass FileMatch:\n    \"\"\"Base class for regex matches\n    Subclasses just need to set the `regexp` class attribute\n    \"\"\"\n    regexp: Optional[str] = None\n    def __init__(self, f: 'FileInfo', m: Match) -> None:",
        "detail": "qemu.scripts.codeconverter.codeconverter.patching",
        "documentation": {}
    },
    {
        "label": "DefineDirective",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('constant', self.group('name'))\nclass ConstantDefine(ExpressionDefine):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ExpressionDefine",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('constant', self.group('name'))\nclass ConstantDefine(ExpressionDefine):\n    \"\"\"Simple #define preprocessor directive for a number or string constant\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_CONSTANT), r'[ \\t]*\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ConstantDefine",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ConstantDefine(ExpressionDefine):\n    \"\"\"Simple #define preprocessor directive for a number or string constant\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_CONSTANT), r'[ \\t]*\\n')\nclass TypeIdentifiers(NamedTuple):\n    \"\"\"Type names found in type declarations\"\"\"\n    # TYPE_MYDEVICE\n    typename: Optional[str]\n    # MYDEVICE\n    uppercase: Optional[str] = None",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeIdentifiers",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeIdentifiers(NamedTuple):\n    \"\"\"Type names found in type declarations\"\"\"\n    # TYPE_MYDEVICE\n    typename: Optional[str]\n    # MYDEVICE\n    uppercase: Optional[str] = None\n    # MyDevice\n    instancetype: Optional[str] = None\n    # MyDeviceClass\n    classtype: Optional[str] = None",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypedefMatch",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypedefMatch(FileMatch):\n    \"\"\"typedef declaration\"\"\"\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('type', self.group('name'))\nclass SimpleTypedefMatch(TypedefMatch):\n    \"\"\"Simple typedef declaration\n    (no replacement rules)\"\"\"\n    regexp = S(r'^[ \\t]*typedef', SP,\n               NAMED('typedef_type', RE_TYPE), SP,\n               NAMED('name', RE_IDENTIFIER), r'\\s*;[ \\t]*\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "SimpleTypedefMatch",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class SimpleTypedefMatch(TypedefMatch):\n    \"\"\"Simple typedef declaration\n    (no replacement rules)\"\"\"\n    regexp = S(r'^[ \\t]*typedef', SP,\n               NAMED('typedef_type', RE_TYPE), SP,\n               NAMED('name', RE_IDENTIFIER), r'\\s*;[ \\t]*\\n')\nRE_MACRO_DEFINE = S(r'^[ \\t]*#\\s*define\\s+', NAMED('name', RE_IDENTIFIER),\n                    r'\\s*\\(\\s*', RE_IDENTIFIER, r'\\s*\\)', CPP_SPACE)\nRE_STRUCT_ATTRIBUTE = r'QEMU_PACKED'\n# This doesn't parse the struct definitions completely, it just assumes",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "FullStructTypedefMatch",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class FullStructTypedefMatch(TypedefMatch):\n    \"\"\"typedef struct [SomeStruct] { ...} SomeType\n    Will be replaced by separate struct declaration + typedef\n    \"\"\"\n    regexp = RE_STRUCT_TYPEDEF\n    def make_structname(self) -> str:\n        \"\"\"Make struct name for struct+typedef split\"\"\"\n        name = self.group('structname')\n        if not name:\n            name = self.name",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "StructTypedefSplit",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class StructTypedefSplit(FullStructTypedefMatch):\n    \"\"\"split struct+typedef declaration\"\"\"\n    def gen_patches(self) -> Iterator[Patch]:\n        if self.group('structname'):\n            yield from self.split_typedef()\nclass DuplicatedTypedefs(SimpleTypedefMatch):\n    \"\"\"Delete ALL duplicate typedefs (unsafe)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        other_td = [td for td in chain(self.file.matches_of_type(SimpleTypedefMatch),\n                                       self.file.matches_of_type(FullStructTypedefMatch))",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DuplicatedTypedefs",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DuplicatedTypedefs(SimpleTypedefMatch):\n    \"\"\"Delete ALL duplicate typedefs (unsafe)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        other_td = [td for td in chain(self.file.matches_of_type(SimpleTypedefMatch),\n                                       self.file.matches_of_type(FullStructTypedefMatch))\n                    if td.name == self.name]\n        DBG(\"other_td: %r\", other_td)\n        if any(td.start() < self.start() for td in other_td):\n            # patch only if handling the first typedef\n            return",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "QOMDuplicatedTypedefs",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class QOMDuplicatedTypedefs(DuplicatedTypedefs):\n    \"\"\"Delete duplicate typedefs if used by QOM type\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        qom_macros = [TypeCheckMacro, DeclareInstanceChecker, DeclareClassCheckers, DeclareObjCheckers]\n        qom_matches = chain(*(self.file.matches_of_type(t) for t in qom_macros))\n        in_use = any(RequiredIdentifier('type', self.name) in m.required_identifiers()\n                     for m in qom_matches)\n        if in_use:\n            yield from DuplicatedTypedefs.gen_patches(self)\nclass QOMStructTypedefSplit(FullStructTypedefMatch):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "QOMStructTypedefSplit",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class QOMStructTypedefSplit(FullStructTypedefMatch):\n    \"\"\"split struct+typedef declaration if used by QOM type\"\"\"\n    def gen_patches(self) -> Iterator[Patch]:\n        qom_macros = [TypeCheckMacro, DeclareInstanceChecker, DeclareClassCheckers, DeclareObjCheckers]\n        qom_matches = chain(*(self.file.matches_of_type(t) for t in qom_macros))\n        in_use = any(RequiredIdentifier('type', self.name) in m.required_identifiers()\n                     for m in qom_matches)\n        if in_use:\n            yield from self.split_typedef()\ndef typedefs(file: FileInfo) -> Iterable[TypedefMatch]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeCheckMacro",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeCheckMacro(FileMatch):\n    \"\"\"OBJECT_CHECK/OBJECT_CLASS_CHECK/OBJECT_GET_CLASS macro definitions\n    Will be replaced by DECLARE_*_CHECKERS macro\n    \"\"\"\n    regexp = RE_CHECK_MACRO\n    @property\n    def checker(self) -> CheckerMacroName:\n        \"\"\"Name of checker macro being used\"\"\"\n        return self.group('checker') # type: ignore\n    @property",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "InterfaceCheckMacro",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class InterfaceCheckMacro(FileMatch):\n    \"\"\"Type checking macro using INTERFACE_CHECK\n    Will be replaced by DECLARE_INTERFACE_CHECKER\n    \"\"\"\n    regexp = S(RE_MACRO_DEFINE,\n               'INTERFACE_CHECK',\n               r'\\s*\\(\\s*', OR(NAMED('instancetype', RE_IDENTIFIER), RE_TYPE, name='c_type'),\n               r'\\s*,', CPP_SPACE,\n               OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n               NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeDeclaration",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeDeclaration(FileMatch):\n    \"\"\"Parent class to all type declarations\"\"\"\n    @property\n    def instancetype(self) -> Optional[str]:\n        return self.getgroup('instancetype')\n    @property\n    def classtype(self) -> Optional[str]:\n        return self.getgroup('classtype')\n    @property\n    def typename(self) -> Optional[str]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeCheckerDeclaration",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeCheckerDeclaration(TypeDeclaration):\n    \"\"\"Parent class to all type checker declarations\"\"\"\n    @property\n    def typename(self) -> str:\n        return self.group('typename')\n    @property\n    def uppercase(self) -> str:\n        return self.group('uppercase')\nclass DeclareInstanceChecker(TypeCheckerDeclaration):\n    \"\"\"DECLARE_INSTANCE_CHECKER use\"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareInstanceChecker",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareInstanceChecker(TypeCheckerDeclaration):\n    \"\"\"DECLARE_INSTANCE_CHECKER use\"\"\"\n    #TODO: replace lonely DECLARE_INSTANCE_CHECKER with DECLARE_OBJ_CHECKERS\n    #      if all types are found.\n    #      This will require looking up the correct class type in the TypeInfo\n    #      structs in another file\n    regexp = S(r'^[ \\t]*DECLARE_INSTANCE_CHECKER\\s*\\(\\s*',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareInterfaceChecker",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareInterfaceChecker(TypeCheckerDeclaration):\n    \"\"\"DECLARE_INTERFACE_CHECKER use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_INTERFACE_CHECKER\\s*\\(\\s*',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('constant', self.group('typename'))",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareInstanceType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareInstanceType(TypeDeclaration):\n    \"\"\"DECLARE_INSTANCE_TYPE use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_INSTANCE_TYPE\\s*\\(\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('instancetype', RE_TYPE), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('type', self.group('instancetype'))\nclass DeclareClassType(TypeDeclaration):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareClassType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareClassType(TypeDeclaration):\n    \"\"\"DECLARE_CLASS_TYPE use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_CLASS_TYPE\\s*\\(\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('classtype', RE_TYPE), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('type', self.group('classtype'))\nclass DeclareClassCheckers(TypeCheckerDeclaration):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareClassCheckers",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareClassCheckers(TypeCheckerDeclaration):\n    \"\"\"DECLARE_CLASS_CHECKER use\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_CLASS_CHECKERS\\s*\\(\\s*',\n               NAMED('classtype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', '\"qom/object.h\"')\n        yield RequiredIdentifier('constant', self.group('typename'))",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareObjCheckers",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareObjCheckers(TypeCheckerDeclaration):\n    \"\"\"DECLARE_OBJ_CHECKERS use\"\"\"\n    #TODO: detect when OBJECT_DECLARE_SIMPLE_TYPE can be used\n    regexp = S(r'^[ \\t]*DECLARE_OBJ_CHECKERS\\s*\\(\\s*',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('classtype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def required_identifiers(self) -> Iterable[RequiredIdentifier]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TypeDeclarationFixup",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TypeDeclarationFixup(FileMatch):\n    \"\"\"Common base class for code that will look at a set of type declarations\"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches(self) -> Iterable[Patch]:\n        if self.file.filename_matches('qom/object.h'):\n            self.debug(\"skipping object.h\")\n            return\n        # group checkers by uppercase name:\n        decl_types: List[Type[TypeDeclaration]] = [DeclareInstanceChecker, DeclareInstanceType,\n                                                   DeclareClassCheckers, DeclareClassType,",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareVoidTypes",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareVoidTypes(TypeDeclarationFixup):\n    \"\"\"Add DECLARE_*_TYPE(..., void) when there's no declared type\"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches_for_type(self, uppercase: str,\n                             checkers: List[TypeDeclaration],\n                             fields: Dict[str, Optional[str]]) -> Iterable[Patch]:\n        if self.find_conflicts(uppercase, checkers):\n            return\n        #_,last_checker = max((m.start(), m) for m in checkers)\n        _,first_checker = min((m.start(), m) for m in checkers)",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "AddDeclareTypeName",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class AddDeclareTypeName(TypeDeclarationFixup):\n    \"\"\"Add DECLARE_TYPE_NAME declarations if necessary\"\"\"\n    def gen_patches_for_type(self, uppercase: str,\n                             checkers: List[TypeDeclaration],\n                             fields: Dict[str, Optional[str]]) -> Iterable[Patch]:\n        typename = fields.get('typename')\n        if typename is None:\n            self.warn(\"typename unavailable\")\n            return\n        if typename == f'TYPE_{uppercase}':",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "TrivialClassStruct",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class TrivialClassStruct(FileMatch):\n    \"\"\"Trivial class struct\"\"\"\n    regexp = S(r'^[ \\t]*struct\\s*', NAMED('name', RE_IDENTIFIER),\n               r'\\s*{\\s*', NAMED('parent_struct', RE_IDENTIFIER), r'\\s*parent(_class)?\\s*;\\s*};\\n')\nclass DeclareTypeName(FileMatch):\n    \"\"\"DECLARE_TYPE_NAME usage\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_TYPE_NAME\\s*\\(',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'),\n               r'\\s*\\);?[ \\t]*\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DeclareTypeName",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class DeclareTypeName(FileMatch):\n    \"\"\"DECLARE_TYPE_NAME usage\"\"\"\n    regexp = S(r'^[ \\t]*DECLARE_TYPE_NAME\\s*\\(',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               OR(RE_IDENTIFIER, RE_STRING, RE_MACRO_CONCAT, RE_FUN_CALL, name='typename'),\n               r'\\s*\\);?[ \\t]*\\n')\nclass ObjectDeclareType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_TYPE usage\n    Will be replaced with OBJECT_DECLARE_SIMPLE_TYPE if possible\n    \"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ObjectDeclareType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ObjectDeclareType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_TYPE usage\n    Will be replaced with OBJECT_DECLARE_SIMPLE_TYPE if possible\n    \"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('classtype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    def gen_patches(self):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "ObjectDeclareSimpleType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class ObjectDeclareSimpleType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_SIMPLE_TYPE usage\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_SIMPLE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\nclass OldStyleObjectDeclareSimpleType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_SIMPLE_TYPE usage (old API)\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_SIMPLE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "OldStyleObjectDeclareSimpleType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class OldStyleObjectDeclareSimpleType(TypeCheckerDeclaration):\n    \"\"\"OBJECT_DECLARE_SIMPLE_TYPE usage (old API)\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DECLARE_SIMPLE_TYPE\\s*\\(',\n               NAMED('instancetype', RE_TYPE), r'\\s*,\\s*',\n               NAMED('lowercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('parent_classtype', RE_TYPE), SP,\n               r'\\)[ \\t]*;?[ \\t]*\\n')\n    @property\n    def classtype(self) -> Optional[str]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "Include",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class Include(FileMatch):\n    \"\"\"#include directive\"\"\"\n    regexp = RE_INCLUDE\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', self.group('includepath'))\nclass InitialIncludes(FileMatch):\n    \"\"\"Initial #include block\"\"\"\n    regexp = S(RE_FILE_BEGIN,\n               M(SP, RE_COMMENTS,\n                 r'^[ \\t]*#[ \\t]*ifndef[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n',",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "InitialIncludes",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class InitialIncludes(FileMatch):\n    \"\"\"Initial #include block\"\"\"\n    regexp = S(RE_FILE_BEGIN,\n               M(SP, RE_COMMENTS,\n                 r'^[ \\t]*#[ \\t]*ifndef[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n',\n                 n='?', name='ifndef_block'),\n               M(SP, RE_COMMENTS,\n                 OR(RE_INCLUDE, RE_SIMPLEDEFINE),\n                 n='*', name='includes'))\nclass SymbolUserList(NamedTuple):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "SymbolUserList",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class SymbolUserList(NamedTuple):\n    definitions: List[FileMatch]\n    users: List[FileMatch]\nclass MoveSymbols(FileMatch):\n    \"\"\"Handle missing symbols\n    - Move typedefs and defines when necessary\n    - Add missing #include lines when necessary\n    \"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches(self) -> Iterator[Patch]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "MoveSymbols",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class MoveSymbols(FileMatch):\n    \"\"\"Handle missing symbols\n    - Move typedefs and defines when necessary\n    - Add missing #include lines when necessary\n    \"\"\"\n    regexp = RE_FILE_BEGIN\n    def gen_patches(self) -> Iterator[Patch]:\n        if self.file.filename_matches('qom/object.h'):\n            self.debug(\"skipping object.h\")\n            return",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "EmptyPreprocessorConditional",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "class EmptyPreprocessorConditional(FileMatch):\n    \"\"\"Delete empty preprocessor conditionals\"\"\"\n    regexp = r'^[ \\t]*#(if|ifdef)[ \\t].*\\n+[ \\t]*#endif[ \\t]*\\n'\n    def gen_patches(self) -> Iterable[Patch]:\n        yield self.make_removal_patch()",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "typedefs",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def typedefs(file: FileInfo) -> Iterable[TypedefMatch]:\n    return (cast(TypedefMatch, m)\n            for m in chain(file.matches_of_type(SimpleTypedefMatch),\n                           file.matches_of_type(FullStructTypedefMatch)))\ndef find_typedef(f: FileInfo, name: Optional[str]) -> Optional[TypedefMatch]:\n    if not name:\n        return None\n    for td in typedefs(f):\n        if td.name == name:\n            return td",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "find_typedef",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def find_typedef(f: FileInfo, name: Optional[str]) -> Optional[TypedefMatch]:\n    if not name:\n        return None\n    for td in typedefs(f):\n        if td.name == name:\n            return td\n    return None\nCHECKER_MACROS = ['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nCheckerMacroName = Literal['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nRE_CHECK_MACRO = \\",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "find_typename_uppercase",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def find_typename_uppercase(files: FileList, typename: str) -> Optional[str]:\n    \"\"\"Try to find what's the right MODULE_OBJ_NAME for a given type name\"\"\"\n    decl = files.find_match(DeclareTypeName, name=typename, group='typename')\n    if decl:\n        return decl.group('uppercase')\n    if typename.startswith('TYPE_'):\n        return typename[len('TYPE_'):]\n    return None\ndef find_type_checkers(files:FileList, name:str, group:str='uppercase') -> Iterable[TypeCheckerDeclaration]:\n    \"\"\"Find usage of DECLARE*CHECKER macro\"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "find_type_checkers",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "def find_type_checkers(files:FileList, name:str, group:str='uppercase') -> Iterable[TypeCheckerDeclaration]:\n    \"\"\"Find usage of DECLARE*CHECKER macro\"\"\"\n    c: Type[TypeCheckerDeclaration]\n    for c in (DeclareInstanceChecker, DeclareClassCheckers, DeclareObjCheckers, ObjectDeclareType, ObjectDeclareSimpleType):\n        yield from files.find_matches(c, name=name, group=group)\nclass Include(FileMatch):\n    \"\"\"#include directive\"\"\"\n    regexp = RE_INCLUDE\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('include', self.group('includepath'))",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "WARN = logger.warning\n# simple expressions:\nRE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_CONSTANT",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_CONSTANT = OR(RE_STRING, RE_NUMBER)\nclass DefineDirective(FileMatch):\n    \"\"\"Match any #define directive\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER), r'\\b')\nclass ExpressionDefine(FileMatch):\n    \"\"\"Simple #define preprocessor directive for an expression\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE, NAMED('name', RE_IDENTIFIER),\n               CPP_SPACE, NAMED('value', RE_EXPRESSION), r'[ \\t]*\\n')\n    def provided_identifiers(self) -> Iterable[RequiredIdentifier]:\n        yield RequiredIdentifier('constant', self.group('name'))",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_MACRO_DEFINE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_MACRO_DEFINE = S(r'^[ \\t]*#\\s*define\\s+', NAMED('name', RE_IDENTIFIER),\n                    r'\\s*\\(\\s*', RE_IDENTIFIER, r'\\s*\\)', CPP_SPACE)\nRE_STRUCT_ATTRIBUTE = r'QEMU_PACKED'\n# This doesn't parse the struct definitions completely, it just assumes\n# the closing brackets are going to be in an unindented line:\nRE_FULL_STRUCT = S('struct', SP, M(RE_IDENTIFIER, n='?', name='structname'), SP,\n                   NAMED('body', r'{\\n',\n                         # acceptable inside the struct body:\n                         # - lines starting with space or tab\n                         # - empty lines",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_STRUCT_ATTRIBUTE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_STRUCT_ATTRIBUTE = r'QEMU_PACKED'\n# This doesn't parse the struct definitions completely, it just assumes\n# the closing brackets are going to be in an unindented line:\nRE_FULL_STRUCT = S('struct', SP, M(RE_IDENTIFIER, n='?', name='structname'), SP,\n                   NAMED('body', r'{\\n',\n                         # acceptable inside the struct body:\n                         # - lines starting with space or tab\n                         # - empty lines\n                         # - preprocessor directives\n                         # - comments",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_FULL_STRUCT",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_FULL_STRUCT = S('struct', SP, M(RE_IDENTIFIER, n='?', name='structname'), SP,\n                   NAMED('body', r'{\\n',\n                         # acceptable inside the struct body:\n                         # - lines starting with space or tab\n                         # - empty lines\n                         # - preprocessor directives\n                         # - comments\n                         OR(r'[ \\t][^\\n]*\\n',\n                            r'#[^\\n]*\\n',\n                            r'\\n',",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_STRUCT_TYPEDEF",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_STRUCT_TYPEDEF = S(r'^[ \\t]*typedef', SP, RE_FULL_STRUCT, SP,\n                      NAMED('name', RE_IDENTIFIER), r'\\s*;[ \\t]*\\n')\nclass FullStructTypedefMatch(TypedefMatch):\n    \"\"\"typedef struct [SomeStruct] { ...} SomeType\n    Will be replaced by separate struct declaration + typedef\n    \"\"\"\n    regexp = RE_STRUCT_TYPEDEF\n    def make_structname(self) -> str:\n        \"\"\"Make struct name for struct+typedef split\"\"\"\n        name = self.group('structname')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "CHECKER_MACROS",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "CHECKER_MACROS = ['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nCheckerMacroName = Literal['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nRE_CHECK_MACRO = \\\n    S(RE_MACRO_DEFINE,\n      OR(*CHECKER_MACROS, name='checker'),\n      M(r'\\s*\\(\\s*', OR(NAMED('typedefname', RE_IDENTIFIER), RE_TYPE, name='c_type'), r'\\s*,', CPP_SPACE,\n        OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n        NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n',\n        n='?', name='check_args'))\nEXPECTED_CHECKER_SUFFIXES: List[Tuple[CheckerMacroName, str]] = [",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "CheckerMacroName",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "CheckerMacroName = Literal['OBJECT_CHECK', 'OBJECT_CLASS_CHECK', 'OBJECT_GET_CLASS']\nRE_CHECK_MACRO = \\\n    S(RE_MACRO_DEFINE,\n      OR(*CHECKER_MACROS, name='checker'),\n      M(r'\\s*\\(\\s*', OR(NAMED('typedefname', RE_IDENTIFIER), RE_TYPE, name='c_type'), r'\\s*,', CPP_SPACE,\n        OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n        NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n',\n        n='?', name='check_args'))\nEXPECTED_CHECKER_SUFFIXES: List[Tuple[CheckerMacroName, str]] = [\n    ('OBJECT_GET_CLASS', '_GET_CLASS'),",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "RE_CHECK_MACRO",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "peekOfCode": "RE_CHECK_MACRO = \\\n    S(RE_MACRO_DEFINE,\n      OR(*CHECKER_MACROS, name='checker'),\n      M(r'\\s*\\(\\s*', OR(NAMED('typedefname', RE_IDENTIFIER), RE_TYPE, name='c_type'), r'\\s*,', CPP_SPACE,\n        OPTIONAL_PARS(RE_IDENTIFIER), r',', CPP_SPACE,\n        NAMED('qom_typename', RE_IDENTIFIER), r'\\s*\\)\\n',\n        n='?', name='check_args'))\nEXPECTED_CHECKER_SUFFIXES: List[Tuple[CheckerMacroName, str]] = [\n    ('OBJECT_GET_CLASS', '_GET_CLASS'),\n    ('OBJECT_CLASS_CHECK', '_CLASS'),",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_macros",
        "documentation": {}
    },
    {
        "label": "InitializerValue",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:\n        #DBG('parse_array: %r', m.group(0))",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ArrayItem",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:\n        #DBG('parse_array: %r', m.group(0))\n        return [m.group('arrayitem') for m in self.group_finditer(ArrayItem, 'arrayitems')]\nclass FieldInitializer(FileMatch):\n    regexp = RE_TI_FIELD_INIT\n    @property",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ArrayInitializer",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:\n        #DBG('parse_array: %r', m.group(0))\n        return [m.group('arrayitem') for m in self.group_finditer(ArrayItem, 'arrayitems')]\nclass FieldInitializer(FileMatch):\n    regexp = RE_TI_FIELD_INIT\n    @property\n    def raw(self) -> str:\n        return self.group('value')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "FieldInitializer",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class FieldInitializer(FileMatch):\n    regexp = RE_TI_FIELD_INIT\n    @property\n    def raw(self) -> str:\n        return self.group('value')\n    @property\n    def parsed(self) -> ParsedInitializerValue:\n        parsed: ParsedInitializerValue = self.raw\n        #DBG(\"parse_initializer_value: %r\", s)\n        array = self.try_group_match(ArrayInitializer, 'value')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeDefinition",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeDefinition(FileMatch):\n    \"\"\"\n    Common base class for type definitions (TypeInfo variables or OBJECT_DEFINE* macros)\n    \"\"\"\n    @property\n    def instancetype(self) -> Optional[str]:\n        return self.group('instancetype')\n    @property\n    def classtype(self) -> Optional[str]:\n        return self.group('classtype')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoVar",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInfoVar(TypeDefinition):\n    \"\"\"TypeInfo variable declaration with initializer\"\"\"\n    regexp = S(NAMED('begin', RE_TYPEINFO_START),\n               M(NAMED('fields', RE_TI_FIELDS),\n                 NAMED('endcomments', SP, RE_COMMENTS),\n                 NAMED('end', r'};?\\n'),\n                 n='?', name='fullspec'))\n    def is_static(self) -> bool:\n        return 'static' in self.group('modifiers')\n    def is_const(self) -> bool:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RemoveRedundantClassSize",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class RemoveRedundantClassSize(TypeInfoVar):\n    \"\"\"Remove class_size when using OBJECT_DECLARE_SIMPLE_TYPE\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        initializers = self.initializers\n        if initializers is None:\n            return\n        if 'class_size' not in initializers:\n            return\n        self.debug(\"Handling %s\", self.name)\n        m = re.fullmatch(RE_SIZEOF, initializers['class_size'].raw)",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RemoveDeclareSimpleTypeArg",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class RemoveDeclareSimpleTypeArg(OldStyleObjectDeclareSimpleType):\n    \"\"\"Remove class_size when using OBJECT_DECLARE_SIMPLE_TYPE\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        c = (f'OBJECT_DECLARE_SIMPLE_TYPE({self.group(\"instancetype\")}, {self.group(\"lowercase\")},\\n'\n             f'                           {self.group(\"uppercase\")})\\n')\n        yield self.make_patch(c)\nclass UseDeclareTypeExtended(TypeInfoVar):\n    \"\"\"Replace TypeInfo variable with OBJECT_DEFINE_TYPE_EXTENDED\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        # this will just ensure the caches for find_match() and matches_for_type()",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "UseDeclareTypeExtended",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class UseDeclareTypeExtended(TypeInfoVar):\n    \"\"\"Replace TypeInfo variable with OBJECT_DEFINE_TYPE_EXTENDED\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        # this will just ensure the caches for find_match() and matches_for_type()\n        # will be loaded in advance:\n        find_type_checkers(self.allfiles, 'xxxxxxxxxxxxxxxxx')\n        if not self.is_static():\n            self.info(\"Skipping non-static TypeInfo variable\")\n            return\n        type_info_macro = self.file.find_match(TypeInfoMacro, self.name)",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ObjectDefineTypeExtended",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ObjectDefineTypeExtended(TypeDefinition):\n    \"\"\"OBJECT_DEFINE_TYPE_EXTENDED usage\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DEFINE_TYPE_EXTENDED\\s*\\(\\s*',\n               NAMED('name', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('instancetype', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('classtype', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('parent_uppercase', RE_IDENTIFIER),\n               M(r',\\s*\\n',\n                 NAMED('fields', RE_TI_FIELDS),",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ObjectDefineType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class ObjectDefineType(TypeDefinition):\n    \"\"\"OBJECT_DEFINE_TYPE usage\"\"\"\n    regexp = S(r'^[ \\t]*OBJECT_DEFINE_TYPE\\s*\\(\\s*',\n               NAMED('lowercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('uppercase', RE_IDENTIFIER), r'\\s*,\\s*',\n               NAMED('parent_uppercase', RE_IDENTIFIER),\n               M(r',\\s*\\n',\n                 NAMED('fields', RE_TI_FIELDS),\n                 n='?'),\n               r'\\s*\\);?\\n?')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddDeclareVoidClassType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddDeclareVoidClassType(TypeDeclarationFixup):\n    \"\"\"Will add DECLARE_CLASS_TYPE(..., void) if possible\"\"\"\n    def gen_patches_for_type(self, uppercase: str,\n                             checkers: List[TypeDeclaration],\n                             fields: Dict[str, Optional[str]]) -> Iterable[Patch]:\n        defs = list(find_type_definitions(self.allfiles, uppercase))\n        if len(defs) > 1:\n            self.warn(\"multiple definitions for %s\", uppercase)\n            for d in defs:\n                d.warn(\"definition found here\")",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddDeclareVoidInstanceType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddDeclareVoidInstanceType(FileMatch):\n    \"\"\"Will add DECLARE_INSTANCE_TYPE(..., void) if possible\"\"\"\n    regexp = S(r'^[ \\t]*#[ \\t]*define', CPP_SPACE,\n               NAMED('name', r'TYPE_[a-zA-Z0-9_]+\\b'),\n               CPP_SPACE, r'.*\\n')\n    def gen_patches(self) -> Iterable[Patch]:\n        assert self.name.startswith('TYPE_')\n        uppercase = self.name[len('TYPE_'):]\n        defs = list(find_type_definitions(self.allfiles, uppercase))\n        if len(defs) > 1:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddObjectDeclareType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddObjectDeclareType(DeclareObjCheckers):\n    \"\"\"Will add OBJECT_DECLARE_TYPE(...) if possible\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        uppercase = self.uppercase\n        typename = self.group('typename')\n        instancetype = self.group('instancetype')\n        classtype = self.group('classtype')\n        if typename != f'TYPE_{uppercase}':\n            self.warn(\"type name mismatch: %s vs %s\", typename, uppercase)\n            return",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "AddObjectDeclareSimpleType",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class AddObjectDeclareSimpleType(DeclareInstanceChecker):\n    \"\"\"Will add OBJECT_DECLARE_SIMPLE_TYPE(...) if possible\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        uppercase = self.uppercase\n        typename = self.group('typename')\n        instancetype = self.group('instancetype')\n        if typename != f'TYPE_{uppercase}':\n            self.warn(\"type name mismatch: %s vs %s\", typename, uppercase)\n            return\n        typedefs = [(t,self.allfiles.find_matches(SimpleTypedefMatch, t))",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoStringName",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInfoStringName(TypeInfoVar):\n    \"\"\"Replace hardcoded type names with TYPE_ constant\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        values = self.initializers\n        if values is None:\n            return\n        if 'name' not in values:\n            self.warn(\"name not set in TypeInfo variable %s\", self.name)\n            return\n        typename = values['name'].raw",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RedundantTypeSizes",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class RedundantTypeSizes(TypeInfoVar):\n    \"\"\"Remove redundant instance_size/class_size from TypeInfo vars\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        values = self.initializers\n        if values is None:\n            return\n        if 'name' not in values:\n            self.warn(\"name not set in TypeInfo variable %s\", self.name)\n            return\n        typename = values['name'].raw",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInitMacro",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInitMacro(FileMatch):\n    \"\"\"Use of type_init(...) macro\"\"\"\n    regexp = S(r'^[ \\t]*type_init\\s*\\(\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\);?[ \\t]*\\n')\nclass DeleteEmptyTypeInitFunc(TypeInitMacro):\n    \"\"\"Delete empty function declared using type_init(...)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = self.file.find_match(StaticVoidFunction, self.name)\n        DBG(\"function for %s: %s\", self.name, fn)\n        if fn and fn.body == '':\n            yield fn.make_patch('')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "DeleteEmptyTypeInitFunc",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class DeleteEmptyTypeInitFunc(TypeInitMacro):\n    \"\"\"Delete empty function declared using type_init(...)\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = self.file.find_match(StaticVoidFunction, self.name)\n        DBG(\"function for %s: %s\", self.name, fn)\n        if fn and fn.body == '':\n            yield fn.make_patch('')\n            yield self.make_patch('')\nclass StaticVoidFunction(FileMatch):\n    \"\"\"simple static void function",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "StaticVoidFunction",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class StaticVoidFunction(FileMatch):\n    \"\"\"simple static void function\n    (no replacement rules)\n    \"\"\"\n    #NOTE: just like RE_FULL_STRUCT, this doesn't parse any of the body contents\n    #      of the function.  Tt will just look for \"}\" in the beginning of a line\n    regexp = S(r'static\\s+void\\s+', NAMED('name', RE_IDENTIFIER), r'\\s*\\(\\s*void\\s*\\)\\n',\n               r'{\\n',\n               NAMED('body',\n                     # acceptable inside the function body:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeRegisterStaticCall",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeRegisterStaticCall(FileMatch):\n    \"\"\"type_register_static() call\n    Will be replaced by TYPE_INFO() macro\n    \"\"\"\n    regexp = S(r'^[ \\t]*', NAMED('func_name', 'type_register_static'),\n               r'\\s*\\(&\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\);[ \\t]*\\n')\nclass UseTypeInfo(TypeRegisterStaticCall):\n    \"\"\"Replace type_register_static() call with TYPE_INFO declaration\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = find_containing_func(self)",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "UseTypeInfo",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class UseTypeInfo(TypeRegisterStaticCall):\n    \"\"\"Replace type_register_static() call with TYPE_INFO declaration\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        fn = find_containing_func(self)\n        if fn:\n            DBG(\"%r is inside %r\", self, fn)\n            type_init = self.file.find_match(TypeInitMacro, fn.name)\n            if type_init is None:\n                self.warn(\"can't find type_init(%s) line\", fn.name)\n                if not self.file.force:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeRegisterCall",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeRegisterCall(FileMatch):\n    \"\"\"type_register_static() call\"\"\"\n    regexp = S(r'^[ \\t]*', NAMED('func_name', 'type_register'),\n               r'\\s*\\(&\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\);[ \\t]*\\n')\nclass TypeInfoMacro(FileMatch):\n    \"\"\"TYPE_INFO macro usage\"\"\"\n    regexp = S(r'^[ \\t]*TYPE_INFO\\s*\\(\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\)[ \\t]*;?[ \\t]*\\n')\ndef find_type_info(files: RegexpScanner, name: str) -> Optional[TypeInfoVar]:\n    ti = [ti for ti in files.matches_of_type(TypeInfoVar)\n            if ti.get_raw_initializer_value('name') == name]",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoMacro",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class TypeInfoMacro(FileMatch):\n    \"\"\"TYPE_INFO macro usage\"\"\"\n    regexp = S(r'^[ \\t]*TYPE_INFO\\s*\\(\\s*', NAMED('name', RE_IDENTIFIER), r'\\s*\\)[ \\t]*;?[ \\t]*\\n')\ndef find_type_info(files: RegexpScanner, name: str) -> Optional[TypeInfoVar]:\n    ti = [ti for ti in files.matches_of_type(TypeInfoVar)\n            if ti.get_raw_initializer_value('name') == name]\n    DBG(\"type info vars: %r\", ti)\n    if len(ti) > 1:\n        DBG(\"multiple TypeInfo vars found for %s\", name)\n        return None",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "CreateClassStruct",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "class CreateClassStruct(DeclareInstanceChecker):\n    \"\"\"Replace DECLARE_INSTANCE_CHECKER with OBJECT_DECLARE_SIMPLE_TYPE\"\"\"\n    def gen_patches(self) -> Iterable[Patch]:\n        typename = self.group('typename')\n        DBG(\"looking for TypeInfo variable for %s\", typename)\n        var = find_type_info(self.allfiles, typename)\n        if var is None:\n            self.warn(\"no TypeInfo var found for %s\", typename)\n            return\n        assert var.initializers",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "find_type_definitions",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def find_type_definitions(files: FileList, uppercase: str) -> Iterable[TypeDefinition]:\n    types: List[Type[TypeDefinition]] = [TypeInfoVar, ObjectDefineType, ObjectDefineTypeExtended]\n    for t in types:\n        for m in files.matches_of_type(t):\n            m.debug(\"uppercase: %s\", m.uppercase)\n    yield from (m for t in types\n                  for m in files.matches_of_type(t)\n                if m.uppercase == uppercase)\nclass AddDeclareVoidClassType(TypeDeclarationFixup):\n    \"\"\"Will add DECLARE_CLASS_TYPE(..., void) if possible\"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "find_containing_func",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def find_containing_func(m: FileMatch) -> Optional['StaticVoidFunction']:\n    \"\"\"Return function containing this match\"\"\"\n    for fn in m.file.matches_of_type(StaticVoidFunction):\n        if fn.contains(m):\n            return fn\n    return None\nclass TypeRegisterStaticCall(FileMatch):\n    \"\"\"type_register_static() call\n    Will be replaced by TYPE_INFO() macro\n    \"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "find_type_info",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def find_type_info(files: RegexpScanner, name: str) -> Optional[TypeInfoVar]:\n    ti = [ti for ti in files.matches_of_type(TypeInfoVar)\n            if ti.get_raw_initializer_value('name') == name]\n    DBG(\"type info vars: %r\", ti)\n    if len(ti) > 1:\n        DBG(\"multiple TypeInfo vars found for %s\", name)\n        return None\n    if len(ti) == 0:\n        DBG(\"no TypeInfo var found for %s\", name)\n        return None",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "type_infos",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def type_infos(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return file.matches_of_type(TypeInfoVar)\ndef full_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if t.is_full()]\ndef partial_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if not t.is_full()]",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "full_types",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def full_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if t.is_full()]\ndef partial_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if not t.is_full()]",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "partial_types",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "def partial_types(file: FileInfo) -> Iterable[TypeInfoVar]:\n    return [t for t in type_infos(file) if not t.is_full()]",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TI_FIELDS",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "TI_FIELDS = [ 'name', 'parent', 'abstract', 'interfaces',\n    'instance_size', 'instance_init', 'instance_post_init', 'instance_finalize',\n    'class_size', 'class_init', 'class_base_init', 'class_data']\nRE_TI_FIELD_NAME = OR(*TI_FIELDS)\nRE_TI_FIELD_INIT = S(r'[ \\t]*', NAMED('comments', RE_COMMENTS),\n                     r'\\.', NAMED('field', RE_TI_FIELD_NAME), r'\\s*=\\s*',\n                     NAMED('value', RE_EXPRESSION), r'[ \\t]*,?[ \\t]*\\n')\nRE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TI_FIELD_NAME",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TI_FIELD_NAME = OR(*TI_FIELDS)\nRE_TI_FIELD_INIT = S(r'[ \\t]*', NAMED('comments', RE_COMMENTS),\n                     r'\\.', NAMED('field', RE_TI_FIELD_NAME), r'\\s*=\\s*',\n                     NAMED('value', RE_EXPRESSION), r'[ \\t]*,?[ \\t]*\\n')\nRE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TI_FIELD_INIT",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TI_FIELD_INIT = S(r'[ \\t]*', NAMED('comments', RE_COMMENTS),\n                     r'\\.', NAMED('field', RE_TI_FIELD_NAME), r'\\s*=\\s*',\n                     NAMED('value', RE_EXPRESSION), r'[ \\t]*,?[ \\t]*\\n')\nRE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TI_FIELDS",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TI_FIELDS = M(RE_TI_FIELD_INIT)\nRE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "RE_TYPEINFO_START",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "RE_TYPEINFO_START = S(r'^[ \\t]*', M(r'(static|const)\\s+', name='modifiers'), r'TypeInfo\\s+',\n                      NAMED('name', RE_IDENTIFIER), r'\\s*=\\s*{[ \\t]*\\n')\nParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ParsedArray",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "ParsedArray = List[str]\nParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "ParsedInitializerValue",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "ParsedInitializerValue = Union[str, ParsedArray]\nclass InitializerValue(NamedTuple):\n    raw: str\n    parsed: Optional[ParsedInitializerValue]\n    match: Optional[Match]\nclass ArrayItem(FileMatch):\n    regexp = RE_ARRAY_ITEM\nclass ArrayInitializer(FileMatch):\n    regexp = RE_ARRAY\n    def parsed(self) -> ParsedArray:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "TypeInfoInitializers",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "description": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "peekOfCode": "TypeInfoInitializers = Dict[str, FieldInitializer]\nclass TypeDefinition(FileMatch):\n    \"\"\"\n    Common base class for type definitions (TypeInfo variables or OBJECT_DEFINE* macros)\n    \"\"\"\n    @property\n    def instancetype(self) -> Optional[str]:\n        return self.group('instancetype')\n    @property\n    def classtype(self) -> Optional[str]:",
        "detail": "qemu.scripts.codeconverter.codeconverter.qom_type_info",
        "documentation": {}
    },
    {
        "label": "S",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'\n    elif capture:\n        return f'({s}){repeat}'",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'\n    elif capture:\n        return f'({s}){repeat}'\n    else:\n        return f'(?:{s}){repeat}'\ndef NAMED(name, *regexps) -> str:",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "NAMED",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def NAMED(name, *regexps) -> str:\n    \"\"\"Make named group using <P<name>...) syntax\n    >>> NAMED('mygroup', 'xyz', 'abc')\n    '(?P<mygroup>xyzabc)'\n    \"\"\"\n    return P(*regexps, name=name)\ndef OR(*regexps, **kwargs) -> str:\n    \"\"\"Build (a|b|c) regexp\"\"\"\n    return P('|'.join(regexps), **kwargs)\ndef M(*regexps, n='*', name=None) -> str:",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "OR",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def OR(*regexps, **kwargs) -> str:\n    \"\"\"Build (a|b|c) regexp\"\"\"\n    return P('|'.join(regexps), **kwargs)\ndef M(*regexps, n='*', name=None) -> str:\n    \"\"\"Add repetition qualifier to regexp(s)\n    >>> M('a', 'b')\n    '(?:ab)*'\n    >>> M('a' , 'b', n='+')\n    '(?:ab)+'\n    >>> M('a' , 'b', n='{2,3}', name='name')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "M",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def M(*regexps, n='*', name=None) -> str:\n    \"\"\"Add repetition qualifier to regexp(s)\n    >>> M('a', 'b')\n    '(?:ab)*'\n    >>> M('a' , 'b', n='+')\n    '(?:ab)+'\n    >>> M('a' , 'b', n='{2,3}', name='name')\n    '(?P<name>(?:ab){2,3})'\n    \"\"\"\n    r = P(*regexps, repeat=n)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "test_optional_pars",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "def test_optional_pars():\n    r = OPTIONAL_PARS('abc')+'$'\n    assert re.match(r, 'abc')\n    assert re.match(r, '(abc)')\n    assert not re.match(r, '(abcd)')\n    assert not re.match(r, '(abc')\n    assert not re.match(r, 'abc)')\n# this disables the MULTILINE flag, so it will match at the\n# beginning of the file:\nRE_FILE_BEGIN = r'(?-m:^)'",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "WARN = logger.warning\ndef S(*regexps) -> str:\n    \"\"\"Just a shortcut to concatenate multiple regexps more easily\"\"\"\n    return ''.join(regexps)\ndef P(*regexps, name=None, capture=False, repeat='') -> str:\n    \"\"\"Just add parenthesis around regexp(s), with optional name or repeat suffix\"\"\"\n    s = S(*regexps)\n    if name:\n        return f'(?P<{name}>{s}){repeat}'\n    elif capture:",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "OPTIONAL_PARS",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "OPTIONAL_PARS = lambda R: OR(S(r'\\(\\s*', R, r'\\s*\\)'), R)\ndef test_optional_pars():\n    r = OPTIONAL_PARS('abc')+'$'\n    assert re.match(r, 'abc')\n    assert re.match(r, '(abc)')\n    assert not re.match(r, '(abcd)')\n    assert not re.match(r, '(abc')\n    assert not re.match(r, 'abc)')\n# this disables the MULTILINE flag, so it will match at the\n# beginning of the file:",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_FILE_BEGIN",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_FILE_BEGIN = r'(?-m:^)'\n# C primitives:\nSP = r'\\s*'\nRE_COMMENT = r'//[^\\n]*$|/\\*([^*]|\\*[^/])*\\*/'\nRE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "SP",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "SP = r'\\s*'\nRE_COMMENT = r'//[^\\n]*$|/\\*([^*]|\\*[^/])*\\*/'\nRE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_COMMENT",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_COMMENT = r'//[^\\n]*$|/\\*([^*]|\\*[^/])*\\*/'\nRE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_COMMENTS",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_COMMENTS = M(RE_COMMENT + SP)\nRE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_IDENTIFIER",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_IDENTIFIER = r'[a-zA-Z_][a-zA-Z0-9_]*(?![a-zA-Z0-9])'\nRE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_STRING",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_STRING = r'\\\"([^\\\"\\\\]|\\\\[a-z\\\"])*\\\"'\nRE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_NUMBER",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_NUMBER = r'[0-9]+|0x[0-9a-fA-F]+'\n# space or escaped newlines:\nCPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "CPP_SPACE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "CPP_SPACE = OR(r'\\s', r'\\\\\\n', repeat='+')\nRE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_PATH",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_PATH = '[a-zA-Z0-9/_.-]+'\nRE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_INCLUDEPATH",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_INCLUDEPATH = OR(S(r'\\\"', RE_PATH, r'\\\"'),\n                    S(r'<', RE_PATH, r'>'))\nRE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_INCLUDE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_INCLUDE = S(r'^[ \\t]*#[ \\t]*include[ \\t]+', NAMED('includepath', RE_INCLUDEPATH), r'[ \\t]*\\n')\nRE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_SIMPLEDEFINE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_SIMPLEDEFINE = S(r'^[ \\t]*#[ \\t]*define[ \\t]+', RE_IDENTIFIER, r'[ \\t]*\\n')\nRE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_STRUCT_TYPE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_STRUCT_TYPE = S(r'struct\\s+', RE_IDENTIFIER)\nRE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_TYPE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_TYPE = OR(RE_IDENTIFIER, RE_STRUCT_TYPE)\nRE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_MACRO_CONCAT",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_MACRO_CONCAT = M(S(OR(RE_IDENTIFIER, RE_STRING), SP), n='{2,}')\nRE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_SIMPLE_VALUE",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_SIMPLE_VALUE = OR(RE_IDENTIFIER, RE_STRING, RE_NUMBER)\nRE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_FUN_CALL",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_FUN_CALL = S(RE_IDENTIFIER, r'\\s*\\(\\s*', RE_SIMPLE_VALUE, r'\\s*\\)')\nRE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_SIZEOF",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_SIZEOF = S(r'sizeof\\s*\\(\\s*', NAMED('sizeoftype', RE_TYPE), r'\\s*\\)')\nRE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ADDRESS",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ADDRESS = S(r'&\\s*', RE_IDENTIFIER)\nRE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY_ITEM",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY_ITEM = S(r'{\\s*', NAMED('arrayitem', M(RE_SIMPLE_VALUE, n='?')), r'\\s*}\\s*,?')\nRE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY_CAST",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY_CAST = S(r'\\(\\s*', RE_IDENTIFIER, r'\\s*\\[\\s*\\]\\)')\nRE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY_ITEMS",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY_ITEMS = M(S(RE_ARRAY_ITEM, SP))\nRE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_ARRAY",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_ARRAY = S(M(RE_ARRAY_CAST, n='?'), r'\\s*{\\s*',\n             NAMED('arrayitems', RE_ARRAY_ITEMS),\n             r'}')\n# NOTE: this covers a very small subset of valid expressions\nRE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "RE_EXPRESSION",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.regexps",
        "peekOfCode": "RE_EXPRESSION = OR(RE_SIZEOF, RE_FUN_CALL, RE_MACRO_CONCAT, RE_SIMPLE_VALUE,\n                   RE_ARRAY, RE_ADDRESS)",
        "detail": "qemu.scripts.codeconverter.codeconverter.regexps",
        "documentation": {}
    },
    {
        "label": "BasicPattern",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "class BasicPattern(FileMatch):\n    regexp = '[abc]{3}'\n    @property\n    def name(self):\n        return self.group(0)\n    def replacement(self) -> str:\n        # replace match with the middle character repeated 5 times\n        return self.group(0)[1].upper()*5\ndef test_pattern_patching():\n    of = NamedTemporaryFile('wt')",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "Function",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "class Function(FileMatch):\n    regexp = S(r'BEGIN\\s+', NAMED('name', RE_IDENTIFIER), r'\\n',\n               r'(.*\\n)*?END\\n')\nclass Statement(FileMatch):\n    regexp = S(r'^\\s*', NAMED('name', RE_IDENTIFIER), r'\\(\\)\\n')\ndef test_container_match():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['statement1()\\n',\n                   'statement2()\\n',\n                   'BEGIN function1\\n',",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "Statement",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "class Statement(FileMatch):\n    regexp = S(r'^\\s*', NAMED('name', RE_IDENTIFIER), r'\\(\\)\\n')\ndef test_container_match():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['statement1()\\n',\n                   'statement2()\\n',\n                   'BEGIN function1\\n',\n                   '  statement3()\\n',\n                   '  statement4()\\n',\n                   'END\\n',",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "test_pattern_patching",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "def test_pattern_patching():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['one line\\n',\n                  'this pattern will be patched: defbbahij\\n',\n                  'third line\\n',\n                  'another pattern: jihaabfed'])\n    of.flush()\n    files = FileList()\n    f = FileInfo(files, of.name)\n    f.load()",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "test_container_match",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "description": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "peekOfCode": "def test_container_match():\n    of = NamedTemporaryFile('wt')\n    of.writelines(['statement1()\\n',\n                   'statement2()\\n',\n                   'BEGIN function1\\n',\n                   '  statement3()\\n',\n                   '  statement4()\\n',\n                   'END\\n',\n                   'BEGIN function2\\n',\n                   '  statement5()\\n',",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_patching",
        "documentation": {}
    },
    {
        "label": "test_res",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "peekOfCode": "def test_res() -> None:\n    def fullmatch(regexp, s):\n        return re.fullmatch(regexp, s, re.MULTILINE)\n    assert fullmatch(RE_IDENTIFIER, 'sizeof')\n    assert fullmatch(RE_IDENTIFIER, 'X86CPU')\n    assert fullmatch(RE_FUN_CALL, 'sizeof(X86CPU)')\n    assert fullmatch(RE_IDENTIFIER, 'X86_CPU_TYPE_NAME')\n    assert fullmatch(RE_SIMPLE_VALUE, '\"base\"')\n    print(RE_FUN_CALL)\n    assert fullmatch(RE_FUN_CALL, 'X86_CPU_TYPE_NAME(\"base\")')",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "documentation": {}
    },
    {
        "label": "test_struct_re",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "peekOfCode": "def test_struct_re():\n    print('---')\n    print(RE_STRUCT_TYPEDEF)\n    assert re.search(RE_STRUCT_TYPEDEF, r'''\ntypedef struct TCGState {\n    AccelState parent_obj;\n    bool mttcg_enabled;\n    unsigned long tb_size;\n} TCGState;\n''', re.MULTILINE)",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "documentation": {}
    },
    {
        "label": "test_initial_includes",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "description": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "peekOfCode": "def test_initial_includes():\n    print(InitialIncludes.regexp)\n    c = '''\n#ifndef HW_FLASH_H\n#define HW_FLASH_H\n/* NOR flash devices */\n#include \"qom/object.h\"\n#include \"exec/hwaddr.h\"\n/* pflash_cfi01.c */\n'''",
        "detail": "qemu.scripts.codeconverter.codeconverter.test_regexps",
        "documentation": {}
    },
    {
        "label": "LineAndColumn",
        "kind": 6,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "class LineAndColumn(NamedTuple):\n    line: int\n    col: int\n    def __str__(self):\n        return '%d:%d' % (self.line, self.col)\ndef line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.\n    \"\"\"\n    before = s[:position]",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "opt_compare",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b\n    else:\n        return a",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b\n    else:\n        return a\ndef test_comp_merge():\n    assert opt_compare(None, 1) == True\n    assert opt_compare(2, None) == True",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "test_comp_merge",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def test_comp_merge():\n    assert opt_compare(None, 1) == True\n    assert opt_compare(2, None) == True\n    assert opt_compare(1, 1) == True\n    assert opt_compare(1, 2) == False\n    assert merge(None, None) is None\n    assert merge(None, 10) == 10\n    assert merge(10, None) == 10\n    assert merge(10, 10) == 10\nLineNumber = NewType('LineNumber', int)",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "line_col",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.\n    \"\"\"\n    before = s[:position]\n    lines = before.split('\\n')\n    line = len(lines)\n    col = len(lines[-1]) + 1\n    return LineAndColumn(line, col)\ndef test_line_col():",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "test_line_col",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def test_line_col():\n    assert line_col('abc\\ndefg\\nhijkl', 0) == (1, 1)\n    assert line_col('abc\\ndefg\\nhijkl', 2) == (1, 3)\n    assert line_col('abc\\ndefg\\nhijkl', 3) == (1, 4)\n    assert line_col('abc\\ndefg\\nhijkl', 4) == (2, 1)\n    assert line_col('abc\\ndefg\\nhijkl', 10) == (3, 2)\ndef not_optional(arg: Optional[T]) -> T:\n    assert arg is not None\n    return arg\n__all__ = ['not_optional', 'opt_compare', 'merge', 'line_col', 'LineAndColumn']",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "not_optional",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "def not_optional(arg: Optional[T]) -> T:\n    assert arg is not None\n    return arg\n__all__ = ['not_optional', 'opt_compare', 'merge', 'line_col', 'LineAndColumn']",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "WARN = logger.warning\nT = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "T = TypeVar('T')\ndef opt_compare(a: T, b: T) -> bool:\n    \"\"\"Compare two values, ignoring mismatches if one of them is None\"\"\"\n    return (a is None) or (b is None) or (a == b)\ndef merge(a: T, b: T) -> T:\n    \"\"\"Merge two values if they matched using opt_compare()\"\"\"\n    assert opt_compare(a, b)\n    if a is None:\n        return b\n    else:",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "LineNumber",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "LineNumber = NewType('LineNumber', int)\nColumnNumber = NewType('ColumnNumber', int)\nclass LineAndColumn(NamedTuple):\n    line: int\n    col: int\n    def __str__(self):\n        return '%d:%d' % (self.line, self.col)\ndef line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "ColumnNumber",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "ColumnNumber = NewType('ColumnNumber', int)\nclass LineAndColumn(NamedTuple):\n    line: int\n    col: int\n    def __str__(self):\n        return '%d:%d' % (self.line, self.col)\ndef line_col(s, position: int) -> LineAndColumn:\n    \"\"\"Return line and column for a char position in string\n    Character position starts in 0, but lines and columns start in 1.\n    \"\"\"",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.codeconverter.utils",
        "description": "qemu.scripts.codeconverter.codeconverter.utils",
        "peekOfCode": "__all__ = ['not_optional', 'opt_compare', 'merge', 'line_col', 'LineAndColumn']",
        "detail": "qemu.scripts.codeconverter.codeconverter.utils",
        "documentation": {}
    },
    {
        "label": "process_all_files",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.converter",
        "description": "qemu.scripts.codeconverter.converter",
        "peekOfCode": "def process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()\n    if args.table:\n        fields = ['filename', 'variable_name'] + TI_FIELDS\n        print('\\t'.join(fields))",
        "detail": "qemu.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.codeconverter.converter",
        "description": "qemu.scripts.codeconverter.converter",
        "peekOfCode": "def main() -> None:\n    p = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)\n    p.add_argument('filenames', nargs='+')\n    p.add_argument('--passes', type=int, default=1,\n                   help=\"Number of passes (0 means unlimited)\")\n    p.add_argument('--pattern', required=True, action='append',\n                   default=[], dest='patterns',\n                   help=\"Pattern to scan for\")\n    p.add_argument('--inplace', '-i', action='store_true',\n                   help=\"Patch file in place\")",
        "detail": "qemu.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.converter",
        "description": "qemu.scripts.codeconverter.converter",
        "peekOfCode": "logger = logging.getLogger(__name__)\nDBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)",
        "detail": "qemu.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "DBG",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.converter",
        "description": "qemu.scripts.codeconverter.converter",
        "peekOfCode": "DBG = logger.debug\nINFO = logger.info\nWARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()",
        "detail": "qemu.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.converter",
        "description": "qemu.scripts.codeconverter.converter",
        "peekOfCode": "INFO = logger.info\nWARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()\n    if args.table:",
        "detail": "qemu.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.converter",
        "description": "qemu.scripts.codeconverter.converter",
        "peekOfCode": "WARN = logger.warning\ndef process_all_files(parser: argparse.ArgumentParser, args: argparse.Namespace) -> None:\n    DBG(\"filenames: %r\", args.filenames)\n    files = FileList()\n    files.extend(FileInfo(files, fn, args.force) for fn in args.filenames)\n    for f in files:\n        DBG('opening %s', f.filename)\n        f.load()\n    if args.table:\n        fields = ['filename', 'variable_name'] + TI_FIELDS",
        "detail": "qemu.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "PATTERN_HELP",
        "kind": 5,
        "importPath": "qemu.scripts.codeconverter.converter",
        "description": "qemu.scripts.codeconverter.converter",
        "peekOfCode": "PATTERN_HELP = ('\\n'.join(\"  %s: %s\" % (n, str(c.__doc__).strip())\n                for (n,c) in sorted(match_class_dict().items())\n                if c.has_replacement_rule()))\ndef main() -> None:\n    p = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)\n    p.add_argument('filenames', nargs='+')\n    p.add_argument('--passes', type=int, default=1,\n                   help=\"Number of passes (0 means unlimited)\")\n    p.add_argument('--pattern', required=True, action='append',\n                   default=[], dest='patterns',",
        "detail": "qemu.scripts.codeconverter.converter",
        "documentation": {}
    },
    {
        "label": "create_parser",
        "kind": 2,
        "importPath": "qemu.scripts.coverage.compare_gcov_json",
        "description": "qemu.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def create_parser():\n    parser = argparse.ArgumentParser(\n        prog='compare_gcov_json',\n        description='analyse the differences in coverage between two runs')\n    parser.add_argument('-a', type=Path, default=None,\n                        help=('First file to check'))\n    parser.add_argument('-b', type=Path, default=None,\n                        help=('Second file to check'))\n    parser.add_argument('--verbose', action='store_true', default=False,\n                        help=('A minimal verbosity level that prints the '",
        "detail": "qemu.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "load_json",
        "kind": 2,
        "importPath": "qemu.scripts.coverage.compare_gcov_json",
        "description": "qemu.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def load_json(json_file_path: Path, verbose = False) -> dict[str, set[int]]:\n    with open(json_file_path) as f:\n        data = json.load(f)\n    root_dir = json_file_path.absolute().parent\n    covered_lines = dict()\n    for filecov in data[\"files\"]:\n        file_path = Path(filecov[\"file\"])\n        # account for generated files - map into src tree\n        resolved_path = Path(file_path).absolute()\n        if resolved_path.is_relative_to(root_dir):",
        "detail": "qemu.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "find_missing_files",
        "kind": 2,
        "importPath": "qemu.scripts.coverage.compare_gcov_json",
        "description": "qemu.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def find_missing_files(first, second):\n    \"\"\"\n    Return a list of files not covered in the second set\n    \"\"\"\n    missing_files = []\n    for f in sorted(first):\n        file_a = first[f]\n        try:\n            file_b = second[f]\n        except KeyError:",
        "detail": "qemu.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.coverage.compare_gcov_json",
        "description": "qemu.scripts.coverage.compare_gcov_json",
        "peekOfCode": "def main():\n    \"\"\"\n    Script entry point\n    \"\"\"\n    parser = create_parser()\n    args = parser.parse_args()\n    if not args.a or not args.b:\n        print(\"We need two files to compare\")\n        sys.exit(1)\n    first_coverage = load_json(args.a, args.verbose)",
        "detail": "qemu.scripts.coverage.compare_gcov_json",
        "documentation": {}
    },
    {
        "label": "get_string_struct",
        "kind": 2,
        "importPath": "qemu.scripts.modules.module_block",
        "description": "qemu.scripts.modules.module_block",
        "peekOfCode": "def get_string_struct(line):\n    data = line.split()\n    # data[0] -> struct element name\n    # data[1] -> =\n    # data[2] -> value\n    return data[2].replace('\"', '')[:-1]\ndef add_module(fheader, library, format_name, protocol_name):\n    lines = []\n    lines.append('.library_name = \"' + library + '\",')\n    if format_name != \"\":",
        "detail": "qemu.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "add_module",
        "kind": 2,
        "importPath": "qemu.scripts.modules.module_block",
        "description": "qemu.scripts.modules.module_block",
        "peekOfCode": "def add_module(fheader, library, format_name, protocol_name):\n    lines = []\n    lines.append('.library_name = \"' + library + '\",')\n    if format_name != \"\":\n        lines.append('.format_name = \"' + format_name + '\",')\n    if protocol_name != \"\":\n        lines.append('.protocol_name = \"' + protocol_name + '\",')\n    text = '\\n        '.join(lines)\n    fheader.write('\\n    {\\n        ' + text + '\\n    },')\ndef process_file(fheader, filename):",
        "detail": "qemu.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "process_file",
        "kind": 2,
        "importPath": "qemu.scripts.modules.module_block",
        "description": "qemu.scripts.modules.module_block",
        "peekOfCode": "def process_file(fheader, filename):\n    # This parser assumes the coding style rules are being followed\n    with open(filename, \"r\") as cfile:\n        found_start = False\n        library, _ = os.path.splitext(os.path.basename(filename))\n        for line in cfile:\n            if found_start:\n                line = line.replace('\\n', '')\n                if line.find(\".format_name\") != -1:\n                    format_name = get_string_struct(line)",
        "detail": "qemu.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "print_top",
        "kind": 2,
        "importPath": "qemu.scripts.modules.module_block",
        "description": "qemu.scripts.modules.module_block",
        "peekOfCode": "def print_top(fheader):\n    fheader.write('''/* AUTOMATICALLY GENERATED, DO NOT MODIFY */\n/*\n * QEMU Block Module Infrastructure\n *\n * Authors:\n *  Marc Mari       <markmb@redhat.com>\n */\n''')\n    fheader.write('''#ifndef QEMU_MODULE_BLOCK_H",
        "detail": "qemu.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "print_bottom",
        "kind": 2,
        "importPath": "qemu.scripts.modules.module_block",
        "description": "qemu.scripts.modules.module_block",
        "peekOfCode": "def print_bottom(fheader):\n    fheader.write('''\n};\n#endif\n''')\nif __name__ == '__main__':\n    # First argument: output file\n    # All other arguments: modules source files (.c)\n    output_file = sys.argv[1]\n    with open(output_file, 'w') as fheader:",
        "detail": "qemu.scripts.modules.module_block",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace\nBy default, will try to use the second-to-last line in the output to identify\nwhether the crash occred. Optionally, manually set a string that idenitifes the\ncrash by setting CRASH_TOKEN=\nOptions:\n-M1: enable a loop around the remove minimizer, which may help decrease some\n     timing dependent instructions. Off by default.",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "check_if_trace_crashes",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def check_if_trace_crashes(trace, path):\n    with open(path, \"w\") as tracefile:\n        tracefile.write(\"\".join(trace))\n    rc = subprocess.Popen(\"timeout -s 9 {timeout}s {qemu_path} {qemu_args} 2>&1\\\n    < {trace_path}\".format(timeout=TIMEOUT,\n                           qemu_path=QEMU_PATH,\n                           qemu_args=QEMU_ARGS,\n                           trace_path=path),\n                          shell=True,\n                          stdin=subprocess.PIPE,",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "split_write_hint",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def split_write_hint(newtrace, i):\n    HINT_LEN = 3 # > 2\n    if i <=(HINT_LEN-1):\n        return None\n    #find previous continuous write traces\n    k = 0\n    l = i-1\n    writes = []\n    while (k != HINT_LEN and l >= 0):\n        if newtrace[l].startswith(\"write \"):",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "remove_lines",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def remove_lines(newtrace, outpath):\n    remove_step = 1\n    i = 0\n    while i < len(newtrace):\n        # 1.) Try to remove lines completely and reproduce the crash.\n        # If it works, we're done.\n        if (i+remove_step) >= len(newtrace):\n            remove_step = 1\n        prior = newtrace[i:i+remove_step]\n        for j in range(i, i+remove_step):",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "clear_bits",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def clear_bits(newtrace, outpath):\n    # try setting bits in operands of out/write to zero\n    i = 0\n    while i < len(newtrace):\n        if (not newtrace[i].startswith(\"write \") and not\n           newtrace[i].startswith(\"out\")):\n           i += 1\n           continue\n        # write ADDR SIZE DATA\n        # outx ADDR VALUE",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "minimize_trace",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "def minimize_trace(inpath, outpath):\n    global TIMEOUT\n    with open(inpath) as f:\n        trace = f.readlines()\n    start = time.time()\n    if not check_if_trace_crashes(trace, outpath):\n        sys.exit(\"The input qtest trace didn't cause a crash...\")\n    end = time.time()\n    print(\"Crashed in {} seconds\".format(end-start))\n    TIMEOUT = (end-start)*5",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "QEMU_ARGS",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "QEMU_ARGS = None\nQEMU_PATH = None\nTIMEOUT = 5\nCRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "QEMU_PATH",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "QEMU_PATH = None\nTIMEOUT = 5\nCRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "TIMEOUT = 5\nCRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "CRASH_TOKEN",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "CRASH_TOKEN = None\n# Minimization levels\nM1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "M1",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "M1 = False # try removing IO commands iteratively\nM2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "M2",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "M2 = False # try setting bits in operand of write/out to zero\nwrite_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace\nBy default, will try to use the second-to-last line in the output to identify",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "write_suffix_lookup",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "write_suffix_lookup = {\"b\": (1, \"B\"),\n                       \"w\": (2, \"H\"),\n                       \"l\": (4, \"L\"),\n                       \"q\": (8, \"Q\")}\ndef usage():\n    sys.exit(\"\"\"\\\nUsage:\nQEMU_PATH=\"/path/to/qemu\" QEMU_ARGS=\"args\" {} [Options] input_trace output_trace\nBy default, will try to use the second-to-last line in the output to identify\nwhether the crash occred. Optionally, manually set a string that idenitifes the",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "deduplication_note",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "peekOfCode": "deduplication_note = \"\"\"\\n\\\nNote: While trimming the input, sometimes the mutated trace triggers a different\ntype crash but indicates the same bug. Under this situation, our minimizer is\nincapable of recognizing and stopped from removing it. In the future, we may\nuse a more sophisticated crash case deduplication method.\n\\n\"\"\"\ndef check_if_trace_crashes(trace, path):\n    with open(path, \"w\") as tracefile:\n        tracefile.write(\"\".join(trace))\n    rc = subprocess.Popen(\"timeout -s 9 {timeout}s {qemu_path} {qemu_args} 2>&1\\",
        "detail": "qemu.scripts.oss-fuzz.minimize_qtest_trace",
        "documentation": {}
    },
    {
        "label": "c_header",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_header(owner):\n    return \"\"\"/*\n * Autogenerated Fuzzer Test Case\n *\n * Copyright (c) {date} {owner}\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n#include \"qemu/osdep.h\"",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "c_comment",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_comment(s):\n    \"\"\" Return a multi-line C comment. Assume the text is already wrapped \"\"\"\n    return \"/*\\n * \" + \"\\n * \".join(s.splitlines()) + \"\\n*/\"\ndef print_c_function(s):\n    print(\"/* \")\n    for l in s.splitlines():\n        print(\" * {}\".format(l))\ndef bash_reproducer(path, args, trace):\n    result = '\\\\\\n'.join(textwrap.wrap(\"cat << EOF | {} {}\".format(path, args),\n                                       72, break_on_hyphens=False,",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "print_c_function",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def print_c_function(s):\n    print(\"/* \")\n    for l in s.splitlines():\n        print(\" * {}\".format(l))\ndef bash_reproducer(path, args, trace):\n    result = '\\\\\\n'.join(textwrap.wrap(\"cat << EOF | {} {}\".format(path, args),\n                                       72, break_on_hyphens=False,\n                                       drop_whitespace=False))\n    for l in trace.splitlines():\n        result += \"\\n\" + '\\\\\\n'.join(textwrap.wrap(l,72,drop_whitespace=False))",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "bash_reproducer",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def bash_reproducer(path, args, trace):\n    result = '\\\\\\n'.join(textwrap.wrap(\"cat << EOF | {} {}\".format(path, args),\n                                       72, break_on_hyphens=False,\n                                       drop_whitespace=False))\n    for l in trace.splitlines():\n        result += \"\\n\" + '\\\\\\n'.join(textwrap.wrap(l,72,drop_whitespace=False))\n    result += \"\\nEOF\"\n    return result\ndef c_reproducer(name, args, trace):\n    result = []",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "c_reproducer",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_reproducer(name, args, trace):\n    result = []\n    result.append(\"\"\"static void {}(void)\\n{{\"\"\".format(name))\n    # libqtest will add its own qtest args, so get rid of them\n    args = args.replace(\"-accel qtest\",\"\")\n    args = args.replace(\",accel=qtest\",\"\")\n    args = args.replace(\"-machine accel=qtest\",\"\")\n    args = args.replace(\"-qtest stdio\",\"\")\n    result.append(\"\"\"QTestState *s = qtest_init(\"{}\");\"\"\".format(args))\n    for l in trace.splitlines():",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "c_main",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def c_main(name, arch):\n    return \"\"\"int main(int argc, char **argv)\n{{\n    const char *arch = qtest_get_arch();\n    g_test_init(&argc, &argv, NULL);\n   if (strcmp(arch, \"{arch}\") == 0) {{\n        qtest_add_func(\"fuzz/{name}\",{name});\n   }}\n   return g_test_run();\n}}\"\"\".format(name=name, arch=arch)",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    group = parser.add_mutually_exclusive_group()\n    group.add_argument(\"-bash\", help=\"Only output a copy-pastable bash command\",\n                        action=\"store_true\")\n    group.add_argument(\"-c\", help=\"Only output a c function\",\n                        action=\"store_true\")\n    parser.add_argument('-owner', help=\"If generating complete C source code, \\\n                        this specifies the Copyright owner\",\n                        nargs='?', default=\"<name of author>\")",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.output_reproducer",
        "description": "qemu.scripts.oss-fuzz.output_reproducer",
        "peekOfCode": "__maintainer__ = \"Alexander Bulekov\"\n__email__      = \"alxndr@bu.edu\"\ndef c_header(owner):\n    return \"\"\"/*\n * Autogenerated Fuzzer Test Case\n *\n * Copyright (c) {date} {owner}\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.",
        "detail": "qemu.scripts.oss-fuzz.output_reproducer",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "peekOfCode": "def usage():\n    sys.exit(\"Usage: {} /path/to/qtest_log_output\".format((sys.argv[0])))\ndef main(filename):\n    with open(filename, \"r\") as f:\n        trace = f.readlines()\n    # Leave only lines that look like logged qtest commands\n    trace[:] = [x.strip() for x in trace if \"[R +\" in x\n                or \"[S +\" in x and \"CLOSED\" not in x]\n    for i in range(len(trace)):\n        if i+1 < len(trace):",
        "detail": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "peekOfCode": "def main(filename):\n    with open(filename, \"r\") as f:\n        trace = f.readlines()\n    # Leave only lines that look like logged qtest commands\n    trace[:] = [x.strip() for x in trace if \"[R +\" in x\n                or \"[S +\" in x and \"CLOSED\" not in x]\n    for i in range(len(trace)):\n        if i+1 < len(trace):\n            if \"[DMA]\" in trace[i+1]:\n                if \"[DOUBLE-FETCH]\" in trace[i+1]:",
        "detail": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "description": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "peekOfCode": "__maintainer__ = \"Alexander Bulekov\"\n__email__      = \"alxndr@bu.edu\"\ndef usage():\n    sys.exit(\"Usage: {} /path/to/qtest_log_output\".format((sys.argv[0])))\ndef main(filename):\n    with open(filename, \"r\") as f:\n        trace = f.readlines()\n    # Leave only lines that look like logged qtest commands\n    trace[:] = [x.strip() for x in trace if \"[R +\" in x\n                or \"[S +\" in x and \"CLOSED\" not in x]",
        "detail": "qemu.scripts.oss-fuzz.reorder_fuzzer_qtest_trace",
        "documentation": {}
    },
    {
        "label": "get_JIT_line",
        "kind": 2,
        "importPath": "qemu.scripts.performance.dissect",
        "description": "qemu.scripts.performance.dissect",
        "peekOfCode": "def get_JIT_line(callgrind_data):\n    \"\"\"\n    Search for the first instance of the JIT call in\n    the callgrind_annotate output when ran using --tree=caller\n    This is equivalent to the self number of instructions of JIT.\n    Parameters:\n    callgrind_data (list): callgrind_annotate output\n    Returns:\n    (int): Line number\n    \"\"\"",
        "detail": "qemu.scripts.performance.dissect",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.performance.dissect",
        "description": "qemu.scripts.performance.dissect",
        "peekOfCode": "def main():\n    # Parse the command line arguments\n    parser = argparse.ArgumentParser(\n        usage='dissect.py [-h] -- '\n        '<qemu executable> [<qemu executable options>] '\n        '<target executable> [<target executable options>]')\n    parser.add_argument('command', type=str, nargs='+', help=argparse.SUPPRESS)\n    args = parser.parse_args()\n    # Extract the needed variables from the args\n    command = args.command",
        "detail": "qemu.scripts.performance.dissect",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "parser = argparse.ArgumentParser(\n    usage='topN_callgrind.py [-h] [-n] <number of displayed top functions>  -- '\n          '<qemu executable> [<qemu executable options>] '\n          '<target executable> [<target executable options>]')\nparser.add_argument('-n', dest='top', type=int, default=25,\n                    help='Specify the number of top functions to print.')\nparser.add_argument('command', type=str, nargs='+', help=argparse.SUPPRESS)\nargs = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "args = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command\ntop = args.top\n# Insure that valgrind is installed\ncheck_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "command = args.command\ntop = args.top\n# Insure that valgrind is installed\ncheck_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind\ncallgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "top",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "top = args.top\n# Insure that valgrind is installed\ncheck_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind\ncallgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]\n    + command),",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "check_valgrind_presence",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "check_valgrind_presence = subprocess.run([\"which\", \"valgrind\"],\n                                         stdout=subprocess.DEVNULL)\nif check_valgrind_presence.returncode:\n    sys.exit(\"Please install valgrind before running the script!\")\n# Run callgrind\ncallgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]\n    + command),\n    stdout=subprocess.DEVNULL,\n    stderr=subprocess.PIPE)",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "callgrind",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "callgrind = subprocess.run((\n    [\"valgrind\", \"--tool=callgrind\", \"--callgrind-out-file=/tmp/callgrind.data\"]\n    + command),\n    stdout=subprocess.DEVNULL,\n    stderr=subprocess.PIPE)\nif callgrind.returncode:\n    sys.exit(callgrind.stderr.decode(\"utf-8\"))\n# Save callgrind_annotate output to /tmp/callgrind_annotate.out\nwith open(\"/tmp/callgrind_annotate.out\", \"w\") as output:\n    callgrind_annotate = subprocess.run([\"callgrind_annotate\",",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "callgrind_data",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "callgrind_data = []\nwith open('/tmp/callgrind_annotate.out', 'r') as data:\n    callgrind_data = data.readlines()\n# Line number with the total number of instructions\ntotal_instructions_line_number = 20\n# Get the total number of instructions\ntotal_instructions_line_data = callgrind_data[total_instructions_line_number]\ntotal_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_instructions_line_number",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "total_instructions_line_number = 20\n# Get the total number of instructions\ntotal_instructions_line_data = callgrind_data[total_instructions_line_number]\ntotal_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_instructions_line_data",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "total_instructions_line_data = callgrind_data[total_instructions_line_number]\ntotal_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_number_of_instructions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "total_number_of_instructions = total_instructions_line_data.split(' ')[0]\ntotal_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "total_number_of_instructions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "total_number_of_instructions = int(\n    total_number_of_instructions.replace(',', ''))\n# Line number with the top function\nfirst_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "first_func_line",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "first_func_line = 25\n# Number of functions recorded by callgrind, last two lines are always empty\nnumber_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "number_of_functions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "number_of_functions = len(callgrind_data) - first_func_line - 2\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "number_of_top_functions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "number_of_top_functions = (top if number_of_functions >\n                           top else number_of_functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Function Name',\n                                                         'Source File',",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "top_functions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_callgrind",
        "description": "qemu.scripts.performance.topN_callgrind",
        "peekOfCode": "top_functions = callgrind_data[first_func_line:\n                               first_func_line + number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Function Name',\n                                                         'Source File',\n                                                         '-' * 4,\n                                                         '-' * 10,\n                                                         '-' * 30,",
        "detail": "qemu.scripts.performance.topN_callgrind",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "parser = argparse.ArgumentParser(\n    usage='topN_perf.py [-h] [-n] <number of displayed top functions >  -- '\n          '<qemu executable> [<qemu executable options>] '\n          '<target executable> [<target executable options>]')\nparser.add_argument('-n', dest='top', type=int, default=25,\n                    help='Specify the number of top functions to print.')\nparser.add_argument('command', type=str, nargs='+', help=argparse.SUPPRESS)\nargs = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "args = parser.parse_args()\n# Extract the needed variables from the args\ncommand = args.command\ntop = args.top\n# Insure that perf is installed\ncheck_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "command = args.command\ntop = args.top\n# Insure that perf is installed\ncheck_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf\ncheck_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "top",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "top = args.top\n# Insure that perf is installed\ncheck_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf\ncheck_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,\n                                          stderr=subprocess.DEVNULL)",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "check_perf_presence",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "check_perf_presence = subprocess.run([\"which\", \"perf\"],\n                                     stdout=subprocess.DEVNULL)\nif check_perf_presence.returncode:\n    sys.exit(\"Please install perf before running the script!\")\n# Insure user has previllage to run perf\ncheck_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,\n                                          stderr=subprocess.DEVNULL)\nif check_perf_executability.returncode:\n    sys.exit(",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "check_perf_executability",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "check_perf_executability = subprocess.run([\"perf\", \"stat\", \"ls\", \"/\"],\n                                          stdout=subprocess.DEVNULL,\n                                          stderr=subprocess.DEVNULL)\nif check_perf_executability.returncode:\n    sys.exit(\n\"\"\"\nError:\nYou may not have permission to collect stats.\nConsider tweaking /proc/sys/kernel/perf_event_paranoid,\nwhich controls use of the performance events system by",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "perf_record",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "perf_record = subprocess.run(([\"perf\", \"record\", \"--output=/tmp/perf.data\"] +\n                              command),\n                             stdout=subprocess.DEVNULL,\n                             stderr=subprocess.PIPE)\nif perf_record.returncode:\n    os.unlink('/tmp/perf.data')\n    sys.exit(perf_record.stderr.decode(\"utf-8\"))\n# Save perf report output to /tmp/perf_report.out\nwith open(\"/tmp/perf_report.out\", \"w\") as output:\n    perf_report = subprocess.run(",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "functions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "functions = []\nwith open(\"/tmp/perf_report.out\", \"r\") as data:\n    # Only read lines that are not comments (comments start with #)\n    # Only read lines that are not empty\n    functions = [line for line in data.readlines() if line and line[0]\n                 != '#' and line[0] != \"\\n\"]\n# Limit the number of top functions to \"top\"\nnumber_of_top_functions = top if len(functions) > top else len(functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = functions[:number_of_top_functions]",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "number_of_top_functions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "number_of_top_functions = top if len(functions) > top else len(functions)\n# Store the data of the top functions in top_functions[]\ntop_functions = functions[:number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Name',\n                                                         'Invoked by',\n                                                         '-' * 4,\n                                                         '-' * 10,",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "top_functions",
        "kind": 5,
        "importPath": "qemu.scripts.performance.topN_perf",
        "description": "qemu.scripts.performance.topN_perf",
        "peekOfCode": "top_functions = functions[:number_of_top_functions]\n# Print table header\nprint('{:>4}  {:>10}  {:<30}  {}\\n{}  {}  {}  {}'.format('No.',\n                                                         'Percentage',\n                                                         'Name',\n                                                         'Invoked by',\n                                                         '-' * 4,\n                                                         '-' * 10,\n                                                         '-' * 30,\n                                                         '-' * 25))",
        "detail": "qemu.scripts.performance.topN_perf",
        "documentation": {}
    },
    {
        "label": "QAPIBackend",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.backend",
        "description": "qemu.scripts.qapi.backend",
        "peekOfCode": "class QAPIBackend(ABC):\n    @abstractmethod\n    def generate(self,\n                 schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str,\n                 unmask: bool,\n                 builtins: bool,\n                 gen_tracing: bool) -> None:\n        \"\"\"",
        "detail": "qemu.scripts.qapi.backend",
        "documentation": {}
    },
    {
        "label": "QAPICBackend",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.backend",
        "description": "qemu.scripts.qapi.backend",
        "peekOfCode": "class QAPICBackend(QAPIBackend):\n    def generate(self,\n                 schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str,\n                 unmask: bool,\n                 builtins: bool,\n                 gen_tracing: bool) -> None:\n        \"\"\"\n        Generate C code for the given schema into the target directory.",
        "detail": "qemu.scripts.qapi.backend",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenCommandVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "class QAPISchemaGenCommandVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str, gen_tracing: bool):\n        super().__init__(\n            prefix, 'qapi-commands',\n            ' * Schema-defined QAPI/QMP commands', None, __doc__,\n            gen_tracing=gen_tracing)\n        self._visited_ret_types: Dict[QAPIGenC, Set[QAPISchemaType]] = {}\n        self._gen_tracing = gen_tracing\n    def _begin_user_module(self, name: str) -> None:\n        self._visited_ret_types[self._genc] = set()",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_command_decl",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_command_decl(name: str,\n                     arg_type: Optional[QAPISchemaObjectType],\n                     boxed: bool,\n                     ret_type: Optional[QAPISchemaType],\n                     coroutine: bool) -> str:\n    return mcgen('''\n%(c_type)s %(coroutine_fn)sqmp_%(c_name)s(%(params)s);\n''',\n                 c_type=(ret_type and ret_type.c_type()) or 'void',\n                 coroutine_fn='coroutine_fn ' if coroutine else '',",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_call",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_call(name: str,\n             arg_type: Optional[QAPISchemaObjectType],\n             boxed: bool,\n             ret_type: Optional[QAPISchemaType],\n             gen_tracing: bool) -> str:\n    ret = ''\n    argstr = ''\n    if boxed:\n        assert arg_type\n        argstr = '&arg, '",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_marshal_output",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_marshal_output(ret_type: QAPISchemaType) -> str:\n    return mcgen('''\nstatic void qmp_marshal_output_%(c_name)s(%(c_type)s ret_in,\n                                QObject **ret_out, Error **errp)\n{\n    Visitor *v;\n    v = qobject_output_visitor_new_qmp(ret_out);\n    if (visit_type_%(c_name)s(v, \"unused\", &ret_in, errp)) {\n        visit_complete(v, ret_out);\n    }",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "build_marshal_proto",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def build_marshal_proto(name: str,\n                        coroutine: bool) -> str:\n    return ('void %(coroutine_fn)sqmp_marshal_%(c_name)s(%(params)s)' % {\n        'coroutine_fn': 'coroutine_fn ' if coroutine else '',\n        'c_name': c_name(name),\n        'params': 'QDict *args, QObject **ret, Error **errp',\n    })\ndef gen_marshal_decl(name: str,\n                     coroutine: bool) -> str:\n    return mcgen('''",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_marshal_decl",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_marshal_decl(name: str,\n                     coroutine: bool) -> str:\n    return mcgen('''\n%(proto)s;\n''',\n                 proto=build_marshal_proto(name, coroutine))\ndef gen_trace(name: str) -> str:\n    return mcgen('''\nqmp_enter_%(name)s(const char *json) \"%%s\"\nqmp_exit_%(name)s(const char *result, bool succeeded) \"%%s %%d\"",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_trace",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_trace(name: str) -> str:\n    return mcgen('''\nqmp_enter_%(name)s(const char *json) \"%%s\"\nqmp_exit_%(name)s(const char *result, bool succeeded) \"%%s %%d\"\n''',\n                 name=c_name(name))\ndef gen_marshal(name: str,\n                arg_type: Optional[QAPISchemaObjectType],\n                boxed: bool,\n                ret_type: Optional[QAPISchemaType],",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_marshal",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_marshal(name: str,\n                arg_type: Optional[QAPISchemaObjectType],\n                boxed: bool,\n                ret_type: Optional[QAPISchemaType],\n                gen_tracing: bool,\n                coroutine: bool) -> str:\n    have_args = boxed or (arg_type and not arg_type.is_empty())\n    if have_args:\n        assert arg_type is not None\n        arg_type_c_name = arg_type.c_name()",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_register_command",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_register_command(name: str,\n                         features: List[QAPISchemaFeature],\n                         success_response: bool,\n                         allow_oob: bool,\n                         allow_preconfig: bool,\n                         coroutine: bool) -> str:\n    options = []\n    if not success_response:\n        options += ['QCO_NO_SUCCESS_RESP']\n    if allow_oob:",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "gen_commands",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.commands",
        "description": "qemu.scripts.qapi.commands",
        "peekOfCode": "def gen_commands(schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str,\n                 gen_tracing: bool) -> None:\n    vis = QAPISchemaGenCommandVisitor(prefix, gen_tracing)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.scripts.qapi.commands",
        "documentation": {}
    },
    {
        "label": "Indentation",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "class Indentation:\n    \"\"\"\n    Indentation level management.\n    :param initial: Initial number of spaces, default 0.\n    \"\"\"\n    def __init__(self, initial: int = 0) -> None:\n        self._level = initial\n    def __repr__(self) -> str:\n        return \"{}({:d})\".format(type(self).__name__, self._level)\n    def __str__(self) -> str:",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "camel_to_upper",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def camel_to_upper(value: str) -> str:\n    \"\"\"\n    Converts CamelCase to CAMEL_CASE.\n    Examples::\n        ENUMName -> ENUM_NAME\n        EnumName1 -> ENUM_NAME1\n        ENUM_NAME -> ENUM_NAME\n        ENUM_NAME1 -> ENUM_NAME1\n        ENUM_Name2 -> ENUM_NAME2\n        ENUM24_Name -> ENUM24_NAME",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "c_enum_const",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def c_enum_const(type_name: str,\n                 const_name: str,\n                 prefix: Optional[str] = None) -> str:\n    \"\"\"\n    Generate a C enumeration constant name.\n    :param type_name: The name of the enumeration.\n    :param const_name: The name of this constant.\n    :param prefix: Optional, prefix that overrides the type_name.\n    \"\"\"\n    if prefix is None:",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "c_name",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def c_name(name: str, protect: bool = True) -> str:\n    \"\"\"\n    Map ``name`` to a valid C identifier.\n    Used for converting 'name' from a 'name':'type' qapi definition\n    into a generated struct member, as well as converting type names\n    into substrings of a generated C function name.\n    '__a.b_c' -> '__a_b_c', 'x-foo' -> 'x_foo'\n    protect=True: 'int' -> 'q_int'; protect=False: 'int' -> 'int'\n    :param name: The name to map.\n    :param protect: If true, avoid returning certain ticklish identifiers",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "cgen",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def cgen(code: str, **kwds: object) -> str:\n    \"\"\"\n    Generate ``code`` with ``kwds`` interpolated.\n    Obey `indent`, and strip `EATSPACE`.\n    \"\"\"\n    raw = code % kwds\n    pfx = str(indent)\n    if pfx:\n        raw = re.sub(r'^(?!(#|$))', pfx, raw, flags=re.MULTILINE)\n    return re.sub(re.escape(EATSPACE) + r' *', '', raw)",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "mcgen",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def mcgen(code: str, **kwds: object) -> str:\n    if code[0] == '\\n':\n        code = code[1:]\n    return cgen(code, **kwds)\ndef c_fname(filename: str) -> str:\n    return re.sub(r'[^A-Za-z0-9_]', '_', filename)\ndef guardstart(name: str) -> str:\n    return mcgen('''\n#ifndef %(name)s\n#define %(name)s",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "c_fname",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def c_fname(filename: str) -> str:\n    return re.sub(r'[^A-Za-z0-9_]', '_', filename)\ndef guardstart(name: str) -> str:\n    return mcgen('''\n#ifndef %(name)s\n#define %(name)s\n''',\n                 name=c_fname(name).upper())\ndef guardend(name: str) -> str:\n    return mcgen('''",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "guardstart",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def guardstart(name: str) -> str:\n    return mcgen('''\n#ifndef %(name)s\n#define %(name)s\n''',\n                 name=c_fname(name).upper())\ndef guardend(name: str) -> str:\n    return mcgen('''\n#endif /* %(name)s */\n''',",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "guardend",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def guardend(name: str) -> str:\n    return mcgen('''\n#endif /* %(name)s */\n''',\n                 name=c_fname(name).upper())\ndef gen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]],\n               cond_fmt: str, not_fmt: str,\n               all_operator: str, any_operator: str) -> str:\n    def do_gen(ifcond: Union[str, Dict[str, Any]],\n               need_parens: bool) -> str:",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "gen_ifcond",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def gen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]],\n               cond_fmt: str, not_fmt: str,\n               all_operator: str, any_operator: str) -> str:\n    def do_gen(ifcond: Union[str, Dict[str, Any]],\n               need_parens: bool) -> str:\n        if isinstance(ifcond, str):\n            return cond_fmt % ifcond\n        assert isinstance(ifcond, dict) and len(ifcond) == 1\n        if 'not' in ifcond:\n            return not_fmt % do_gen(ifcond['not'], True)",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "cgen_ifcond",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def cgen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]]) -> str:\n    return gen_ifcond(ifcond, 'defined(%s)', '!%s', ' && ', ' || ')\ndef docgen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]]) -> str:\n    # TODO Doc generated for conditions needs polish\n    return gen_ifcond(ifcond, '%s', 'not %s', ' and ', ' or ')\ndef gen_if(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#if %(cond)s",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "docgen_ifcond",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def docgen_ifcond(ifcond: Optional[Union[str, Dict[str, Any]]]) -> str:\n    # TODO Doc generated for conditions needs polish\n    return gen_ifcond(ifcond, '%s', 'not %s', ' and ', ' or ')\ndef gen_if(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#if %(cond)s\n''', cond=cond)\ndef gen_endif(cond: str) -> str:",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "gen_if",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def gen_if(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#if %(cond)s\n''', cond=cond)\ndef gen_endif(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "gen_endif",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def gen_endif(cond: str) -> str:\n    if not cond:\n        return ''\n    return mcgen('''\n#endif /* %(cond)s */\n''', cond=cond)\ndef must_match(pattern: str, string: str) -> Match[str]:\n    match = re.match(pattern, string)\n    assert match is not None\n    return match",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "must_match",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "def must_match(pattern: str, string: str) -> Match[str]:\n    match = re.match(pattern, string)\n    assert match is not None\n    return match",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "EATSPACE",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "EATSPACE = '\\033EATSPACE.'\nPOINTER_SUFFIX = ' *' + EATSPACE\ndef camel_to_upper(value: str) -> str:\n    \"\"\"\n    Converts CamelCase to CAMEL_CASE.\n    Examples::\n        ENUMName -> ENUM_NAME\n        EnumName1 -> ENUM_NAME1\n        ENUM_NAME -> ENUM_NAME\n        ENUM_NAME1 -> ENUM_NAME1",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "POINTER_SUFFIX",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "POINTER_SUFFIX = ' *' + EATSPACE\ndef camel_to_upper(value: str) -> str:\n    \"\"\"\n    Converts CamelCase to CAMEL_CASE.\n    Examples::\n        ENUMName -> ENUM_NAME\n        EnumName1 -> ENUM_NAME1\n        ENUM_NAME -> ENUM_NAME\n        ENUM_NAME1 -> ENUM_NAME1\n        ENUM_Name2 -> ENUM_NAME2",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "indent",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.common",
        "description": "qemu.scripts.qapi.common",
        "peekOfCode": "indent = Indentation()\ndef cgen(code: str, **kwds: object) -> str:\n    \"\"\"\n    Generate ``code`` with ``kwds`` interpolated.\n    Obey `indent`, and strip `EATSPACE`.\n    \"\"\"\n    raw = code % kwds\n    pfx = str(indent)\n    if pfx:\n        raw = re.sub(r'^(?!(#|$))', pfx, raw, flags=re.MULTILINE)",
        "detail": "qemu.scripts.qapi.common",
        "documentation": {}
    },
    {
        "label": "QAPIError",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.error",
        "description": "qemu.scripts.qapi.error",
        "peekOfCode": "class QAPIError(Exception):\n    \"\"\"Base class for all exceptions from the QAPI package.\"\"\"\nclass QAPISourceError(QAPIError):\n    \"\"\"Error class for all exceptions identifying a source location.\"\"\"\n    def __init__(self,\n                 info: Optional[QAPISourceInfo],\n                 msg: str,\n                 col: Optional[int] = None):\n        super().__init__()\n        self.info = info",
        "detail": "qemu.scripts.qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPISourceError",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.error",
        "description": "qemu.scripts.qapi.error",
        "peekOfCode": "class QAPISourceError(QAPIError):\n    \"\"\"Error class for all exceptions identifying a source location.\"\"\"\n    def __init__(self,\n                 info: Optional[QAPISourceInfo],\n                 msg: str,\n                 col: Optional[int] = None):\n        super().__init__()\n        self.info = info\n        self.msg = msg\n        self.col = col",
        "detail": "qemu.scripts.qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPISemError",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.error",
        "description": "qemu.scripts.qapi.error",
        "peekOfCode": "class QAPISemError(QAPISourceError):\n    \"\"\"Error class for semantic QAPI errors.\"\"\"",
        "detail": "qemu.scripts.qapi.error",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenEventVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.events",
        "description": "qemu.scripts.qapi.events",
        "peekOfCode": "class QAPISchemaGenEventVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-events',\n            ' * Schema-defined QAPI/QMP events', None, __doc__)\n        self._event_enum_name = c_name(prefix + 'QAPIEvent', protect=False)\n        self._event_enum_members: List[QAPISchemaEnumMember] = []\n        self._event_emit_name = c_name(prefix + 'qapi_event_emit')\n    def _begin_user_module(self, name: str) -> None:\n        events = self._module_basename('qapi-events', name)",
        "detail": "qemu.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "build_event_send_proto",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.events",
        "description": "qemu.scripts.qapi.events",
        "peekOfCode": "def build_event_send_proto(name: str,\n                           arg_type: Optional[QAPISchemaObjectType],\n                           boxed: bool) -> str:\n    return 'void qapi_event_send_%(c_name)s(%(param)s)' % {\n        'c_name': c_name(name.lower()),\n        'param': build_params(arg_type, boxed)}\ndef gen_event_send_decl(name: str,\n                        arg_type: Optional[QAPISchemaObjectType],\n                        boxed: bool) -> str:\n    return mcgen('''",
        "detail": "qemu.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_event_send_decl",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.events",
        "description": "qemu.scripts.qapi.events",
        "peekOfCode": "def gen_event_send_decl(name: str,\n                        arg_type: Optional[QAPISchemaObjectType],\n                        boxed: bool) -> str:\n    return mcgen('''\n%(proto)s;\n''',\n                 proto=build_event_send_proto(name, arg_type, boxed))\ndef gen_param_var(typ: QAPISchemaObjectType) -> str:\n    \"\"\"\n    Generate a struct variable holding the event parameters.",
        "detail": "qemu.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_param_var",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.events",
        "description": "qemu.scripts.qapi.events",
        "peekOfCode": "def gen_param_var(typ: QAPISchemaObjectType) -> str:\n    \"\"\"\n    Generate a struct variable holding the event parameters.\n    Initialize it with the function arguments defined in `gen_event_send`.\n    \"\"\"\n    assert not typ.branches\n    ret = mcgen('''\n    %(c_name)s param = {\n''',\n                c_name=typ.c_name())",
        "detail": "qemu.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_event_send",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.events",
        "description": "qemu.scripts.qapi.events",
        "peekOfCode": "def gen_event_send(name: str,\n                   arg_type: Optional[QAPISchemaObjectType],\n                   features: List[QAPISchemaFeature],\n                   boxed: bool,\n                   event_enum_name: str,\n                   event_emit: str) -> str:\n    # FIXME: Our declaration of local variables (and of 'errp' in the\n    # parameter list) can collide with exploded members of the event's\n    # data type passed in as parameters.  If this collision ever hits in\n    # practice, we can rename our local variables with a leading _ prefix,",
        "detail": "qemu.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "gen_events",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.events",
        "description": "qemu.scripts.qapi.events",
        "peekOfCode": "def gen_events(schema: QAPISchema,\n               output_dir: str,\n               prefix: str) -> None:\n    vis = QAPISchemaGenEventVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.scripts.qapi.events",
        "documentation": {}
    },
    {
        "label": "check_name_is_str",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_name_is_str(name: object,\n                      info: QAPISourceInfo,\n                      source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a ``str``.\n    :raise QAPISemError: When ``name`` fails validation.\n    \"\"\"\n    if not isinstance(name, str):\n        raise QAPISemError(info, \"%s requires a string name\" % source)\ndef check_name_str(name: str, info: QAPISourceInfo, source: str) -> str:",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_str",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_name_str(name: str, info: QAPISourceInfo, source: str) -> str:\n    \"\"\"\n    Ensure that ``name`` is a valid QAPI name.\n    A valid name consists of ASCII letters, digits, ``-``, and ``_``,\n    starting with a letter.  It may be prefixed by a downstream prefix\n    of the form __RFQDN_, or the experimental prefix ``x-``.  If both\n    prefixes are present, the __RFDQN_ prefix goes first.\n    A valid name cannot start with ``q_``, which is reserved.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_upper",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_name_upper(name: str, info: QAPISourceInfo, source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid event name.\n    This means it must be a valid QAPI name as checked by\n    `check_name_str()`, but where the stem prohibits lowercase\n    characters and ``-``.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing what ``name`` belongs to.\n    :raise QAPISemError: When ``name`` fails validation.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_lower",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_name_lower(name: str, info: QAPISourceInfo, source: str,\n                     permit_upper: bool = False,\n                     permit_underscore: bool = False) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid command or member name.\n    This means it must be a valid QAPI name as checked by\n    `check_name_str()`, but where the stem prohibits uppercase\n    characters and ``_``.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_name_camel",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_name_camel(name: str, info: QAPISourceInfo, source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid user-defined type name.\n    This means it must be a valid QAPI name as checked by\n    `check_name_str()`, but where the stem must be in CamelCase.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing what ``name`` belongs to.\n    :raise QAPISemError: When ``name`` fails validation.\n    \"\"\"",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_defn_name_str",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_defn_name_str(name: str, info: QAPISourceInfo, meta: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a valid definition name.\n    Based on the value of ``meta``, this means that:\n      - 'event' names adhere to `check_name_upper()`.\n      - 'command' names adhere to `check_name_lower()`.\n      - Else, meta is a type, and must pass `check_name_camel()`.\n        These names must not end with ``List``.\n    :param name: Name to check.\n    :param info: QAPI schema source file information.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_keys",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_keys(value: Dict[str, object],\n               info: QAPISourceInfo,\n               source: str,\n               required: List[str],\n               optional: List[str]) -> None:\n    \"\"\"\n    Ensure that a dict has a specific set of keys.\n    :param value: The dict to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing this ``value``.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_flags",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_flags(expr: QAPIExpression) -> None:\n    \"\"\"\n    Ensure flag members (if present) have valid values.\n    :param expr: The expression to validate.\n    :raise QAPISemError:\n        When certain flags have an invalid value, or when\n        incompatible flags are present.\n    \"\"\"\n    for key in ('gen', 'success-response'):\n        if key in expr and expr[key] is not False:",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_if",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_if(expr: Dict[str, object],\n             info: QAPISourceInfo, source: str) -> None:\n    \"\"\"\n    Validate the ``if`` member of an object.\n    The ``if`` member may be either a ``str`` or a dict.\n    :param expr: The expression containing the ``if`` member to validate.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing ``expr``.\n    :raise QAPISemError:\n        When the \"if\" member fails validation, or when there are no",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "normalize_members",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def normalize_members(members: object) -> None:\n    \"\"\"\n    Normalize a \"members\" value.\n    If ``members`` is a dict, for every value in that dict, if that\n    value is not itself already a dict, normalize it to\n    ``{'type': value}``.\n    :forms:\n      :sugared: ``Dict[str, Union[str, TypeRef]]``\n      :canonical: ``Dict[str, TypeRef]``\n    :param members: The members value to normalize.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_name",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_type_name(value: Optional[object],\n                    info: QAPISourceInfo, source: str) -> None:\n    if value is not None and not isinstance(value, str):\n        raise QAPISemError(info, \"%s should be a type name\" % source)\ndef check_type_name_or_array(value: Optional[object],\n                             info: QAPISourceInfo, source: str) -> None:\n    if value is None or isinstance(value, str):\n        return\n    if not isinstance(value, list):\n        raise QAPISemError(info,",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_name_or_array",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_type_name_or_array(value: Optional[object],\n                             info: QAPISourceInfo, source: str) -> None:\n    if value is None or isinstance(value, str):\n        return\n    if not isinstance(value, list):\n        raise QAPISemError(info,\n                           \"%s should be a type name or array\" % source)\n    if len(value) != 1 or not isinstance(value[0], str):\n        raise QAPISemError(info,\n                           \"%s: array type must contain single type name\" %",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_implicit",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_type_implicit(value: Optional[object],\n                        info: QAPISourceInfo, source: str,\n                        parent_name: Optional[str]) -> None:\n    \"\"\"\n    Normalize and validate an optional implicit struct type.\n    Accept ``None`` or a ``dict`` defining an implicit struct type.\n    The latter is normalized in place.\n    :param value: The value to check.\n    :param info: QAPI schema source file information.\n    :param source: Error string describing this ``value``.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_type_name_or_implicit",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_type_name_or_implicit(value: Optional[object],\n                                info: QAPISourceInfo, source: str,\n                                parent_name: Optional[str]) -> None:\n    if value is None or isinstance(value, str):\n        return\n    check_type_implicit(value, info, source, parent_name)\ndef check_features(features: Optional[object],\n                   info: QAPISourceInfo) -> None:\n    \"\"\"\n    Normalize and validate the ``features`` member.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_features",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_features(features: Optional[object],\n                   info: QAPISourceInfo) -> None:\n    \"\"\"\n    Normalize and validate the ``features`` member.\n    ``features`` may be a ``list`` of either ``str`` or ``dict``.\n    Any ``str`` element will be normalized to ``{'name': element}``.\n    :forms:\n      :sugared: ``List[Union[str, Feature]]``\n      :canonical: ``List[Feature]``\n    :param features: The features member value to validate.",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_enum",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_enum(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as an ``enum`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``enum``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    name = expr['enum']\n    members = expr['data']\n    prefix = expr.get('prefix')",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_struct",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_struct(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as a ``struct`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``struct``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    name = cast(str, expr['struct'])  # Checked in check_exprs\n    members = expr['data']\n    check_type_implicit(members, expr.info, \"'data'\", name)",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_union",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_union(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as a ``union`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: when ``expr`` is not a valid ``union``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    name = cast(str, expr['union'])  # Checked in check_exprs\n    base = expr['base']\n    discriminator = expr['discriminator']",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_alternate",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_alternate(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as an ``alternate`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``alternate``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    members = expr['data']\n    info = expr.info\n    if not members:",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_command",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_command(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as a ``command`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``command``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    args = expr.get('data')\n    rets = expr.get('returns')\n    boxed = expr.get('boxed', False)",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_event",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_event(expr: QAPIExpression) -> None:\n    \"\"\"\n    Normalize and validate this expression as an ``event`` definition.\n    :param expr: The expression to validate.\n    :raise QAPISemError: When ``expr`` is not a valid ``event``.\n    :return: None, ``expr`` is normalized in-place as needed.\n    \"\"\"\n    args = expr.get('data')\n    boxed = expr.get('boxed', False)\n    if boxed:",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "check_exprs",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "def check_exprs(exprs: List[QAPIExpression]) -> List[QAPIExpression]:\n    \"\"\"\n    Validate and normalize a list of parsed QAPI schema expressions.\n    This function accepts a list of expressions and metadata as returned\n    by the parser.  It destructively normalizes the expressions in-place.\n    :param exprs: The list of expressions to normalize and validate.\n    :raise QAPISemError: When any expression fails validation.\n    :return: The same list of expressions (now modified).\n    \"\"\"\n    for expr in exprs:",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "valid_name",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.expr",
        "description": "qemu.scripts.qapi.expr",
        "peekOfCode": "valid_name = re.compile(r'(__[a-z0-9.-]+_)?'\n                        r'(x-)?'\n                        r'([a-z][a-z0-9_-]*)$', re.IGNORECASE)\ndef check_name_is_str(name: object,\n                      info: QAPISourceInfo,\n                      source: str) -> None:\n    \"\"\"\n    Ensure that ``name`` is a ``str``.\n    :raise QAPISemError: When ``name`` fails validation.\n    \"\"\"",
        "detail": "qemu.scripts.qapi.expr",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenFeatureVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.features",
        "description": "qemu.scripts.qapi.features",
        "peekOfCode": "class QAPISchemaGenFeatureVisitor(QAPISchemaMonolithicCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-features',\n            ' * Schema-defined QAPI features',\n            __doc__)\n        self.features: ValuesView[QAPISchemaFeature]\n    def visit_begin(self, schema: QAPISchema) -> None:\n        self.features = schema.features()\n        self._genh.add(\"#include \\\"qapi/util.h\\\"\\n\\n\")",
        "detail": "qemu.scripts.qapi.features",
        "documentation": {}
    },
    {
        "label": "gen_features",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.features",
        "description": "qemu.scripts.qapi.features",
        "peekOfCode": "def gen_features(schema: QAPISchema,\n                 output_dir: str,\n                 prefix: str) -> None:\n    vis = QAPISchemaGenFeatureVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.scripts.qapi.features",
        "documentation": {}
    },
    {
        "label": "QAPIGen",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "class QAPIGen:\n    def __init__(self, fname: str):\n        self.fname = fname\n        self._preamble = ''\n        self._body = ''\n    def preamble_add(self, text: str) -> None:\n        self._preamble += text\n    def add(self, text: str) -> None:\n        self._body += text\n    def get_content(self) -> str:",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenCCode",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenCCode(QAPIGen):\n    def __init__(self, fname: str):\n        super().__init__(fname)\n        self._start_if: Optional[Tuple[QAPISchemaIfCond, str, str]] = None\n    def start_if(self, ifcond: QAPISchemaIfCond) -> None:\n        assert self._start_if is None\n        self._start_if = (ifcond, self._body, self._preamble)\n    def end_if(self) -> None:\n        assert self._start_if is not None\n        self._body = _wrap_ifcond(self._start_if[0],",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenC",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenC(QAPIGenCCode):\n    def __init__(self, fname: str, blurb: str, pydoc: str):\n        super().__init__(fname)\n        self._blurb = blurb\n        self._copyright = '\\n * '.join(re.findall(r'^Copyright .*', pydoc,\n                                                  re.MULTILINE))\n    def _top(self) -> str:\n        return mcgen('''\n/* AUTOMATICALLY GENERATED by %(tool)s DO NOT MODIFY */\n/*",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenH",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenH(QAPIGenC):\n    def _top(self) -> str:\n        return super()._top() + guardstart(self.fname)\n    def _bottom(self) -> str:\n        return guardend(self.fname)\nclass QAPIGenTrace(QAPIGen):\n    def _top(self) -> str:\n        return (super()._top()\n                + '# AUTOMATICALLY GENERATED by '\n                + os.path.basename(sys.argv[0])",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPIGenTrace",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "class QAPIGenTrace(QAPIGen):\n    def _top(self) -> str:\n        return (super()._top()\n                + '# AUTOMATICALLY GENERATED by '\n                + os.path.basename(sys.argv[0])\n                + ', DO NOT MODIFY\\n\\n')\n@contextmanager\ndef ifcontext(ifcond: QAPISchemaIfCond, *args: QAPIGenCCode) -> Iterator[None]:\n    \"\"\"\n    A with-statement context manager that wraps with `start_if()` / `end_if()`.",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPISchemaMonolithicCVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "class QAPISchemaMonolithicCVisitor(QAPISchemaVisitor):\n    def __init__(self,\n                 prefix: str,\n                 what: str,\n                 blurb: str,\n                 pydoc: str):\n        self._prefix = prefix\n        self._what = what\n        self._genc = QAPIGenC(self._prefix + self._what + '.c',\n                              blurb, pydoc)",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "QAPISchemaModularCVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "class QAPISchemaModularCVisitor(QAPISchemaVisitor):\n    def __init__(self,\n                 prefix: str,\n                 what: str,\n                 user_blurb: str,\n                 builtin_blurb: Optional[str],\n                 pydoc: str,\n                 gen_tracing: bool = False):\n        self._prefix = prefix\n        self._what = what",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "gen_features",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "def gen_features(features: Sequence[QAPISchemaFeature]) -> str:\n    feats = [f\"1u << {c_enum_const('qapi_feature', feat.name)}\"\n             for feat in features]\n    return ' | '.join(feats) or '0'\nclass QAPIGen:\n    def __init__(self, fname: str):\n        self.fname = fname\n        self._preamble = ''\n        self._body = ''\n    def preamble_add(self, text: str) -> None:",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "build_params",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "def build_params(arg_type: Optional[QAPISchemaObjectType],\n                 boxed: bool,\n                 extra: Optional[str] = None) -> str:\n    ret = ''\n    sep = ''\n    if boxed:\n        assert arg_type\n        ret += '%s arg' % arg_type.c_param_type()\n        sep = ', '\n    elif arg_type:",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "ifcontext",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.gen",
        "description": "qemu.scripts.qapi.gen",
        "peekOfCode": "def ifcontext(ifcond: QAPISchemaIfCond, *args: QAPIGenCCode) -> Iterator[None]:\n    \"\"\"\n    A with-statement context manager that wraps with `start_if()` / `end_if()`.\n    :param ifcond: A sequence of conditionals, passed to `start_if()`.\n    :param args: any number of `QAPIGenCCode`.\n    Example::\n        with ifcontext(ifcond, self._genh, self._genc):\n            modify self._genh and self._genc ...\n    Is equivalent to calling::\n        self._genh.start_if(ifcond)",
        "detail": "qemu.scripts.qapi.gen",
        "documentation": {}
    },
    {
        "label": "Annotated",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "class Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"\n    value: _ValueT\n    ifcond: QAPISchemaIfCond\n    comment: Optional[str] = None\ndef _tree_to_qlit(obj: JSONValue,",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenIntrospectVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "class QAPISchemaGenIntrospectVisitor(QAPISchemaMonolithicCVisitor):\n    def __init__(self, prefix: str, unmask: bool):\n        super().__init__(\n            prefix, 'qapi-introspect',\n            ' * QAPI/QMP schema introspection', __doc__)\n        self._unmask = unmask\n        self._schema: Optional[QAPISchema] = None\n        self._trees: List[Annotated[SchemaInfo]] = []\n        self._used_types: List[QAPISchemaType] = []\n        self._name_map: Dict[str, str] = {}",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "to_c_string",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "def to_c_string(string: str) -> str:\n    return '\"' + string.replace('\\\\', r'\\\\').replace('\"', r'\\\"') + '\"'\nclass QAPISchemaGenIntrospectVisitor(QAPISchemaMonolithicCVisitor):\n    def __init__(self, prefix: str, unmask: bool):\n        super().__init__(\n            prefix, 'qapi-introspect',\n            ' * QAPI/QMP schema introspection', __doc__)\n        self._unmask = unmask\n        self._schema: Optional[QAPISchema] = None\n        self._trees: List[Annotated[SchemaInfo]] = []",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "gen_introspect",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "def gen_introspect(schema: QAPISchema, output_dir: str, prefix: str,\n                   opt_unmask: bool) -> None:\n    vis = QAPISchemaGenIntrospectVisitor(prefix, opt_unmask)\n    schema.visit(vis)\n    vis.write(output_dir)",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_Stub",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "_Stub = Any\n_Scalar = Union[str, bool, None]\n_NonScalar = Union[Dict[str, _Stub], List[_Stub]]\n_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_Scalar",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "_Scalar = Union[str, bool, None]\n_NonScalar = Union[Dict[str, _Stub], List[_Stub]]\n_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_NonScalar",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "_NonScalar = Union[Dict[str, _Stub], List[_Stub]]\n_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_Value",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "_Value = Union[_Scalar, _NonScalar]\nJSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "JSONValue",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "JSONValue = Union[_Value, 'Annotated[_Value]']\n# These types are based on structures defined in QEMU's schema, so we\n# lack precise types for them here. Python 3.6 does not offer\n# TypedDict constructs, so they are broadly typed here as simple\n# Python Dicts.\nSchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfo",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfo = Dict[str, object]\nSchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoEnumMember",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoEnumMember = Dict[str, object]\nSchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoObject",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoObject = Dict[str, object]\nSchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoObjectVariant",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoObjectVariant = Dict[str, object]\nSchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoObjectMember",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoObjectMember = Dict[str, object]\nSchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "SchemaInfoCommand",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "SchemaInfoCommand = Dict[str, object]\n_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"\n    value: _ValueT",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "_ValueT",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.introspect",
        "description": "qemu.scripts.qapi.introspect",
        "peekOfCode": "_ValueT = TypeVar('_ValueT', bound=_Value)\n@dataclass\nclass Annotated(Generic[_ValueT]):\n    \"\"\"\n    Annotated generally contains a SchemaInfo-like type (as a dict),\n    But it also used to wrap comments/ifconds around scalar leaf values,\n    for the benefit of features and enums.\n    \"\"\"\n    value: _ValueT\n    ifcond: QAPISchemaIfCond",
        "detail": "qemu.scripts.qapi.introspect",
        "documentation": {}
    },
    {
        "label": "invalid_prefix_char",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.main",
        "description": "qemu.scripts.qapi.main",
        "peekOfCode": "def invalid_prefix_char(prefix: str) -> Optional[str]:\n    match = must_match(r'([A-Za-z_.-][A-Za-z0-9_.-]*)?', prefix)\n    if match.end() != len(prefix):\n        return prefix[match.end()]\n    return None\ndef create_backend(path: str) -> QAPIBackend:\n    if path is None:\n        return QAPICBackend()\n    module_path, dot, class_name = path.rpartition('.')\n    if not dot:",
        "detail": "qemu.scripts.qapi.main",
        "documentation": {}
    },
    {
        "label": "create_backend",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.main",
        "description": "qemu.scripts.qapi.main",
        "peekOfCode": "def create_backend(path: str) -> QAPIBackend:\n    if path is None:\n        return QAPICBackend()\n    module_path, dot, class_name = path.rpartition('.')\n    if not dot:\n        raise QAPIError(\"argument of -B must be of the form MODULE.CLASS\")\n    try:\n        mod = import_module(module_path)\n    except Exception as ex:\n        raise QAPIError(f\"unable to import '{module_path}': {ex}\") from ex",
        "detail": "qemu.scripts.qapi.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.main",
        "description": "qemu.scripts.qapi.main",
        "peekOfCode": "def main() -> int:\n    \"\"\"\n    gapi-gen executable entry point.\n    Expects arguments via sys.argv, see --help for details.\n    :return: int, 0 on success, 1 on failure.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Generate code from a QAPI schema')\n    parser.add_argument('-b', '--builtins', action='store_true',\n                        help=\"generate code for built-in types\")",
        "detail": "qemu.scripts.qapi.main",
        "documentation": {}
    },
    {
        "label": "QAPIExpression",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.parser",
        "description": "qemu.scripts.qapi.parser",
        "peekOfCode": "class QAPIExpression(Dict[str, Any]):\n    # pylint: disable=too-few-public-methods\n    def __init__(self,\n                 data: Mapping[str, object],\n                 info: QAPISourceInfo,\n                 doc: Optional['QAPIDoc'] = None):\n        super().__init__(data)\n        self.info = info\n        self.doc: Optional['QAPIDoc'] = doc\nclass QAPIParseError(QAPISourceError):",
        "detail": "qemu.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPIParseError",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.parser",
        "description": "qemu.scripts.qapi.parser",
        "peekOfCode": "class QAPIParseError(QAPISourceError):\n    \"\"\"Error class for all QAPI schema parsing errors.\"\"\"\n    def __init__(self, parser: 'QAPISchemaParser', msg: str):\n        col = 1\n        for ch in parser.src[parser.line_pos:parser.pos]:\n            if ch == '\\t':\n                col = (col + 7) % 8 + 1\n            else:\n                col += 1\n        super().__init__(parser.info, msg, col)",
        "detail": "qemu.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPISchemaParser",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.parser",
        "description": "qemu.scripts.qapi.parser",
        "peekOfCode": "class QAPISchemaParser:\n    \"\"\"\n    Parse QAPI schema source.\n    Parse a JSON-esque schema file and process directives.  See\n    qapi-code-gen.rst section \"Schema Syntax\" for the exact syntax.\n    Grammatical validation is handled later by `expr.check_exprs()`.\n    :param fname: Source file name.\n    :param previously_included:\n        The absolute names of previously included source files,\n        if being invoked from another parser.",
        "detail": "qemu.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPIDoc",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.parser",
        "description": "qemu.scripts.qapi.parser",
        "peekOfCode": "class QAPIDoc:\n    \"\"\"\n    A documentation comment block, either definition or free-form\n    Definition documentation blocks consist of\n    * a body section: one line naming the definition, followed by an\n      overview (any number of lines)\n    * argument sections: a description of each argument (for commands\n      and events) or member (for structs, unions and alternates)\n    * features sections: a description of each feature flag\n    * additional (non-argument) sections, possibly tagged",
        "detail": "qemu.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "_ExprValue",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.parser",
        "description": "qemu.scripts.qapi.parser",
        "peekOfCode": "_ExprValue = Union[List[object], Dict[str, object], str, bool]\nclass QAPIExpression(Dict[str, Any]):\n    # pylint: disable=too-few-public-methods\n    def __init__(self,\n                 data: Mapping[str, object],\n                 info: QAPISourceInfo,\n                 doc: Optional['QAPIDoc'] = None):\n        super().__init__(data)\n        self.info = info\n        self.doc: Optional['QAPIDoc'] = doc",
        "detail": "qemu.scripts.qapi.parser",
        "documentation": {}
    },
    {
        "label": "QAPISchemaIfCond",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaIfCond:\n    def __init__(\n        self,\n        ifcond: Optional[Union[str, Dict[str, object]]] = None,\n    ) -> None:\n        self.ifcond = ifcond\n    def _cgen(self) -> str:\n        return cgen_ifcond(self.ifcond)\n    def gen_if(self) -> str:\n        return gen_if(self._cgen())",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEntity",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEntity:\n    \"\"\"\n    A schema entity.\n    This is either a directive, such as include, or a definition.\n    The latter uses sub-class `QAPISchemaDefinition`.\n    \"\"\"\n    def __init__(self, info: Optional[QAPISourceInfo]):\n        self._module: Optional[QAPISchemaModule] = None\n        # For explicitly defined entities, info points to the (explicit)\n        # definition.  For builtins (and their arrays), info is None.",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaDefinition",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaDefinition(QAPISchemaEntity):\n    meta: str\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond] = None,\n        features: Optional[List[QAPISchemaFeature]] = None,\n    ):",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaVisitor:\n    def visit_begin(self, schema: QAPISchema) -> None:\n        pass\n    def visit_end(self) -> None:\n        pass\n    def visit_module(self, name: str) -> None:\n        pass\n    def visit_needed(self, entity: QAPISchemaEntity) -> bool:\n        # pylint: disable=unused-argument\n        # Default to visiting everything",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaModule",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaModule:\n    BUILTIN_MODULE_NAME = './builtin'\n    def __init__(self, name: str):\n        self.name = name\n        self._entity_list: List[QAPISchemaEntity] = []\n    @staticmethod\n    def is_system_module(name: str) -> bool:\n        \"\"\"\n        System modules are internally defined modules.\n        Their names start with the \"./\" prefix.",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaInclude",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaInclude(QAPISchemaEntity):\n    def __init__(self, sub_module: QAPISchemaModule, info: QAPISourceInfo):\n        super().__init__(info)\n        self._sub_module = sub_module\n    def visit(self, visitor: QAPISchemaVisitor) -> None:\n        super().visit(visitor)\n        visitor.visit_include(self._sub_module.name, self.info)\nclass QAPISchemaType(QAPISchemaDefinition, ABC):\n    # Return the C type for common use.\n    # For the types we commonly box, this is a pointer type.",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaType",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaType(QAPISchemaDefinition, ABC):\n    # Return the C type for common use.\n    # For the types we commonly box, this is a pointer type.\n    @abstractmethod\n    def c_type(self) -> str:\n        pass\n    # Return the C type to be used in a parameter list.\n    def c_param_type(self) -> str:\n        return self.c_type()\n    # Return the C type to be used where we suppress boxing.",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaBuiltinType",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaBuiltinType(QAPISchemaType):\n    meta = 'built-in'\n    def __init__(self, name: str, json_type: str, c_type: str):\n        super().__init__(name, None, None)\n        assert json_type in ('string', 'number', 'int', 'boolean', 'null',\n                             'value')\n        self._json_type_name = json_type\n        self._c_type_name = c_type\n    def c_name(self) -> str:\n        return self.name",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEnumType",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEnumType(QAPISchemaType):\n    meta = 'enum'\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond],\n        features: Optional[List[QAPISchemaFeature]],\n        members: List[QAPISchemaEnumMember],",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaArrayType",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaArrayType(QAPISchemaType):\n    meta = 'array'\n    def __init__(\n        self, name: str, info: Optional[QAPISourceInfo], element_type: str\n    ):\n        super().__init__(name, info, None)\n        self._element_type_name = element_type\n        self.element_type: QAPISchemaType\n    def need_has_if_optional(self) -> bool:\n        # When FOO is an array, we still need has_FOO to distinguish",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaObjectType",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaObjectType(QAPISchemaType):\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond],\n        features: Optional[List[QAPISchemaFeature]],\n        base: Optional[str],\n        local_members: List[QAPISchemaObjectTypeMember],",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaAlternateType",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaAlternateType(QAPISchemaType):\n    meta = 'alternate'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        doc: Optional[QAPIDoc],\n        ifcond: Optional[QAPISchemaIfCond],\n        features: List[QAPISchemaFeature],\n        alternatives: QAPISchemaAlternatives,",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVariants",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaVariants:\n    def __init__(\n        self,\n        info: QAPISourceInfo,\n        variants: List[QAPISchemaVariant],\n    ):\n        self.info = info\n        self.tag_member: QAPISchemaObjectTypeMember\n        self.variants = variants\n    def set_defined_in(self, name: str) -> None:",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaBranches",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaBranches(QAPISchemaVariants):\n    def __init__(self,\n                 info: QAPISourceInfo,\n                 variants: List[QAPISchemaVariant],\n                 tag_name: str):\n        super().__init__(info, variants)\n        self._tag_name = tag_name\n    def check(\n            self, schema: QAPISchema, seen: Dict[str, QAPISchemaMember]\n    ) -> None:",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaAlternatives",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaAlternatives(QAPISchemaVariants):\n    def __init__(self,\n                 info: QAPISourceInfo,\n                 variants: List[QAPISchemaVariant],\n                 tag_member: QAPISchemaObjectTypeMember):\n        super().__init__(info, variants)\n        self.tag_member = tag_member\n    def check(\n            self, schema: QAPISchema, seen: Dict[str, QAPISchemaMember]\n    ) -> None:",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaMember",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaMember:\n    \"\"\" Represents object members, enum members and features \"\"\"\n    role = 'member'\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        ifcond: Optional[QAPISchemaIfCond] = None,\n    ):\n        self.name = name",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEnumMember",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEnumMember(QAPISchemaMember):\n    role = 'value'\n    def __init__(\n        self,\n        name: str,\n        info: Optional[QAPISourceInfo],\n        ifcond: Optional[QAPISchemaIfCond] = None,\n        features: Optional[List[QAPISchemaFeature]] = None,\n    ):\n        super().__init__(name, info, ifcond)",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaFeature",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaFeature(QAPISchemaMember):\n    role = 'feature'\n    # Features which are standardized across all schemas\n    SPECIAL_NAMES = ['deprecated', 'unstable']\n    def is_special(self) -> bool:\n        return self.name in QAPISchemaFeature.SPECIAL_NAMES\nclass QAPISchemaObjectTypeMember(QAPISchemaMember):\n    def __init__(\n        self,\n        name: str,",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaObjectTypeMember",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaObjectTypeMember(QAPISchemaMember):\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        typ: str,\n        optional: bool,\n        ifcond: Optional[QAPISchemaIfCond] = None,\n        features: Optional[List[QAPISchemaFeature]] = None,\n    ):",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaVariant",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaVariant(QAPISchemaObjectTypeMember):\n    role = 'branch'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        typ: str,\n        ifcond: QAPISchemaIfCond,\n    ):\n        super().__init__(name, info, typ, False, ifcond)",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaCommand",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaCommand(QAPISchemaDefinition):\n    meta = 'command'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        doc: Optional[QAPIDoc],\n        ifcond: QAPISchemaIfCond,\n        features: List[QAPISchemaFeature],\n        arg_type: Optional[str],",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaEvent",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchemaEvent(QAPISchemaDefinition):\n    meta = 'event'\n    def __init__(\n        self,\n        name: str,\n        info: QAPISourceInfo,\n        doc: Optional[QAPIDoc],\n        ifcond: QAPISchemaIfCond,\n        features: List[QAPISchemaFeature],\n        arg_type: Optional[str],",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchema",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.schema",
        "description": "qemu.scripts.qapi.schema",
        "peekOfCode": "class QAPISchema:\n    def __init__(self, fname: str):\n        self.fname = fname\n        try:\n            parser = QAPISchemaParser(fname)\n        except OSError as err:\n            raise QAPIError(\n                f\"can't read schema file '{fname}': {err.strerror}\"\n            ) from err\n        exprs = check_exprs(parser.exprs)",
        "detail": "qemu.scripts.qapi.schema",
        "documentation": {}
    },
    {
        "label": "QAPISchemaPragma",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.source",
        "description": "qemu.scripts.qapi.source",
        "peekOfCode": "class QAPISchemaPragma:\n    # Replace with @dataclass in Python 3.7+\n    # pylint: disable=too-few-public-methods\n    def __init__(self) -> None:\n        # Are documentation comments required?\n        self.doc_required = False\n        # Commands whose names may use '_'\n        self.command_name_exceptions: List[str] = []\n        # Commands allowed to return a non-dictionary\n        self.command_returns_exceptions: List[str] = []",
        "detail": "qemu.scripts.qapi.source",
        "documentation": {}
    },
    {
        "label": "QAPISourceInfo",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.source",
        "description": "qemu.scripts.qapi.source",
        "peekOfCode": "class QAPISourceInfo:\n    T = TypeVar('T', bound='QAPISourceInfo')\n    def __init__(self, fname: str, parent: Optional['QAPISourceInfo']):\n        self.fname = fname\n        self.line = 1\n        self.parent = parent\n        self.pragma: QAPISchemaPragma = (\n            parent.pragma if parent else QAPISchemaPragma()\n        )\n        self.defn_meta: Optional[str] = None",
        "detail": "qemu.scripts.qapi.source",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenTypeVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "class QAPISchemaGenTypeVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-types', ' * Schema-defined QAPI types',\n            ' * Built-in QAPI types', __doc__)\n    def _begin_builtin_module(self) -> None:\n        self._genc.preamble_add(mcgen('''\n#include \"qemu/osdep.h\"\n#include \"qapi/dealloc-visitor.h\"\n#include \"qapi/qapi-builtin-types.h\"",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_enum_lookup",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_enum_lookup(name: str,\n                    members: List[QAPISchemaEnumMember],\n                    prefix: Optional[str] = None) -> str:\n    max_index = c_enum_const(name, '_MAX', prefix)\n    feats = ''\n    ret = mcgen('''\nconst QEnumLookup %(c_name)s_lookup = {\n    .array = (const char *const[]) {\n''',\n                c_name=c_name(name))",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_enum",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_enum(name: str,\n             members: List[QAPISchemaEnumMember],\n             prefix: Optional[str] = None) -> str:\n    # append automatically generated _MAX value\n    enum_members = members + [QAPISchemaEnumMember('_MAX', None)]\n    ret = mcgen('''\ntypedef enum %(c_name)s {\n''',\n                c_name=c_name(name))\n    for memb in enum_members:",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_fwd_object_or_array",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_fwd_object_or_array(name: str) -> str:\n    return mcgen('''\ntypedef struct %(c_name)s %(c_name)s;\n''',\n                 c_name=c_name(name))\ndef gen_array(name: str, element_type: QAPISchemaType) -> str:\n    return mcgen('''\nstruct %(c_name)s {\n    %(c_name)s *next;\n    %(c_type)s value;",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_array",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_array(name: str, element_type: QAPISchemaType) -> str:\n    return mcgen('''\nstruct %(c_name)s {\n    %(c_name)s *next;\n    %(c_type)s value;\n};\n''',\n                 c_name=c_name(name), c_type=element_type.c_type())\ndef gen_struct_members(members: List[QAPISchemaObjectTypeMember]) -> str:\n    ret = ''",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_struct_members",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_struct_members(members: List[QAPISchemaObjectTypeMember]) -> str:\n    ret = ''\n    for memb in members:\n        ret += memb.ifcond.gen_if()\n        if memb.need_has():\n            ret += mcgen('''\n    bool has_%(c_name)s;\n''',\n                         c_name=c_name(memb.name))\n        ret += mcgen('''",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_object",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_object(name: str, ifcond: QAPISchemaIfCond,\n               base: Optional[QAPISchemaObjectType],\n               members: List[QAPISchemaObjectTypeMember],\n               variants: Optional[QAPISchemaVariants]) -> str:\n    if name in objects_seen:\n        return ''\n    objects_seen.add(name)\n    ret = ''\n    for var in variants.variants if variants else ():\n        obj = var.type",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_upcast",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_upcast(name: str, base: QAPISchemaObjectType) -> str:\n    # C makes const-correctness ugly.  We have to cast away const to let\n    # this function work for both const and non-const obj.\n    return mcgen('''\nstatic inline %(base)s *qapi_%(c_name)s_base(const %(c_name)s *obj)\n{\n    return (%(base)s *)obj;\n}\n''',\n                 c_name=c_name(name), base=base.c_name())",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_variants",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_variants(variants: QAPISchemaVariants) -> str:\n    ret = mcgen('''\n    union { /* union tag is @%(c_name)s */\n''',\n                c_name=c_name(variants.tag_member.name))\n    for var in variants.variants:\n        if var.type.name == 'q_empty':\n            continue\n        ret += var.ifcond.gen_if()\n        ret += mcgen('''",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_type_cleanup_decl",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_type_cleanup_decl(name: str) -> str:\n    ret = mcgen('''\nvoid qapi_free_%(c_name)s(%(c_name)s *obj);\nG_DEFINE_AUTOPTR_CLEANUP_FUNC(%(c_name)s, qapi_free_%(c_name)s)\n''',\n                c_name=c_name(name))\n    return ret\ndef gen_type_cleanup(name: str) -> str:\n    ret = mcgen('''\nvoid qapi_free_%(c_name)s(%(c_name)s *obj)",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_type_cleanup",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_type_cleanup(name: str) -> str:\n    ret = mcgen('''\nvoid qapi_free_%(c_name)s(%(c_name)s *obj)\n{\n    Visitor *v;\n    if (!obj) {\n        return;\n    }\n    v = qapi_dealloc_visitor_new();\n    visit_type_%(c_name)s(v, NULL, &obj, NULL);",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "gen_types",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "def gen_types(schema: QAPISchema,\n              output_dir: str,\n              prefix: str,\n              opt_builtins: bool) -> None:\n    vis = QAPISchemaGenTypeVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir, opt_builtins)",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "objects_seen",
        "kind": 5,
        "importPath": "qemu.scripts.qapi.types",
        "description": "qemu.scripts.qapi.types",
        "peekOfCode": "objects_seen = set()\ndef gen_enum_lookup(name: str,\n                    members: List[QAPISchemaEnumMember],\n                    prefix: Optional[str] = None) -> str:\n    max_index = c_enum_const(name, '_MAX', prefix)\n    feats = ''\n    ret = mcgen('''\nconst QEnumLookup %(c_name)s_lookup = {\n    .array = (const char *const[]) {\n''',",
        "detail": "qemu.scripts.qapi.types",
        "documentation": {}
    },
    {
        "label": "QAPISchemaGenVisitVisitor",
        "kind": 6,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "class QAPISchemaGenVisitVisitor(QAPISchemaModularCVisitor):\n    def __init__(self, prefix: str):\n        super().__init__(\n            prefix, 'qapi-visit', ' * Schema-defined QAPI visitors',\n            ' * Built-in QAPI visitors', __doc__)\n    def _begin_builtin_module(self) -> None:\n        self._genc.preamble_add(mcgen('''\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qapi-builtin-visit.h\"",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_decl",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_decl(name: str, scalar: bool = False) -> str:\n    c_type = c_name(name) + ' *'\n    if not scalar:\n        c_type += '*'\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_type)sobj, Error **errp);\n''',\n                 c_name=c_name(name), c_type=c_type)\ndef gen_visit_members_decl(name: str) -> str:",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_members_decl",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_members_decl(name: str) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s_members(Visitor *v, %(c_name)s *obj, Error **errp);\n''',\n                 c_name=c_name(name))\ndef gen_visit_object_members(name: str,\n                             base: Optional[QAPISchemaObjectType],\n                             members: List[QAPISchemaObjectTypeMember],\n                             branches: Optional[QAPISchemaBranches]) -> str:\n    ret = mcgen('''",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_object_members",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_object_members(name: str,\n                             base: Optional[QAPISchemaObjectType],\n                             members: List[QAPISchemaObjectTypeMember],\n                             branches: Optional[QAPISchemaBranches]) -> str:\n    ret = mcgen('''\nbool visit_type_%(c_name)s_members(Visitor *v, %(c_name)s *obj, Error **errp)\n{\n''',\n                c_name=c_name(name))\n    sep = ''",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_list",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_list(name: str, element_type: QAPISchemaType) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s **obj, Error **errp)\n{\n    bool ok = false;\n    %(c_name)s *tail;\n    size_t size = sizeof(**obj);\n    if (!visit_start_list(v, name, (GenericList **)obj, size, errp)) {\n        return false;",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_enum",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_enum(name: str) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s *obj, Error **errp)\n{\n    int value = *obj;\n    bool ok = visit_type_enum(v, name, &value, &%(c_name)s_lookup, errp);\n    *obj = value;\n    return ok;\n}",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_alternate",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_alternate(name: str,\n                        alternatives: QAPISchemaAlternatives) -> str:\n    ret = mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s **obj, Error **errp)\n{\n    bool ok = false;\n    if (!visit_start_alternate(v, name, (GenericAlternate **)obj,\n                               sizeof(**obj), errp)) {\n        return false;",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit_object",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit_object(name: str) -> str:\n    return mcgen('''\nbool visit_type_%(c_name)s(Visitor *v, const char *name,\n                 %(c_name)s **obj, Error **errp)\n{\n    bool ok = false;\n    if (!visit_start_struct(v, name, (void **)obj, sizeof(%(c_name)s), errp)) {\n        return false;\n    }\n    if (!*obj) {",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "gen_visit",
        "kind": 2,
        "importPath": "qemu.scripts.qapi.visit",
        "description": "qemu.scripts.qapi.visit",
        "peekOfCode": "def gen_visit(schema: QAPISchema,\n              output_dir: str,\n              prefix: str,\n              opt_builtins: bool) -> None:\n    vis = QAPISchemaGenVisitVisitor(prefix)\n    schema.visit(vis)\n    vis.write(output_dir, opt_builtins)",
        "detail": "qemu.scripts.qapi.visit",
        "documentation": {}
    },
    {
        "label": "HandlersCommand",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.aio",
        "description": "qemu.scripts.qemugdb.aio",
        "peekOfCode": "class HandlersCommand(gdb.Command):\n    '''Display aio handlers'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu handlers', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        verbose = False\n        argv = gdb.string_to_argv(arg)\n        if len(argv) > 0 and argv[0] == '--verbose':\n            verbose = True",
        "detail": "qemu.scripts.qemugdb.aio",
        "documentation": {}
    },
    {
        "label": "isnull",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.aio",
        "description": "qemu.scripts.qemugdb.aio",
        "peekOfCode": "def isnull(ptr):\n    return ptr == gdb.Value(0).cast(ptr.type)\ndef dump_aiocontext(context, verbose):\n    '''Display a dump and backtrace for an aiocontext'''\n    cur = context['aio_handlers']['lh_first']\n    # Get pointers to functions we're going to process specially\n    sym_fd_coroutine_enter = gdb.parse_and_eval('fd_coroutine_enter')\n    while not isnull(cur):\n        entry = cur.dereference()\n        gdb.write('----\\n%s\\n' % entry)",
        "detail": "qemu.scripts.qemugdb.aio",
        "documentation": {}
    },
    {
        "label": "dump_aiocontext",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.aio",
        "description": "qemu.scripts.qemugdb.aio",
        "peekOfCode": "def dump_aiocontext(context, verbose):\n    '''Display a dump and backtrace for an aiocontext'''\n    cur = context['aio_handlers']['lh_first']\n    # Get pointers to functions we're going to process specially\n    sym_fd_coroutine_enter = gdb.parse_and_eval('fd_coroutine_enter')\n    while not isnull(cur):\n        entry = cur.dereference()\n        gdb.write('----\\n%s\\n' % entry)\n        if verbose and cur['io_read'] == sym_fd_coroutine_enter:\n            coptr = (cur['opaque'].cast(gdb.lookup_type('FDYieldUntilData').pointer()))['co']",
        "detail": "qemu.scripts.qemugdb.aio",
        "documentation": {}
    },
    {
        "label": "CoroutineCommand",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutineCommand(gdb.Command):\n    '''Display coroutine backtrace'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu coroutine', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        argv = gdb.string_to_argv(arg)\n        if len(argv) != 1:\n            gdb.write('usage: qemu coroutine <coroutine-pointer>\\n')\n            return",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "CoroutineBt",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutineBt(gdb.Command):\n    '''Display backtrace including coroutine switches'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu bt', gdb.COMMAND_STACK,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        gdb.execute(\"bt\")\n        try:\n            # This only works with a live session\n            co_ptr = gdb.parse_and_eval(\"qemu_coroutine_self()\")",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "CoroutineSPFunction",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutineSPFunction(gdb.Function):\n    def __init__(self):\n        gdb.Function.__init__(self, 'qemu_coroutine_sp')\n    def invoke(self, addr):\n        return get_jmpbuf_regs(coroutine_to_jmpbuf(addr))['rsp'].cast(VOID_PTR)\nclass CoroutinePCFunction(gdb.Function):\n    def __init__(self):\n        gdb.Function.__init__(self, 'qemu_coroutine_pc')\n    def invoke(self, addr):\n        return get_jmpbuf_regs(coroutine_to_jmpbuf(addr))['rip'].cast(VOID_PTR)",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "CoroutinePCFunction",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "class CoroutinePCFunction(gdb.Function):\n    def __init__(self):\n        gdb.Function.__init__(self, 'qemu_coroutine_pc')\n    def invoke(self, addr):\n        return get_jmpbuf_regs(coroutine_to_jmpbuf(addr))['rip'].cast(VOID_PTR)",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "pthread_self",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def pthread_self():\n    '''Fetch the base address of TLS.'''\n    return gdb.parse_and_eval(\"$fs_base\")\ndef get_glibc_pointer_guard():\n    '''Fetch glibc pointer guard value'''\n    fs_base = pthread_self()\n    return gdb.parse_and_eval('*(uint64_t*)((uint64_t)%s + 0x30)' % fs_base)\ndef glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''\n    return gdb.parse_and_eval('(((uint64_t)%s >> 0x11) | ((uint64_t)%s << (64 - 0x11))) ^ (uint64_t)%s' % (val, val, pointer_guard))",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "get_glibc_pointer_guard",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def get_glibc_pointer_guard():\n    '''Fetch glibc pointer guard value'''\n    fs_base = pthread_self()\n    return gdb.parse_and_eval('*(uint64_t*)((uint64_t)%s + 0x30)' % fs_base)\ndef glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''\n    return gdb.parse_and_eval('(((uint64_t)%s >> 0x11) | ((uint64_t)%s << (64 - 0x11))) ^ (uint64_t)%s' % (val, val, pointer_guard))\ndef get_jmpbuf_regs(jmpbuf):\n    JB_RBX  = 0\n    JB_RBP  = 1",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "glibc_ptr_demangle",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''\n    return gdb.parse_and_eval('(((uint64_t)%s >> 0x11) | ((uint64_t)%s << (64 - 0x11))) ^ (uint64_t)%s' % (val, val, pointer_guard))\ndef get_jmpbuf_regs(jmpbuf):\n    JB_RBX  = 0\n    JB_RBP  = 1\n    JB_R12  = 2\n    JB_R13  = 3\n    JB_R14  = 4\n    JB_R15  = 5",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "get_jmpbuf_regs",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def get_jmpbuf_regs(jmpbuf):\n    JB_RBX  = 0\n    JB_RBP  = 1\n    JB_R12  = 2\n    JB_R13  = 3\n    JB_R14  = 4\n    JB_R15  = 5\n    JB_RSP  = 6\n    JB_PC   = 7\n    pointer_guard = get_glibc_pointer_guard()",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "symbol_lookup",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def symbol_lookup(addr):\n    # Example: \"__clone3 + 44 in section .text of /lib64/libc.so.6\"\n    result = gdb.execute(f\"info symbol {hex(addr)}\", to_string=True).strip()\n    try:\n        if \"+\" in result:\n            (func, result) = result.split(\" + \")\n            (offset, result) = result.split(\" in \")\n        else:\n            offset = \"0\"\n            (func, result) = result.split(\" in \")",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "dump_backtrace",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def dump_backtrace(regs):\n    '''\n    Backtrace dump with raw registers, mimic GDB command 'bt'.\n    '''\n    # Here only rbp and rip that matter..\n    rbp = regs['rbp']\n    rip = regs['rip']\n    i = 0\n    while rbp:\n        # For all return addresses on stack, we want to look up symbol/line",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "dump_backtrace_live",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def dump_backtrace_live(regs):\n    '''\n    Backtrace dump with gdb's 'bt' command, only usable in a live session.\n    '''\n    old = dict()\n    # remember current stack frame and select the topmost\n    # so that register modifications don't wreck it\n    selected_frame = gdb.selected_frame()\n    gdb.newest_frame().select()\n    for i in regs:",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "bt_jmpbuf",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def bt_jmpbuf(jmpbuf):\n    '''Backtrace a jmpbuf'''\n    regs = get_jmpbuf_regs(jmpbuf)\n    try:\n        # This reuses gdb's \"bt\" command, which can be slightly prettier\n        # but only works with live sessions.\n        dump_backtrace_live(regs)\n    except:\n        # If above doesn't work, fallback to poor man's unwind\n        dump_backtrace(regs)",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "co_cast",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def co_cast(co):\n    return co.cast(gdb.lookup_type('CoroutineUContext').pointer())\ndef coroutine_to_jmpbuf(co):\n    coroutine_pointer = co_cast(co)\n    return coroutine_pointer['env']['__jmpbuf']\nclass CoroutineCommand(gdb.Command):\n    '''Display coroutine backtrace'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu coroutine', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "coroutine_to_jmpbuf",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "def coroutine_to_jmpbuf(co):\n    coroutine_pointer = co_cast(co)\n    return coroutine_pointer['env']['__jmpbuf']\nclass CoroutineCommand(gdb.Command):\n    '''Display coroutine backtrace'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu coroutine', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        argv = gdb.string_to_argv(arg)",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "VOID_PTR",
        "kind": 5,
        "importPath": "qemu.scripts.qemugdb.coroutine",
        "description": "qemu.scripts.qemugdb.coroutine",
        "peekOfCode": "VOID_PTR = gdb.lookup_type('void').pointer()\ndef pthread_self():\n    '''Fetch the base address of TLS.'''\n    return gdb.parse_and_eval(\"$fs_base\")\ndef get_glibc_pointer_guard():\n    '''Fetch glibc pointer guard value'''\n    fs_base = pthread_self()\n    return gdb.parse_and_eval('*(uint64_t*)((uint64_t)%s + 0x30)' % fs_base)\ndef glibc_ptr_demangle(val, pointer_guard):\n    '''Undo effect of glibc's PTR_MANGLE()'''",
        "detail": "qemu.scripts.qemugdb.coroutine",
        "documentation": {}
    },
    {
        "label": "MtreeCommand",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.mtree",
        "description": "qemu.scripts.qemugdb.mtree",
        "peekOfCode": "class MtreeCommand(gdb.Command):\n    '''Display the memory tree hierarchy'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu mtree', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n        self.queue = []\n    def invoke(self, arg, from_tty):\n        self.seen = set()\n        self.queue_root('address_space_memory')\n        self.queue_root('address_space_io')",
        "detail": "qemu.scripts.qemugdb.mtree",
        "documentation": {}
    },
    {
        "label": "isnull",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.mtree",
        "description": "qemu.scripts.qemugdb.mtree",
        "peekOfCode": "def isnull(ptr):\n    return ptr == gdb.Value(0).cast(ptr.type)\ndef int128(p):\n    '''Read an Int128 type to a python integer.\n    QEMU can be built with native Int128 support so we need to detect\n    if the value is a structure or the native type.\n    '''\n    if p.type.code == gdb.TYPE_CODE_STRUCT:\n        return int(p['lo']) + (int(p['hi']) << 64)\n    else:",
        "detail": "qemu.scripts.qemugdb.mtree",
        "documentation": {}
    },
    {
        "label": "int128",
        "kind": 2,
        "importPath": "qemu.scripts.qemugdb.mtree",
        "description": "qemu.scripts.qemugdb.mtree",
        "peekOfCode": "def int128(p):\n    '''Read an Int128 type to a python integer.\n    QEMU can be built with native Int128 support so we need to detect\n    if the value is a structure or the native type.\n    '''\n    if p.type.code == gdb.TYPE_CODE_STRUCT:\n        return int(p['lo']) + (int(p['hi']) << 64)\n    else:\n        return int((\"%s\" % p), 16)\nclass MtreeCommand(gdb.Command):",
        "detail": "qemu.scripts.qemugdb.mtree",
        "documentation": {}
    },
    {
        "label": "TCGLockStatusCommand",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.tcg",
        "description": "qemu.scripts.qemugdb.tcg",
        "peekOfCode": "class TCGLockStatusCommand(gdb.Command):\n    '''Display TCG Execution Status'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu tcg-lock-status', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def invoke(self, arg, from_tty):\n        gdb.write(\"Thread, BQL (iothread_mutex), Replay, Blocked?\\n\")\n        for thread in gdb.inferiors()[0].threads():\n            thread.switch()\n            iothread = gdb.parse_and_eval(\"iothread_locked\")",
        "detail": "qemu.scripts.qemugdb.tcg",
        "documentation": {}
    },
    {
        "label": "TimersCommand",
        "kind": 6,
        "importPath": "qemu.scripts.qemugdb.timers",
        "description": "qemu.scripts.qemugdb.timers",
        "peekOfCode": "class TimersCommand(gdb.Command):\n    '''Display the current QEMU timers'''\n    def __init__(self):\n        'Register the class as a gdb command'\n        gdb.Command.__init__(self, 'qemu timers', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE)\n    def dump_timers(self, timer):\n        \"Follow a timer and recursively dump each one in the list.\"\n        # timer should be of type QemuTimer\n        gdb.write(\"    timer %s/%s (cb:%s,opq:%s)\\n\" % (",
        "detail": "qemu.scripts.qemugdb.timers",
        "documentation": {}
    },
    {
        "label": "CargoTOML",
        "kind": 6,
        "importPath": "qemu.scripts.rust.rustc_args",
        "description": "qemu.scripts.rust.rustc_args",
        "peekOfCode": "class CargoTOML:\n    tomldata: Mapping[Any, Any]\n    workspace_data: Mapping[Any, Any]\n    check_cfg: Set[str]\n    def __init__(self, path: Optional[str], workspace: Optional[str]):\n        if path is not None:\n            with open(path, 'rb') as f:\n                self.tomldata = tomllib.load(f)\n        else:\n            self.tomldata = {\"lints\": {\"workspace\": True}}",
        "detail": "qemu.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "LintFlag",
        "kind": 6,
        "importPath": "qemu.scripts.rust.rustc_args",
        "description": "qemu.scripts.rust.rustc_args",
        "peekOfCode": "class LintFlag:\n    flags: List[str]\n    priority: int\ndef generate_lint_flags(cargo_toml: CargoTOML, strict_lints: bool) -> Iterable[str]:\n    \"\"\"Converts Cargo.toml lints to rustc -A/-D/-F/-W flags.\"\"\"\n    toml_lints = cargo_toml.lints\n    lint_list = []\n    for k, v in toml_lints.items():\n        prefix = \"\" if k == \"rust\" else k + \"::\"\n        for lint, data in v.items():",
        "detail": "qemu.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "generate_lint_flags",
        "kind": 2,
        "importPath": "qemu.scripts.rust.rustc_args",
        "description": "qemu.scripts.rust.rustc_args",
        "peekOfCode": "def generate_lint_flags(cargo_toml: CargoTOML, strict_lints: bool) -> Iterable[str]:\n    \"\"\"Converts Cargo.toml lints to rustc -A/-D/-F/-W flags.\"\"\"\n    toml_lints = cargo_toml.lints\n    lint_list = []\n    for k, v in toml_lints.items():\n        prefix = \"\" if k == \"rust\" else k + \"::\"\n        for lint, data in v.items():\n            level = data if isinstance(data, str) else data[\"level\"]\n            priority = 0 if isinstance(data, str) else data.get(\"priority\", 0)\n            if level == \"deny\":",
        "detail": "qemu.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "generate_cfg_flags",
        "kind": 2,
        "importPath": "qemu.scripts.rust.rustc_args",
        "description": "qemu.scripts.rust.rustc_args",
        "peekOfCode": "def generate_cfg_flags(header: str, cargo_toml: CargoTOML) -> Iterable[str]:\n    \"\"\"Converts defines from config[..].h headers to rustc --cfg flags.\"\"\"\n    with open(header, encoding=\"utf-8\") as cfg:\n        config = [l.split()[1:] for l in cfg if l.startswith(\"#define\")]\n    cfg_list = []\n    for cfg in config:\n        name = cfg[0]\n        if f'cfg({name})' not in cargo_toml.check_cfg:\n            continue\n        if len(cfg) >= 2 and cfg[1] != \"1\":",
        "detail": "qemu.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.rust.rustc_args",
        "description": "qemu.scripts.rust.rustc_args",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    parser.add_argument(\n        \"--config-headers\",\n        metavar=\"CONFIG_HEADER\",\n        action=\"append\",\n        dest=\"config_headers\",\n        help=\"paths to any configuration C headers (*.h files), if any\",\n        required=False,",
        "detail": "qemu.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "STRICT_LINTS",
        "kind": 5,
        "importPath": "qemu.scripts.rust.rustc_args",
        "description": "qemu.scripts.rust.rustc_args",
        "peekOfCode": "STRICT_LINTS = {\"unknown_lints\", \"warnings\"}\nclass CargoTOML:\n    tomldata: Mapping[Any, Any]\n    workspace_data: Mapping[Any, Any]\n    check_cfg: Set[str]\n    def __init__(self, path: Optional[str], workspace: Optional[str]):\n        if path is not None:\n            with open(path, 'rb') as f:\n                self.tomldata = tomllib.load(f)\n        else:",
        "detail": "qemu.scripts.rust.rustc_args",
        "documentation": {}
    },
    {
        "label": "ExtendAction",
        "kind": 6,
        "importPath": "qemu.scripts.simplebench.bench-backup",
        "description": "qemu.scripts.simplebench.bench-backup",
        "peekOfCode": "class ExtendAction(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = getattr(namespace, self.dest) or []\n        items.extend(values)\n        setattr(namespace, self.dest, items)\nif __name__ == '__main__':\n    p = argparse.ArgumentParser('Backup benchmark', epilog='''\nENV format\n    (LABEL:PATH|LABEL|PATH)[,max-workers=N][,use-copy-range=(on|off)][,mirror]\n    LABEL                short name for the binary",
        "detail": "qemu.scripts.simplebench.bench-backup",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench-backup",
        "description": "qemu.scripts.simplebench.bench-backup",
        "peekOfCode": "def bench_func(env, case):\n    \"\"\" Handle one \"cell\" of benchmarking table. \"\"\"\n    cmd_options = env['cmd-options'] if 'cmd-options' in env else {}\n    return bench_block_copy(env['qemu-binary'], env['cmd'],\n                            cmd_options,\n                            case['source'], case['target'])\ndef bench(args):\n    test_cases = []\n    # paths with colon not supported, so we just split by ':'\n    dirs = dict(d.split(':') for d in args.dir)",
        "detail": "qemu.scripts.simplebench.bench-backup",
        "documentation": {}
    },
    {
        "label": "bench",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench-backup",
        "description": "qemu.scripts.simplebench.bench-backup",
        "peekOfCode": "def bench(args):\n    test_cases = []\n    # paths with colon not supported, so we just split by ':'\n    dirs = dict(d.split(':') for d in args.dir)\n    nbd_drv = None\n    if args.nbd:\n        nbd = args.nbd.split(':')\n        host = nbd[0]\n        port = '10809' if len(nbd) == 1 else nbd[1]\n        nbd_drv = drv_nbd(host, port)",
        "detail": "qemu.scripts.simplebench.bench-backup",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "def bench_func(env, case):\n    \"\"\" Handle one \"cell\" of benchmarking table. \"\"\"\n    return bench_block_copy(env['qemu_binary'], env['cmd'], {},\n                            case['source'], case['target'])\n# You may set the following five variables to correct values, to turn this\n# example to real benchmark.\nssd_source = '/path-to-raw-source-image-at-ssd'\nssd_target = '/path-to-raw-target-image-at-ssd'\nhdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "ssd_source",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "ssd_source = '/path-to-raw-source-image-at-ssd'\nssd_target = '/path-to-raw-target-image-at-ssd'\nhdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "ssd_target",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "ssd_target = '/path-to-raw-target-image-at-ssd'\nhdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "hdd_target",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "hdd_target = '/path-to-raw-source-image-at-hdd'\nnbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "nbd_ip",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "nbd_ip = 'nbd-ip-addr'\nnbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)\n    },",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "nbd_port",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "nbd_port = 'nbd-port-number'\n# Test-cases are \"rows\" in benchmark resulting table, 'id' is a caption for\n# the row, other fields are handled by bench_func.\ntest_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)\n    },\n    {",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "test_cases",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "test_cases = [\n    {\n        'id': 'ssd -> ssd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(ssd_target)\n    },\n    {\n        'id': 'ssd -> hdd',\n        'source': drv_file(ssd_source),\n        'target': drv_file(hdd_target)",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "test_envs",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "test_envs = [\n    {\n        'id': 'backup-1',\n        'cmd': 'blockdev-backup',\n        'qemu_binary': '/path-to-qemu-binary-1'\n    },\n    {\n        'id': 'backup-2',\n        'cmd': 'blockdev-backup',\n        'qemu_binary': '/path-to-qemu-binary-2'",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.bench-example",
        "description": "qemu.scripts.simplebench.bench-example",
        "peekOfCode": "result = simplebench.bench(bench_func, test_envs, test_cases, count=3)\nprint(results_to_text(result))",
        "detail": "qemu.scripts.simplebench.bench-example",
        "documentation": {}
    },
    {
        "label": "bench_block_job",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_block_job",
        "description": "qemu.scripts.simplebench.bench_block_job",
        "peekOfCode": "def bench_block_job(cmd, cmd_args, qemu_args):\n    \"\"\"Benchmark block-job\n    cmd       -- qmp command to run block-job (like blockdev-backup)\n    cmd_args  -- dict of qmp command arguments\n    qemu_args -- list of Qemu command line arguments, including path to Qemu\n                 binary\n    Returns {'seconds': int} on success and {'error': str} on failure, dict may\n    contain additional 'vm-log' field. Return value is compatible with\n    simplebench lib.\n    \"\"\"",
        "detail": "qemu.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "get_image_size",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_block_job",
        "description": "qemu.scripts.simplebench.bench_block_job",
        "peekOfCode": "def get_image_size(path):\n    out = subprocess.run(['qemu-img', 'info', '--out=json', path],\n                         stdout=subprocess.PIPE, check=True).stdout\n    return json.loads(out)['virtual-size']\ndef get_blockdev_size(obj):\n    img = obj['filename'] if 'filename' in obj else obj['file']['filename']\n    return get_image_size(img)\n# Bench backup or mirror\ndef bench_block_copy(qemu_binary, cmd, cmd_options, source, target):\n    \"\"\"Helper to run bench_block_job() for mirror or backup\"\"\"",
        "detail": "qemu.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "get_blockdev_size",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_block_job",
        "description": "qemu.scripts.simplebench.bench_block_job",
        "peekOfCode": "def get_blockdev_size(obj):\n    img = obj['filename'] if 'filename' in obj else obj['file']['filename']\n    return get_image_size(img)\n# Bench backup or mirror\ndef bench_block_copy(qemu_binary, cmd, cmd_options, source, target):\n    \"\"\"Helper to run bench_block_job() for mirror or backup\"\"\"\n    assert cmd in ('blockdev-backup', 'blockdev-mirror')\n    if target['driver'] == 'qcow2':\n        try:\n            os.remove(target['file']['filename'])",
        "detail": "qemu.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "bench_block_copy",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_block_job",
        "description": "qemu.scripts.simplebench.bench_block_job",
        "peekOfCode": "def bench_block_copy(qemu_binary, cmd, cmd_options, source, target):\n    \"\"\"Helper to run bench_block_job() for mirror or backup\"\"\"\n    assert cmd in ('blockdev-backup', 'blockdev-mirror')\n    if target['driver'] == 'qcow2':\n        try:\n            os.remove(target['file']['filename'])\n        except OSError:\n            pass\n        subprocess.run(['qemu-img', 'create', '-f', 'qcow2',\n                        target['file']['filename'],",
        "detail": "qemu.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_file",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_block_job",
        "description": "qemu.scripts.simplebench.bench_block_job",
        "peekOfCode": "def drv_file(filename, o_direct=True):\n    node = {'driver': 'file', 'filename': filename}\n    if o_direct:\n        node['cache'] = {'direct': True}\n        node['aio'] = 'native'\n    return node\ndef drv_nbd(host, port):\n    return {'driver': 'nbd',\n            'server': {'type': 'inet', 'host': host, 'port': port}}\ndef drv_qcow2(file):",
        "detail": "qemu.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_nbd",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_block_job",
        "description": "qemu.scripts.simplebench.bench_block_job",
        "peekOfCode": "def drv_nbd(host, port):\n    return {'driver': 'nbd',\n            'server': {'type': 'inet', 'host': host, 'port': port}}\ndef drv_qcow2(file):\n    return {'driver': 'qcow2', 'file': file}\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) < 4:\n        print('USAGE: {} <qmp block-job command name> '\n              '<json string of arguments for the command> '",
        "detail": "qemu.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "drv_qcow2",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_block_job",
        "description": "qemu.scripts.simplebench.bench_block_job",
        "peekOfCode": "def drv_qcow2(file):\n    return {'driver': 'qcow2', 'file': file}\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) < 4:\n        print('USAGE: {} <qmp block-job command name> '\n              '<json string of arguments for the command> '\n              '<qemu binary path and arguments>'.format(sys.argv[0]))\n        exit(1)\n    res = bench_block_job(sys.argv[1], json.loads(sys.argv[2]), sys.argv[3:])",
        "detail": "qemu.scripts.simplebench.bench_block_job",
        "documentation": {}
    },
    {
        "label": "qemu_img_bench",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_prealloc",
        "description": "qemu.scripts.simplebench.bench_prealloc",
        "peekOfCode": "def qemu_img_bench(args):\n    p = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,\n                       universal_newlines=True)\n    if p.returncode == 0:\n        try:\n            m = re.search(r'Run completed in (\\d+.\\d+) seconds.', p.stdout)\n            return {'seconds': float(m.group(1))}\n        except Exception:\n            return {'error': f'failed to parse qemu-img output: {p.stdout}'}\n    else:",
        "detail": "qemu.scripts.simplebench.bench_prealloc",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_prealloc",
        "description": "qemu.scripts.simplebench.bench_prealloc",
        "peekOfCode": "def bench_func(env, case):\n    fname = f\"{case['dir']}/prealloc-test.qcow2\"\n    try:\n        os.remove(fname)\n    except OSError:\n        pass\n    subprocess.run([env['qemu-img-binary'], 'create', '-f', 'qcow2', fname,\n                   '16G'], stdout=subprocess.DEVNULL,\n                   stderr=subprocess.DEVNULL, check=True)\n    args = [env['qemu-img-binary'], 'bench', '-c', str(case['count']),",
        "detail": "qemu.scripts.simplebench.bench_prealloc",
        "documentation": {}
    },
    {
        "label": "auto_count_bench_func",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_prealloc",
        "description": "qemu.scripts.simplebench.bench_prealloc",
        "peekOfCode": "def auto_count_bench_func(env, case):\n    case['count'] = 100\n    while True:\n        res = bench_func(env, case)\n        if 'error' in res:\n            return res\n        if res['seconds'] >= 1:\n            break\n        case['count'] *= 10\n    if res['seconds'] < 5:",
        "detail": "qemu.scripts.simplebench.bench_prealloc",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_write_req",
        "description": "qemu.scripts.simplebench.bench_write_req",
        "peekOfCode": "def bench_func(env, case):\n    \"\"\" Handle one \"cell\" of benchmarking table. \"\"\"\n    return bench_write_req(env['qemu_img'], env['image_name'],\n                           case['block_size'], case['block_offset'],\n                           case['cluster_size'])\ndef qemu_img_pipe(*args):\n    '''Run qemu-img and return its output'''\n    subp = subprocess.Popen(list(args),\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT,",
        "detail": "qemu.scripts.simplebench.bench_write_req",
        "documentation": {}
    },
    {
        "label": "qemu_img_pipe",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_write_req",
        "description": "qemu.scripts.simplebench.bench_write_req",
        "peekOfCode": "def qemu_img_pipe(*args):\n    '''Run qemu-img and return its output'''\n    subp = subprocess.Popen(list(args),\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT,\n                            universal_newlines=True)\n    exitcode = subp.wait()\n    if exitcode < 0:\n        sys.stderr.write('qemu-img received signal %i: %s\\n'\n                         % (-exitcode, ' '.join(list(args))))",
        "detail": "qemu.scripts.simplebench.bench_write_req",
        "documentation": {}
    },
    {
        "label": "bench_write_req",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.bench_write_req",
        "description": "qemu.scripts.simplebench.bench_write_req",
        "peekOfCode": "def bench_write_req(qemu_img, image_name, block_size, block_offset,\n                    cluster_size):\n    \"\"\"Benchmark write requests\n    The function creates a QCOW2 image with the given path/name. Then it runs\n    the 'qemu-img bench' command and makes series of write requests on the\n    image clusters. Finally, it returns the total time of the write operations\n    on the disk.\n    qemu_img     -- path to qemu_img executable file\n    image_name   -- QCOW2 image name to create\n    block_size   -- size of a block to write to clusters",
        "detail": "qemu.scripts.simplebench.bench_write_req",
        "documentation": {}
    },
    {
        "label": "bench_func",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.img_bench_templater",
        "description": "qemu.scripts.simplebench.img_bench_templater",
        "peekOfCode": "def bench_func(env, case):\n    test = templater.gen(env['data'], case['data'])\n    p = subprocess.run(test, shell=True, stdout=subprocess.PIPE,\n                       stderr=subprocess.STDOUT, universal_newlines=True)\n    if p.returncode == 0:\n        try:\n            m = re.search(r'Run completed in (\\d+.\\d+) seconds.', p.stdout)\n            return {'seconds': float(m.group(1))}\n        except Exception:\n            return {'error': f'failed to parse qemu-img output: {p.stdout}'}",
        "detail": "qemu.scripts.simplebench.img_bench_templater",
        "documentation": {}
    },
    {
        "label": "format_value",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.results_to_text",
        "description": "qemu.scripts.simplebench.results_to_text",
        "peekOfCode": "def format_value(x, stdev):\n    stdev_pr = stdev / x * 100\n    if stdev_pr < 1.5:\n        # don't care too much\n        return f'{x:.2g}'\n    else:\n        return f'{x:.2g}  {math.ceil(stdev_pr)}%'\ndef result_to_text(result):\n    \"\"\"Return text representation of bench_one() returned dict.\"\"\"\n    if 'average' in result:",
        "detail": "qemu.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "result_to_text",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.results_to_text",
        "description": "qemu.scripts.simplebench.results_to_text",
        "peekOfCode": "def result_to_text(result):\n    \"\"\"Return text representation of bench_one() returned dict.\"\"\"\n    if 'average' in result:\n        s = format_value(result['average'], result['stdev'])\n        if 'n-failed' in result:\n            s += '\\n({} failed)'.format(result['n-failed'])\n        return s\n    else:\n        return 'FAILED'\ndef results_dimension(results):",
        "detail": "qemu.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "results_dimension",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.results_to_text",
        "description": "qemu.scripts.simplebench.results_to_text",
        "peekOfCode": "def results_dimension(results):\n    dim = None\n    for case in results['cases']:\n        for env in results['envs']:\n            res = results['tab'][case['id']][env['id']]\n            if dim is None:\n                dim = res['dimension']\n            else:\n                assert dim == res['dimension']\n    assert dim in ('iops', 'seconds')",
        "detail": "qemu.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "results_to_text",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.results_to_text",
        "description": "qemu.scripts.simplebench.results_to_text",
        "peekOfCode": "def results_to_text(results):\n    \"\"\"Return text representation of bench() returned dict.\"\"\"\n    n_columns = len(results['envs'])\n    named_columns = n_columns > 2\n    dim = results_dimension(results)\n    tab = []\n    if named_columns:\n        # Environment columns are named A, B, ...\n        tab.append([''] + [chr(ord('A') + i) for i in range(n_columns)])\n    tab.append([''] + [c['id'] for c in results['envs']])",
        "detail": "qemu.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "tabulate.PRESERVE_WHITESPACE",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.results_to_text",
        "description": "qemu.scripts.simplebench.results_to_text",
        "peekOfCode": "tabulate.PRESERVE_WHITESPACE = True\ndef format_value(x, stdev):\n    stdev_pr = stdev / x * 100\n    if stdev_pr < 1.5:\n        # don't care too much\n        return f'{x:.2g}'\n    else:\n        return f'{x:.2g}  {math.ceil(stdev_pr)}%'\ndef result_to_text(result):\n    \"\"\"Return text representation of bench_one() returned dict.\"\"\"",
        "detail": "qemu.scripts.simplebench.results_to_text",
        "documentation": {}
    },
    {
        "label": "do_drop_caches",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.simplebench",
        "description": "qemu.scripts.simplebench.simplebench",
        "peekOfCode": "def do_drop_caches():\n    subprocess.run('sync; echo 3 > /proc/sys/vm/drop_caches', shell=True,\n                   check=True)\ndef bench_one(test_func, test_env, test_case, count=5, initial_run=True,\n              slow_limit=100, drop_caches=False):\n    \"\"\"Benchmark one test-case\n    test_func   -- benchmarking function with prototype\n                   test_func(env, case), which takes test_env and test_case\n                   arguments and on success returns dict with 'seconds' or\n                   'iops' (or both) fields, specifying the benchmark result.",
        "detail": "qemu.scripts.simplebench.simplebench",
        "documentation": {}
    },
    {
        "label": "bench_one",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.simplebench",
        "description": "qemu.scripts.simplebench.simplebench",
        "peekOfCode": "def bench_one(test_func, test_env, test_case, count=5, initial_run=True,\n              slow_limit=100, drop_caches=False):\n    \"\"\"Benchmark one test-case\n    test_func   -- benchmarking function with prototype\n                   test_func(env, case), which takes test_env and test_case\n                   arguments and on success returns dict with 'seconds' or\n                   'iops' (or both) fields, specifying the benchmark result.\n                   If both 'iops' and 'seconds' provided, the 'iops' is\n                   considered the main, and 'seconds' is just an additional\n                   info. On failure test_func should return {'error': str}.",
        "detail": "qemu.scripts.simplebench.simplebench",
        "documentation": {}
    },
    {
        "label": "bench",
        "kind": 2,
        "importPath": "qemu.scripts.simplebench.simplebench",
        "description": "qemu.scripts.simplebench.simplebench",
        "peekOfCode": "def bench(test_func, test_envs, test_cases, *args, **vargs):\n    \"\"\"Fill benchmark table\n    test_func -- benchmarking function, see bench_one for description\n    test_envs -- list of test environments, see bench_one\n    test_cases -- list of test cases, see bench_one\n    args, vargs -- additional arguments for bench_one\n    Returns dict with the following fields:\n        'envs':  test_envs\n        'cases': test_cases\n        'tab':   filled 2D array, where cell [i][j] is bench_one result for",
        "detail": "qemu.scripts.simplebench.simplebench",
        "documentation": {}
    },
    {
        "label": "Templater",
        "kind": 6,
        "importPath": "qemu.scripts.simplebench.table_templater",
        "description": "qemu.scripts.simplebench.table_templater",
        "peekOfCode": "class Templater:\n    def __init__(self, template):\n        self.tree = parser.parse(template)\n        c_switches = []\n        r_switches = []\n        for x in self.tree.children:\n            if x.data == 'column_switch':\n                c_switches.append([el.children[0].value for el in x.children])\n            elif x.data == 'row_switch':\n                r_switches.append([el.children[0].value for el in x.children])",
        "detail": "qemu.scripts.simplebench.table_templater",
        "documentation": {}
    },
    {
        "label": "grammar",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.table_templater",
        "description": "qemu.scripts.simplebench.table_templater",
        "peekOfCode": "grammar = \"\"\"\nstart: ( text | column_switch | row_switch )+\ncolumn_switch: \"{\" text [\"|\" text]+ \"}\"\nrow_switch: \"[\" text [\"|\" text]+ \"]\"\ntext: /[^|{}\\[\\]]+/\n\"\"\"\nparser = Lark(grammar)\nclass Templater:\n    def __init__(self, template):\n        self.tree = parser.parse(template)",
        "detail": "qemu.scripts.simplebench.table_templater",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.scripts.simplebench.table_templater",
        "description": "qemu.scripts.simplebench.table_templater",
        "peekOfCode": "parser = Lark(grammar)\nclass Templater:\n    def __init__(self, template):\n        self.tree = parser.parse(template)\n        c_switches = []\n        r_switches = []\n        for x in self.tree.children:\n            if x.data == 'column_switch':\n                c_switches.append([el.children[0].value for el in x.children])\n            elif x.data == 'row_switch':",
        "detail": "qemu.scripts.simplebench.table_templater",
        "documentation": {}
    },
    {
        "label": "probeprefix",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY\ndef generate_h_begin(events, group):",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "binary",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY\ndef generate_h_begin(events, group):\n    if group == \"root\":\n        header = \"trace-dtrace-root.h\"\n    else:\n        header = \"trace-dtrace-%s.h\" % group\n    # Workaround for ust backend, which also includes <sys/sdt.h> and may",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def generate_h_begin(events, group):\n    if group == \"root\":\n        header = \"trace-dtrace-root.h\"\n    else:\n        header = \"trace-dtrace-%s.h\" % group\n    # Workaround for ust backend, which also includes <sys/sdt.h> and may\n    # require SDT_USE_VARIADIC to be defined. If dtrace includes <sys/sdt.h>\n    # first without defining SDT_USE_VARIADIC then ust breaks because the\n    # STAP_PROBEV() macro is not defined.\n    out('#ifndef SDT_USE_VARIADIC')",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def generate_h(event, group):\n    out('    QEMU_%(uppername)s(%(argnames)s);',\n        uppername=event.name.upper(),\n        argnames=\", \".join(event.args.names()))\ndef generate_h_backend_dstate(event, group):\n    out('    QEMU_%(uppername)s_ENABLED() || \\\\',\n        uppername=event.name.upper())",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    QEMU_%(uppername)s_ENABLED() || \\\\',\n        uppername=event.name.upper())",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nPUBLIC = True\nPROBEPREFIX = None\ndef probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "PUBLIC = True\nPROBEPREFIX = None\ndef probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "PROBEPREFIX",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "PROBEPREFIX = None\ndef probeprefix():\n    if PROBEPREFIX is None:\n        raise ValueError(\"you must set PROBEPREFIX\")\n    return PROBEPREFIX\nBINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "BINARY",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.dtrace",
        "description": "qemu.scripts.tracetool.backend.dtrace",
        "peekOfCode": "BINARY = None\ndef binary():\n    if BINARY is None:\n        raise ValueError(\"you must set BINARY\")\n    return BINARY\ndef generate_h_begin(events, group):\n    if group == \"root\":\n        header = \"trace-dtrace-root.h\"\n    else:\n        header = \"trace-dtrace-%s.h\" % group",
        "detail": "qemu.scripts.tracetool.backend.dtrace",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.ftrace",
        "description": "qemu.scripts.tracetool.backend.ftrace",
        "peekOfCode": "def generate_h_begin(events, group):\n    out('#include \"trace/ftrace.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    {',\n        '        char ftrace_buf[MAX_TRACE_STRLEN];',\n        '        int unused __attribute__ ((unused));',",
        "detail": "qemu.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.ftrace",
        "description": "qemu.scripts.tracetool.backend.ftrace",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    {',\n        '        char ftrace_buf[MAX_TRACE_STRLEN];',\n        '        int unused __attribute__ ((unused));',\n        '        int trlen;',\n        '        if (trace_event_get_state(%(event_id)s)) {',\n        '#line %(event_lineno)d \"%(event_filename)s\"',",
        "detail": "qemu.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.ftrace",
        "description": "qemu.scripts.tracetool.backend.ftrace",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())",
        "detail": "qemu.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.ftrace",
        "description": "qemu.scripts.tracetool.backend.ftrace",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport os.path\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"trace/ftrace.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())",
        "detail": "qemu.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.ftrace",
        "description": "qemu.scripts.tracetool.backend.ftrace",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"trace/ftrace.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    {',\n        '        char ftrace_buf[MAX_TRACE_STRLEN];',",
        "detail": "qemu.scripts.tracetool.backend.ftrace",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.log",
        "description": "qemu.scripts.tracetool.backend.log",
        "peekOfCode": "def generate_h_begin(events, group):\n    out('#include \"qemu/log-for-trace.h\"',\n        '#include \"qemu/error-report.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code",
        "detail": "qemu.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.log",
        "description": "qemu.scripts.tracetool.backend.log",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code\n        cond = \"true\"\n    else:\n        cond = \"trace_event_get_state(%s)\" % (\"TRACE_\" + event.name.upper())\n    out('    if (%(cond)s && qemu_loglevel_mask(LOG_TRACE)) {',",
        "detail": "qemu.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.log",
        "description": "qemu.scripts.tracetool.backend.log",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())",
        "detail": "qemu.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.log",
        "description": "qemu.scripts.tracetool.backend.log",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport os.path\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"qemu/log-for-trace.h\"',\n        '#include \"qemu/error-report.h\"',\n        '')\ndef generate_h(event, group):",
        "detail": "qemu.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.log",
        "description": "qemu.scripts.tracetool.backend.log",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include \"qemu/log-for-trace.h\"',\n        '#include \"qemu/error-report.h\"',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:",
        "detail": "qemu.scripts.tracetool.backend.log",
        "documentation": {}
    },
    {
        "label": "is_string",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "def is_string(arg):\n    strtype = ('const char*', 'char*', 'const char *', 'char *')\n    arg_strip = arg.lstrip()\n    if arg_strip.startswith(strtype) and arg_strip.count('*') == 1:\n        return True\n    else:\n        return False\ndef generate_h_begin(events, group):\n    for event in events:\n        out('void _simple_%(api)s(%(args)s);',",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_h_begin(events, group):\n    for event in events:\n        out('void _simple_%(api)s(%(args)s);',\n            api=event.api(),\n            args=event.args)\n    out('')\ndef generate_h(event, group):\n    out('    _simple_%(api)s(%(args)s);',\n        api=event.api(),\n        args=\", \".join(event.args.names()))",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_h(event, group):\n    out('    _simple_%(api)s(%(args)s);',\n        api=event.api(),\n        args=\", \".join(event.args.names()))\ndef generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())\ndef generate_c_begin(events, group):\n    out('#include \"qemu/osdep.h\"',\n        '#include \"trace/control.h\"',",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())\ndef generate_c_begin(events, group):\n    out('#include \"qemu/osdep.h\"',\n        '#include \"trace/control.h\"',\n        '#include \"trace/simple.h\"',\n        '')\ndef generate_c(event, group):\n    out('void _simple_%(api)s(%(args)s)',",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_c_begin",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_c_begin(events, group):\n    out('#include \"qemu/osdep.h\"',\n        '#include \"trace/control.h\"',\n        '#include \"trace/simple.h\"',\n        '')\ndef generate_c(event, group):\n    out('void _simple_%(api)s(%(args)s)',\n        '{',\n        '    TraceBufferRecord rec;',\n        api=event.api(),",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_c",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "def generate_c(event, group):\n    out('void _simple_%(api)s(%(args)s)',\n        '{',\n        '    TraceBufferRecord rec;',\n        api=event.api(),\n        args=event.args)\n    sizes = []\n    for type_, name in event.args:\n        if is_string(type_):\n            out('    size_t arg%(name)s_len = %(name)s ? MIN(strlen(%(name)s), MAX_TRACE_STRLEN) : 0;',",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nPUBLIC = True\ndef is_string(arg):\n    strtype = ('const char*', 'char*', 'const char *', 'char *')\n    arg_strip = arg.lstrip()\n    if arg_strip.startswith(strtype) and arg_strip.count('*') == 1:\n        return True\n    else:",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.simple",
        "description": "qemu.scripts.tracetool.backend.simple",
        "peekOfCode": "PUBLIC = True\ndef is_string(arg):\n    strtype = ('const char*', 'char*', 'const char *', 'char *')\n    arg_strip = arg.lstrip()\n    if arg_strip.startswith(strtype) and arg_strip.count('*') == 1:\n        return True\n    else:\n        return False\ndef generate_h_begin(events, group):\n    for event in events:",
        "detail": "qemu.scripts.tracetool.backend.simple",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.syslog",
        "description": "qemu.scripts.tracetool.backend.syslog",
        "peekOfCode": "def generate_h_begin(events, group):\n    out('#include <syslog.h>',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code\n        cond = \"true\"",
        "detail": "qemu.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.syslog",
        "description": "qemu.scripts.tracetool.backend.syslog",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code\n        cond = \"true\"\n    else:\n        cond = \"trace_event_get_state(%s)\" % (\"TRACE_\" + event.name.upper())\n    out('    if (%(cond)s) {',",
        "detail": "qemu.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.syslog",
        "description": "qemu.scripts.tracetool.backend.syslog",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    trace_event_get_state_dynamic_by_id(%(event_id)s) || \\\\',\n        event_id=\"TRACE_\" + event.name.upper())",
        "detail": "qemu.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.syslog",
        "description": "qemu.scripts.tracetool.backend.syslog",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport os.path\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include <syslog.h>',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())",
        "detail": "qemu.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.syslog",
        "description": "qemu.scripts.tracetool.backend.syslog",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    out('#include <syslog.h>',\n        '')\ndef generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    if \"vcpu\" in event.properties:\n        # already checked on the generic format code",
        "detail": "qemu.scripts.tracetool.backend.syslog",
        "documentation": {}
    },
    {
        "label": "generate_h_begin",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.ust",
        "description": "qemu.scripts.tracetool.backend.ust",
        "peekOfCode": "def generate_h_begin(events, group):\n    header = 'trace-ust-' + group + '.h'\n    out('#include <lttng/tracepoint.h>',\n        '#include \"%s\"' % header,\n        '',\n        '/* tracepoint_enabled() was introduced in LTTng UST 2.7 */',\n        '#ifndef tracepoint_enabled',\n        '#define tracepoint_enabled(a, b) true',\n        '#endif',\n        '')",
        "detail": "qemu.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "generate_h",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.ust",
        "description": "qemu.scripts.tracetool.backend.ust",
        "peekOfCode": "def generate_h(event, group):\n    argnames = \", \".join(event.args.names())\n    if len(event.args) > 0:\n        argnames = \", \" + argnames\n    out('    tracepoint(qemu, %(name)s%(tp_args)s);',\n        name=event.name,\n        tp_args=argnames)\ndef generate_h_backend_dstate(event, group):\n    out('    tracepoint_enabled(qemu, %(name)s) || \\\\',\n        name=event.name)",
        "detail": "qemu.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "generate_h_backend_dstate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.backend.ust",
        "description": "qemu.scripts.tracetool.backend.ust",
        "peekOfCode": "def generate_h_backend_dstate(event, group):\n    out('    tracepoint_enabled(qemu, %(name)s) || \\\\',\n        name=event.name)",
        "detail": "qemu.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.ust",
        "description": "qemu.scripts.tracetool.backend.ust",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nPUBLIC = True\ndef generate_h_begin(events, group):\n    header = 'trace-ust-' + group + '.h'\n    out('#include <lttng/tracepoint.h>',\n        '#include \"%s\"' % header,\n        '',\n        '/* tracepoint_enabled() was introduced in LTTng UST 2.7 */',",
        "detail": "qemu.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "PUBLIC",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.backend.ust",
        "description": "qemu.scripts.tracetool.backend.ust",
        "peekOfCode": "PUBLIC = True\ndef generate_h_begin(events, group):\n    header = 'trace-ust-' + group + '.h'\n    out('#include <lttng/tracepoint.h>',\n        '#include \"%s\"' % header,\n        '',\n        '/* tracepoint_enabled() was introduced in LTTng UST 2.7 */',\n        '#ifndef tracepoint_enabled',\n        '#define tracepoint_enabled(a, b) true',\n        '#endif',",
        "detail": "qemu.scripts.tracetool.backend.ust",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.c",
        "description": "qemu.scripts.tracetool.format.c",
        "peekOfCode": "def generate(events, backend, group):\n    active_events = [e for e in events\n                     if \"disable\" not in e.properties]\n    header = \"trace-\" + group + \".h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',\n        '#include \"qemu/module.h\"',\n        '#include \"%s\"' % header,\n        '')",
        "detail": "qemu.scripts.tracetool.format.c",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.c",
        "description": "qemu.scripts.tracetool.format.c",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    active_events = [e for e in events\n                     if \"disable\" not in e.properties]\n    header = \"trace-\" + group + \".h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',",
        "detail": "qemu.scripts.tracetool.format.c",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.d",
        "description": "qemu.scripts.tracetool.format.d",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disable\" not in e.properties]\n    # SystemTap's dtrace(1) warns about empty \"provider qemu {}\" but is happy\n    # with an empty file.  Avoid the warning.\n    # But dtrace on macOS can't deal with empty files.\n    if not events and platform != \"darwin\":\n        return\n    out('/* This file is autogenerated by tracetool, do not edit. */'\n        '',",
        "detail": "qemu.scripts.tracetool.format.d",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.d",
        "description": "qemu.scripts.tracetool.format.d",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nfrom sys import platform\n# Reserved keywords from\n# https://wikis.oracle.com/display/DTrace/Types,+Operators+and+Expressions\nRESERVED_WORDS = (\n    'auto', 'goto', 'sizeof', 'break', 'if', 'static', 'case', 'import',\n    'string', 'char', 'inline', 'stringof', 'const', 'int', 'struct',\n    'continue', 'long', 'switch', 'counter', 'offsetof', 'this',",
        "detail": "qemu.scripts.tracetool.format.d",
        "documentation": {}
    },
    {
        "label": "RESERVED_WORDS",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.d",
        "description": "qemu.scripts.tracetool.format.d",
        "peekOfCode": "RESERVED_WORDS = (\n    'auto', 'goto', 'sizeof', 'break', 'if', 'static', 'case', 'import',\n    'string', 'char', 'inline', 'stringof', 'const', 'int', 'struct',\n    'continue', 'long', 'switch', 'counter', 'offsetof', 'this',\n    'default', 'probe', 'translator', 'do', 'provider', 'typedef',\n    'double', 'register', 'union', 'else', 'restrict', 'unsigned',\n    'enum', 'return', 'void', 'extern', 'self', 'volatile', 'float',\n    'short', 'while', 'for', 'signed', 'xlate',\n)\ndef generate(events, backend, group):",
        "detail": "qemu.scripts.tracetool.format.d",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.h",
        "description": "qemu.scripts.tracetool.format.h",
        "peekOfCode": "def generate(events, backend, group):\n    header = \"trace/control.h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#ifndef TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '#define TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '',\n        '#include \"%s\"' % header,\n        '')\n    for e in events:",
        "detail": "qemu.scripts.tracetool.format.h",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.h",
        "description": "qemu.scripts.tracetool.format.h",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    header = \"trace/control.h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#ifndef TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '#define TRACE_%s_GENERATED_TRACERS_H' % group.upper(),\n        '',",
        "detail": "qemu.scripts.tracetool.format.h",
        "documentation": {}
    },
    {
        "label": "global_var_name",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "def global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\nSTATE_SKIP = 0\nSTATE_LITERAL = 1\nSTATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "c_macro_to_format",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "def c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"\n    macro = \"\"\n    escape = 0;",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "c_fmt_to_stap",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "def c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"\n    macro = \"\"\n    escape = 0;\n    for i in range(len(fmt)):\n        if fmt[i] == '\\\\':\n            if escape:\n                escape = 0",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "def generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for event_id, e in enumerate(events):\n        if 'disable' in e.properties:\n            continue\n        out('probe %(probeprefix)s.log.%(name)s = %(probeprefix)s.%(name)s ?',\n            '{',\n            probeprefix=probeprefix(),\n            name=e.name)",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "__maintainer__ = \"Daniel Berrange\"\n__email__      = \"berrange@redhat.com\"\nimport re\nfrom tracetool import out\nfrom tracetool.backend.dtrace import binary, probeprefix\nfrom tracetool.backend.simple import is_string\nfrom tracetool.format.stap import stap_escape\ndef global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\nSTATE_SKIP = 0",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "STATE_SKIP",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "STATE_SKIP = 0\nSTATE_LITERAL = 1\nSTATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "STATE_LITERAL",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "STATE_LITERAL = 1\nSTATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "STATE_MACRO",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.log_stap",
        "description": "qemu.scripts.tracetool.format.log_stap",
        "peekOfCode": "STATE_MACRO = 2\ndef c_macro_to_format(macro):\n    if macro.startswith(\"PRI\"):\n        return macro[3]\n    raise Exception(\"Unhandled macro '%s'\" % macro)\ndef c_fmt_to_stap(fmt):\n    state = 0\n    bits = []\n    literal = \"\"\n    macro = \"\"",
        "detail": "qemu.scripts.tracetool.format.log_stap",
        "documentation": {}
    },
    {
        "label": "global_var_name",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.simpletrace_stap",
        "description": "qemu.scripts.tracetool.format.simpletrace_stap",
        "peekOfCode": "def global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\ndef generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for event_id, e in enumerate(events):\n        if 'disable' in e.properties:\n            continue\n        out('probe %(probeprefix)s.simpletrace.%(name)s = %(probeprefix)s.%(name)s ?',\n            '{',",
        "detail": "qemu.scripts.tracetool.format.simpletrace_stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.simpletrace_stap",
        "description": "qemu.scripts.tracetool.format.simpletrace_stap",
        "peekOfCode": "def generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for event_id, e in enumerate(events):\n        if 'disable' in e.properties:\n            continue\n        out('probe %(probeprefix)s.simpletrace.%(name)s = %(probeprefix)s.%(name)s ?',\n            '{',\n            probeprefix=probeprefix(),\n            name=e.name)",
        "detail": "qemu.scripts.tracetool.format.simpletrace_stap",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.simpletrace_stap",
        "description": "qemu.scripts.tracetool.format.simpletrace_stap",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nfrom tracetool.backend.dtrace import probeprefix\nfrom tracetool.backend.simple import is_string\nfrom tracetool.format.stap import stap_escape\ndef global_var_name(name):\n    return probeprefix().replace(\".\", \"_\") + \"_\" + name\ndef generate(events, backend, group):\n    out('/* This file is autogenerated by tracetool, do not edit. */',",
        "detail": "qemu.scripts.tracetool.format.simpletrace_stap",
        "documentation": {}
    },
    {
        "label": "stap_escape",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.stap",
        "description": "qemu.scripts.tracetool.format.stap",
        "peekOfCode": "def stap_escape(identifier):\n    # Append underscore to reserved keywords\n    if identifier in RESERVED_WORDS:\n        return identifier + '_'\n    return identifier\ndef generate(events, backend, group):\n    events = [e for e in events\n              if \"disable\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')",
        "detail": "qemu.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.stap",
        "description": "qemu.scripts.tracetool.format.stap",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disable\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '')\n    for e in events:\n        # Define prototype for probe arguments\n        out('probe %(probeprefix)s.%(name)s = process(\"%(binary)s\").mark(\"%(name)s\")',\n            '{',\n            probeprefix=probeprefix(),",
        "detail": "qemu.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.stap",
        "description": "qemu.scripts.tracetool.format.stap",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\nfrom tracetool.backend.dtrace import binary, probeprefix\n# Technically 'self' is not used by systemtap yet, but\n# they recommended we keep it in the reserved list anyway\nRESERVED_WORDS = (\n    'break', 'catch', 'continue', 'delete', 'else', 'for',\n    'foreach', 'function', 'global', 'if', 'in', 'limit',\n    'long', 'next', 'probe', 'return', 'self', 'string',",
        "detail": "qemu.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "RESERVED_WORDS",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.stap",
        "description": "qemu.scripts.tracetool.format.stap",
        "peekOfCode": "RESERVED_WORDS = (\n    'break', 'catch', 'continue', 'delete', 'else', 'for',\n    'foreach', 'function', 'global', 'if', 'in', 'limit',\n    'long', 'next', 'probe', 'return', 'self', 'string',\n    'try', 'while'\n    )\ndef stap_escape(identifier):\n    # Append underscore to reserved keywords\n    if identifier in RESERVED_WORDS:\n        return identifier + '_'",
        "detail": "qemu.scripts.tracetool.format.stap",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.ust_events_c",
        "description": "qemu.scripts.tracetool.format.ust_events_c",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',\n        '',\n        '#define TRACEPOINT_DEFINE',\n        '#define TRACEPOINT_CREATE_PROBES',\n        '',",
        "detail": "qemu.scripts.tracetool.format.ust_events_c",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.ust_events_c",
        "description": "qemu.scripts.tracetool.format.ust_events_c",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#include \"qemu/osdep.h\"',\n        '',",
        "detail": "qemu.scripts.tracetool.format.ust_events_c",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool.format.ust_events_h",
        "description": "qemu.scripts.tracetool.format.ust_events_h",
        "peekOfCode": "def generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    if group == \"all\":\n        include = \"trace-ust-all.h\"\n    else:\n        include = \"trace-ust.h\"\n    out('/* This file is autogenerated by tracetool, do not edit. */',\n        '',\n        '#undef TRACEPOINT_PROVIDER',",
        "detail": "qemu.scripts.tracetool.format.ust_events_h",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool.format.ust_events_h",
        "description": "qemu.scripts.tracetool.format.ust_events_h",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nfrom tracetool import out\ndef generate(events, backend, group):\n    events = [e for e in events\n              if \"disabled\" not in e.properties]\n    if group == \"all\":\n        include = \"trace-ust-all.h\"\n    else:\n        include = \"trace-ust.h\"",
        "detail": "qemu.scripts.tracetool.format.ust_events_h",
        "documentation": {}
    },
    {
        "label": "VirtFSRequestTracker",
        "kind": 6,
        "importPath": "qemu.scripts.analyse-9p-simpletrace",
        "description": "qemu.scripts.analyse-9p-simpletrace",
        "peekOfCode": "class VirtFSRequestTracker(simpletrace.Analyzer):\n        def begin(self):\n                print(\"Pretty printing 9p simpletrace log ...\")\n        def v9fs_rerror(self, tag, id, err):\n                print(\"RERROR (tag =\", tag, \", id =\", symbol_9p[id], \", err = \\\"\", os.strerror(err), \"\\\")\")\n        def v9fs_version(self, tag, id, msize, version):\n                print(\"TVERSION (tag =\", tag, \", msize =\", msize, \", version =\", version, \")\")\n        def v9fs_version_return(self, tag, id, msize, version):\n                print(\"RVERSION (tag =\", tag, \", msize =\", msize, \", version =\", version, \")\")\n        def v9fs_attach(self, tag, id, fid, afid, uname, aname):",
        "detail": "qemu.scripts.analyse-9p-simpletrace",
        "documentation": {}
    },
    {
        "label": "symbol_9p",
        "kind": 5,
        "importPath": "qemu.scripts.analyse-9p-simpletrace",
        "description": "qemu.scripts.analyse-9p-simpletrace",
        "peekOfCode": "symbol_9p = {\n    6   : 'TLERROR',\n    7   : 'RLERROR',\n    8   : 'TSTATFS',\n    9   : 'RSTATFS',\n    12  : 'TLOPEN',\n    13  : 'RLOPEN',\n    14  : 'TLCREATE',\n    15  : 'RLCREATE',\n    16  : 'TSYMLINK',",
        "detail": "qemu.scripts.analyse-9p-simpletrace",
        "documentation": {}
    },
    {
        "label": "MutexAnalyser",
        "kind": 6,
        "importPath": "qemu.scripts.analyse-locks-simpletrace",
        "description": "qemu.scripts.analyse-locks-simpletrace",
        "peekOfCode": "class MutexAnalyser(simpletrace.Analyzer):\n    \"A simpletrace Analyser for checking locks.\"\n    def __init__(self):\n        self.locks = 0\n        self.locked = 0\n        self.unlocks = 0\n        self.mutex_records = {}\n    def _get_mutex(self, mutex):\n        if not mutex in self.mutex_records:\n            self.mutex_records[mutex] = {\"locks\": 0,",
        "detail": "qemu.scripts.analyse-locks-simpletrace",
        "documentation": {}
    },
    {
        "label": "get_args",
        "kind": 2,
        "importPath": "qemu.scripts.analyse-locks-simpletrace",
        "description": "qemu.scripts.analyse-locks-simpletrace",
        "peekOfCode": "def get_args():\n    \"Grab options\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--output\", \"-o\", type=str, help=\"Render plot to file\")\n    parser.add_argument(\"events\", type=str, help='trace file read from')\n    parser.add_argument(\"tracefile\", type=str, help='trace file read from')\n    return parser.parse_args()\nif __name__ == '__main__':\n    args = get_args()\n    # Gather data from the trace",
        "detail": "qemu.scripts.analyse-locks-simpletrace",
        "documentation": {}
    },
    {
        "label": "MigrationFile",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class MigrationFile(object):\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = open(self.filename, \"rb\")\n    def read64(self):\n        return int.from_bytes(self.file.read(8), byteorder='big', signed=False)\n    def read32(self):\n        return int.from_bytes(self.file.read(4), byteorder='big', signed=False)\n    def read16(self):\n        return int.from_bytes(self.file.read(2), byteorder='big', signed=False)",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "RamSection",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class RamSection(object):\n    RAM_SAVE_FLAG_COMPRESS = 0x02\n    RAM_SAVE_FLAG_MEM_SIZE = 0x04\n    RAM_SAVE_FLAG_PAGE     = 0x08\n    RAM_SAVE_FLAG_EOS      = 0x10\n    RAM_SAVE_FLAG_CONTINUE = 0x20\n    RAM_SAVE_FLAG_XBZRLE   = 0x40\n    RAM_SAVE_FLAG_HOOK     = 0x80\n    RAM_SAVE_FLAG_COMPRESS_PAGE = 0x100\n    RAM_SAVE_FLAG_MULTIFD_FLUSH = 0x200",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "HTABSection",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class HTABSection(object):\n    HASH_PTE_SIZE_64       = 16\n    def __init__(self, file, version_id, device, section_key):\n        if version_id != 1:\n            raise Exception(\"Unknown HTAB version %d\" % version_id)\n        self.file = file\n        self.section_key = section_key\n    def read(self):\n        header = self.file.read32()\n        if (header == -1):",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "S390StorageAttributes",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class S390StorageAttributes(object):\n    STATTR_FLAG_EOS   = 0x01\n    STATTR_FLAG_MORE  = 0x02\n    STATTR_FLAG_ERROR = 0x04\n    STATTR_FLAG_DONE  = 0x08\n    def __init__(self, file, version_id, device, section_key):\n        if version_id != 0:\n            raise Exception(\"Unknown storage_attributes version %d\" % version_id)\n        self.file = file\n        self.section_key = section_key",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "ConfigurationSection",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class ConfigurationSection(object):\n    def __init__(self, file, desc):\n        self.file = file\n        self.desc = desc\n        self.caps = []\n    def parse_capabilities(self, vmsd_caps):\n        if not vmsd_caps:\n            return\n        ncaps = vmsd_caps.data['caps_count'].data\n        self.caps = vmsd_caps.data['capabilities']",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldGeneric",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldGeneric(object):\n    def __init__(self, desc, file):\n        self.file = file\n        self.desc = desc\n        self.data = \"\"\n    def __repr__(self):\n        return str(self.__str__())\n    def __str__(self):\n        return \" \".join(\"{0:02x}\".format(c) for c in self.data)\n    def getDict(self):",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldCap",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldCap(object):\n    def __init__(self, desc, file):\n        self.file = file\n        self.desc = desc\n        self.data = \"\"\n    def __repr__(self):\n        return self.data\n    def __str__(self):\n        return self.data\n    def read(self):",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldInt",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldInt(VMSDFieldGeneric):\n    def __init__(self, desc, file):\n        super(VMSDFieldInt, self).__init__(desc, file)\n        self.size = int(desc['size'])\n        self.format = '0x%%0%dx' % (self.size * 2)\n        self.sdtype = '>i%d' % self.size\n        self.udtype = '>u%d' % self.size\n    def __repr__(self):\n        if self.data < 0:\n            return ('%s (%d)' % ((self.format % self.udata), self.data))",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldUInt",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldUInt(VMSDFieldInt):\n    def __init__(self, desc, file):\n        super(VMSDFieldUInt, self).__init__(desc, file)\n    def read(self):\n        super(VMSDFieldUInt, self).read()\n        self.data = self.udata\n        return self.data\nclass VMSDFieldIntLE(VMSDFieldInt):\n    def __init__(self, desc, file):\n        super(VMSDFieldIntLE, self).__init__(desc, file)",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldIntLE",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldIntLE(VMSDFieldInt):\n    def __init__(self, desc, file):\n        super(VMSDFieldIntLE, self).__init__(desc, file)\n        self.dtype = '<i%d' % self.size\nclass VMSDFieldNull(VMSDFieldGeneric):\n    NULL_PTR_MARKER = b'0'\n    def __init__(self, desc, file):\n        super(VMSDFieldNull, self).__init__(desc, file)\n    def __repr__(self):\n        # A NULL pointer is encoded in the stream as a '0' to",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldNull",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldNull(VMSDFieldGeneric):\n    NULL_PTR_MARKER = b'0'\n    def __init__(self, desc, file):\n        super(VMSDFieldNull, self).__init__(desc, file)\n    def __repr__(self):\n        # A NULL pointer is encoded in the stream as a '0' to\n        # disambiguate from a mere 0x0 value and avoid consumers\n        # trying to follow the NULL pointer. Displaying '0', 0x30 or\n        # 0x0 when analyzing the JSON debug stream could become\n        # confusing, so use an explicit term instead.",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldBool",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldBool(VMSDFieldGeneric):\n    def __init__(self, desc, file):\n        super(VMSDFieldBool, self).__init__(desc, file)\n    def __repr__(self):\n        return self.data.__repr__()\n    def __str__(self):\n        return self.data.__str__()\n    def getDict(self):\n        return self.data\n    def read(self):",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDFieldStruct",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDFieldStruct(VMSDFieldGeneric):\n    QEMU_VM_SUBSECTION    = 0x05\n    def __init__(self, desc, file):\n        super(VMSDFieldStruct, self).__init__(desc, file)\n        self.data = collections.OrderedDict()\n        if 'fields' not in self.desc['struct']:\n            raise Exception(\"No fields in struct. VMSD:\\n%s\" % self.desc)\n        # When we see compressed array elements, unfold them here\n        new_fields = []\n        for field in self.desc['struct']['fields']:",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "VMSDSection",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class VMSDSection(VMSDFieldStruct):\n    def __init__(self, file, version_id, device, section_key):\n        self.file = file\n        self.data = \"\"\n        self.vmsd_name = \"\"\n        self.section_key = section_key\n        desc = device\n        if 'vmsd_name' in device:\n            self.vmsd_name = device['vmsd_name']\n        # A section really is nothing but a FieldStruct :)",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "MigrationDump",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class MigrationDump(object):\n    QEMU_VM_FILE_MAGIC    = 0x5145564d\n    QEMU_VM_FILE_VERSION  = 0x00000003\n    QEMU_VM_EOF           = 0x00\n    QEMU_VM_SECTION_START = 0x01\n    QEMU_VM_SECTION_PART  = 0x02\n    QEMU_VM_SECTION_END   = 0x03\n    QEMU_VM_SECTION_FULL  = 0x04\n    QEMU_VM_SUBSECTION    = 0x05\n    QEMU_VM_VMDESCRIPTION = 0x06",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "JSONEncoder",
        "kind": 6,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "class JSONEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, VMSDFieldGeneric):\n            return str(o)\n        return json.JSONEncoder.default(self, o)\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-f\", \"--file\", help='migration dump to read from', required=True)\nparser.add_argument(\"-m\", \"--memory\", help='dump RAM contents as well', action='store_true')\nparser.add_argument(\"-d\", \"--dump\", help='what to dump (\"state\" or \"desc\")', default='state')\nparser.add_argument(\"-x\", \"--extract\", help='extract contents into individual files', action='store_true')",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "def mkdir_p(path):\n    try:\n        os.makedirs(path)\n    except OSError:\n        pass\nclass MigrationFile(object):\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = open(self.filename, \"rb\")\n    def read64(self):",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "vmsd_field_readers",
        "kind": 5,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "vmsd_field_readers = {\n    \"bool\" : VMSDFieldBool,\n    \"int8\" : VMSDFieldInt,\n    \"int16\" : VMSDFieldInt,\n    \"int32\" : VMSDFieldInt,\n    \"int32 equal\" : VMSDFieldInt,\n    \"int32 le\" : VMSDFieldIntLE,\n    \"int64\" : VMSDFieldInt,\n    \"uint8\" : VMSDFieldUInt,\n    \"uint16\" : VMSDFieldUInt,",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"-f\", \"--file\", help='migration dump to read from', required=True)\nparser.add_argument(\"-m\", \"--memory\", help='dump RAM contents as well', action='store_true')\nparser.add_argument(\"-d\", \"--dump\", help='what to dump (\"state\" or \"desc\")', default='state')\nparser.add_argument(\"-x\", \"--extract\", help='extract contents into individual files', action='store_true')\nargs = parser.parse_args()\njsonenc = JSONEncoder(indent=4, separators=(',', ': '))\nif not any([args.extract, args.dump == \"state\", args.dump == \"desc\"]):\n    raise Exception(\"Please specify either -x, -d state or -d desc\")\ntry:",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "args = parser.parse_args()\njsonenc = JSONEncoder(indent=4, separators=(',', ': '))\nif not any([args.extract, args.dump == \"state\", args.dump == \"desc\"]):\n    raise Exception(\"Please specify either -x, -d state or -d desc\")\ntry:\n    dump = MigrationDump(args.file)\n    if args.extract:\n        dump.read(desc_only = True)\n        print(\"desc.json\")\n        f = open(\"desc.json\", \"w\")",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "jsonenc",
        "kind": 5,
        "importPath": "qemu.scripts.analyze-migration",
        "description": "qemu.scripts.analyze-migration",
        "peekOfCode": "jsonenc = JSONEncoder(indent=4, separators=(',', ': '))\nif not any([args.extract, args.dump == \"state\", args.dump == \"desc\"]):\n    raise Exception(\"Please specify either -x, -d state or -d desc\")\ntry:\n    dump = MigrationDump(args.file)\n    if args.extract:\n        dump.read(desc_only = True)\n        print(\"desc.json\")\n        f = open(\"desc.json\", \"w\")\n        f.truncate()",
        "detail": "qemu.scripts.analyze-migration",
        "documentation": {}
    },
    {
        "label": "ParamDecl",
        "kind": 6,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "class ParamDecl:\n    param_re = re.compile(r'(?P<decl>'\n                          r'(?P<type>.*[ *])'\n                          r'(?P<name>[a-z][a-z0-9_]*)'\n                          r')')\n    def __init__(self, param_decl: str) -> None:\n        m = self.param_re.match(param_decl.strip())\n        if m is None:\n            raise ValueError(f'Wrong parameter declaration: \"{param_decl}\"')\n        self.decl = m.group('decl')",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "FuncDecl",
        "kind": 6,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "class FuncDecl:\n    def __init__(self, wrapper_type: str, return_type: str, name: str,\n                 args: str, variant: str) -> None:\n        self.return_type = return_type.strip()\n        self.name = name.strip()\n        self.struct_name = snake_to_camel(self.name)\n        self.args = [ParamDecl(arg.strip()) for arg in args.split(',')]\n        self.create_only_co = 'mixed' not in variant\n        self.graph_rdlock = 'bdrv_rdlock' in variant\n        self.graph_wrlock = 'bdrv_wrlock' in variant",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_header",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_header():\n    copyright = re.sub('^.*Copyright', 'Copyright', __doc__, flags=re.DOTALL)\n    copyright = re.sub('^(?=.)', ' * ', copyright.strip(), flags=re.MULTILINE)\n    copyright = re.sub('^$', ' *', copyright, flags=re.MULTILINE)\n    return f\"\"\"\\\n/*\n * File is generated by scripts/block-coroutine-wrapper.py\n *\n{copyright}\n */",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "func_decl_iter",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def func_decl_iter(text: str) -> Iterator:\n    for m in func_decl_re.finditer(text):\n        yield FuncDecl(wrapper_type=m.group('wrapper_type'),\n                       return_type=m.group('return_type'),\n                       name=m.group('wrapper_name'),\n                       args=m.group('args'),\n                       variant=m.group('variant'))\ndef snake_to_camel(func_name: str) -> str:\n    \"\"\"\n    Convert underscore names like 'some_function_name' to camel-case like",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "snake_to_camel",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def snake_to_camel(func_name: str) -> str:\n    \"\"\"\n    Convert underscore names like 'some_function_name' to camel-case like\n    'SomeFunctionName'\n    \"\"\"\n    words = func_name.split('_')\n    words = [w[0].upper() + w[1:] for w in words]\n    return ''.join(words)\ndef create_mixed_wrapper(func: FuncDecl) -> str:\n    \"\"\"",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "create_mixed_wrapper",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def create_mixed_wrapper(func: FuncDecl) -> str:\n    \"\"\"\n    Checks if we are already in coroutine\n    \"\"\"\n    name = func.target_name\n    struct_name = func.struct_name\n    graph_assume_lock = 'assume_graph_lock();' if func.graph_rdlock else ''\n    return f\"\"\"\\\n{func.return_type} {func.name}({ func.gen_list('{decl}') })\n{{",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "create_co_wrapper",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def create_co_wrapper(func: FuncDecl) -> str:\n    \"\"\"\n    Assumes we are not in coroutine, and creates one\n    \"\"\"\n    name = func.target_name\n    struct_name = func.struct_name\n    return f\"\"\"\\\n{func.return_type} {func.name}({ func.gen_list('{decl}') })\n{{\n    {struct_name} s = {{",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_co_wrapper",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_co_wrapper(func: FuncDecl) -> str:\n    assert not '_co_' in func.name\n    assert func.wrapper_type == 'co'\n    name = func.target_name\n    struct_name = func.struct_name\n    graph_lock=''\n    graph_unlock=''\n    if func.graph_rdlock:\n        graph_lock='    bdrv_graph_co_rdlock();'\n        graph_unlock='    bdrv_graph_co_rdunlock();'",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_no_co_wrapper",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_no_co_wrapper(func: FuncDecl) -> str:\n    assert '_co_' in func.name\n    assert func.wrapper_type == 'no_co'\n    name = func.target_name\n    struct_name = func.struct_name\n    graph_lock=''\n    graph_unlock=''\n    if func.graph_rdlock:\n        graph_lock='    bdrv_graph_rdlock_main_loop();'\n        graph_unlock='    bdrv_graph_rdunlock_main_loop();'",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "gen_wrappers",
        "kind": 2,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "def gen_wrappers(input_code: str) -> str:\n    res = ''\n    for func in func_decl_iter(input_code):\n        res += '\\n\\n\\n'\n        if func.wrapper_type == 'co':\n            res += gen_co_wrapper(func)\n        else:\n            res += gen_no_co_wrapper(func)\n    return res\nif __name__ == '__main__':",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "func_decl_re",
        "kind": 5,
        "importPath": "qemu.scripts.block-coroutine-wrapper",
        "description": "qemu.scripts.block-coroutine-wrapper",
        "peekOfCode": "func_decl_re = re.compile(r'^(?P<return_type>[a-zA-Z][a-zA-Z0-9_]* [\\*]?)'\n                          r'(\\s*coroutine_fn)?'\n                          r'\\s*(?P<wrapper_type>(no_)?co)_wrapper'\n                          r'(?P<variant>(_[a-z][a-z0-9_]*)?)\\s*'\n                          r'(?P<wrapper_name>[a-z][a-z0-9_]*)'\n                          r'\\((?P<args>[^)]*)\\);$', re.MULTILINE)\ndef func_decl_iter(text: str) -> Iterator:\n    for m in func_decl_re.finditer(text):\n        yield FuncDecl(wrapper_type=m.group('wrapper_type'),\n                       return_type=m.group('return_type'),",
        "detail": "qemu.scripts.block-coroutine-wrapper",
        "documentation": {}
    },
    {
        "label": "cmdline_for_sparse",
        "kind": 2,
        "importPath": "qemu.scripts.check_sparse",
        "description": "qemu.scripts.check_sparse",
        "peekOfCode": "def cmdline_for_sparse(sparse, cmdline):\n    # Do not include the C compiler executable\n    skip = True\n    arg = False\n    out = sparse + ['-no-compile']\n    for x in cmdline:\n        if arg:\n            out.append(x)\n            arg = False\n            continue",
        "detail": "qemu.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "build_path",
        "kind": 2,
        "importPath": "qemu.scripts.check_sparse",
        "description": "qemu.scripts.check_sparse",
        "peekOfCode": "def build_path(s):\n    return s if not root_path else os.path.join(root_path, s)\nccjson_path = build_path(sys.argv[1])\nwith open(ccjson_path, 'r') as fd:\n    compile_commands = json.load(fd)\nsparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)",
        "detail": "qemu.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "root_path",
        "kind": 5,
        "importPath": "qemu.scripts.check_sparse",
        "description": "qemu.scripts.check_sparse",
        "peekOfCode": "root_path = os.getenv('MESON_BUILD_ROOT')\ndef build_path(s):\n    return s if not root_path else os.path.join(root_path, s)\nccjson_path = build_path(sys.argv[1])\nwith open(ccjson_path, 'r') as fd:\n    compile_commands = json.load(fd)\nsparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])",
        "detail": "qemu.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "ccjson_path",
        "kind": 5,
        "importPath": "qemu.scripts.check_sparse",
        "description": "qemu.scripts.check_sparse",
        "peekOfCode": "ccjson_path = build_path(sys.argv[1])\nwith open(ccjson_path, 'r') as fd:\n    compile_commands = json.load(fd)\nsparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)\n    print('REAL_CC=%s' % shlex.quote(cmdline[0]),\n          ' '.join((shlex.quote(x) for x in cmd)))",
        "detail": "qemu.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "sparse",
        "kind": 5,
        "importPath": "qemu.scripts.check_sparse",
        "description": "qemu.scripts.check_sparse",
        "peekOfCode": "sparse = sys.argv[2:]\nsparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)\n    print('REAL_CC=%s' % shlex.quote(cmdline[0]),\n          ' '.join((shlex.quote(x) for x in cmd)))\n    sparse_env['REAL_CC'] = cmdline[0]\n    r = subprocess.run(cmd, env=sparse_env, cwd=root_path)\n    if r.returncode != 0:",
        "detail": "qemu.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "sparse_env",
        "kind": 5,
        "importPath": "qemu.scripts.check_sparse",
        "description": "qemu.scripts.check_sparse",
        "peekOfCode": "sparse_env = os.environ.copy()\nfor cmd in compile_commands:\n    cmdline = shlex.split(cmd['command'])\n    cmd = cmdline_for_sparse(sparse, cmdline)\n    print('REAL_CC=%s' % shlex.quote(cmdline[0]),\n          ' '.join((shlex.quote(x) for x in cmd)))\n    sparse_env['REAL_CC'] = cmdline[0]\n    r = subprocess.run(cmd, env=sparse_env, cwd=root_path)\n    if r.returncode != 0:\n        sys.exit(r.returncode)",
        "detail": "qemu.scripts.check_sparse",
        "documentation": {}
    },
    {
        "label": "Driver",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class Driver():\n    def __init__(self, vm: QEMUMachine, name: str, abstract: bool) -> None:\n        self.vm = vm\n        self.name = name\n        self.abstract = abstract\n        self.parent: Optional[Driver] = None\n        self.property_getter: Optional[Driver] = None\n    def get_prop(self, driver: str, prop: str) -> str:\n        if self.property_getter:\n            return self.property_getter.get_prop(driver, prop)",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUObject",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class QEMUObject(Driver):\n    def __init__(self, vm: QEMUMachine, name: str) -> None:\n        super().__init__(vm, name, True)\n    def set_implementations(self, implementations: List[Driver]) -> None:\n        self.implementations = implementations\n        # each implementation of the abstract driver has to use property getter\n        # of this abstract driver unless it has specialization. (e.g. having\n        # 'device' and 'x86_64-cpu', property getter of 'x86_64-cpu' will be\n        # used for '486-x86_64-cpu')\n        for impl in implementations:",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUDevice",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class QEMUDevice(QEMUObject):\n    def __init__(self, vm: QEMUMachine) -> None:\n        super().__init__(vm, 'device')\n        self.cached: Dict[str, List[Dict[str, Any]]] = {}\n    def get_prop(self, driver: str, prop_name: str) -> str:\n        if driver not in self.cached:\n            self.cached[driver] = self.vm.cmd('device-list-properties',\n                                              typename=driver)\n        for prop in self.cached[driver]:\n            if prop['name'] == prop_name:",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUx86CPU",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class QEMUx86CPU(QEMUObject):\n    def __init__(self, vm: QEMUMachine) -> None:\n        super().__init__(vm, 'x86_64-cpu')\n        self.cached: Dict[str, Dict[str, Any]] = {}\n    def get_prop(self, driver: str, prop_name: str) -> str:\n        if not driver.endswith('-x86_64-cpu'):\n            return 'Wrong x86_64-cpu name'\n        # crop last 11 chars '-x86_64-cpu'\n        name = driver[:-11]\n        if name not in self.cached:",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "QEMUMemoryBackend",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class QEMUMemoryBackend(QEMUObject):\n    def __init__(self, vm: QEMUMachine) -> None:\n        super().__init__(vm, 'memory-backend')\n        self.cached: Dict[str, List[Dict[str, Any]]] = {}\n    def get_prop(self, driver: str, prop_name: str) -> str:\n        if driver not in self.cached:\n            self.cached[driver] = self.vm.cmd('qom-list-properties',\n                                              typename=driver)\n        for prop in self.cached[driver]:\n            if prop['name'] == prop_name:",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "VMPropertyGetter",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class VMPropertyGetter:\n    \"\"\"It implements the relationship between drivers and how to get their\n    properties\"\"\"\n    def __init__(self, vm: QEMUMachine) -> None:\n        self.drivers: Dict[str, Driver] = {}\n        qom_all_types = vm.cmd('qom-list-types', abstract=True)\n        self.drivers = {t['name']: new_driver(vm, t['name'],\n                                              t.get('abstract', False))\n                        for t in qom_all_types}\n        for t in qom_all_types:",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "Machine",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class Machine:\n    \"\"\"A short QEMU machine type description. It contains only processed\n    compat_props (properties of abstract classes are applied to its\n    implementations)\n    \"\"\"\n    # raw_mt_dict - dict produced by `query-machines`\n    def __init__(self, raw_mt_dict: Dict[str, Any],\n                 qemu_drivers: VMPropertyGetter) -> None:\n        self.name = raw_mt_dict['name']\n        self.compat_props: Dict[str, Any] = {}",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "Configuration",
        "kind": 6,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "class Configuration():\n    \"\"\"Class contains all necessary components to generate table and is used\n    to compare different binaries\"\"\"\n    def __init__(self, vm: QEMUMachine,\n                 req_mt: List[str], all_mt: bool) -> None:\n        self._vm = vm\n        self._binary = vm.binary\n        self._qemu_args = args.qemu_args.split(' ')\n        self._qemu_drivers = VMPropertyGetter(vm)\n        self.req_mt = get_req_mt(self._qemu_drivers, vm, req_mt, all_mt)",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "new_driver",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def new_driver(vm: QEMUMachine, name: str, is_abstr: bool) -> Driver:\n    if name == 'object':\n        return QEMUObject(vm, 'object')\n    elif name == 'device':\n        return QEMUDevice(vm)\n    elif name == 'x86_64-cpu':\n        return QEMUx86CPU(vm)\n    elif name == 'memory-backend':\n        return QEMUMemoryBackend(vm)\n    else:",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def parse_args() -> Namespace:\n    parser = ArgumentParser(formatter_class=RawTextHelpFormatter,\n                            description=script_desc)\n    parser.add_argument('--format', choices=['human-readable', 'json', 'csv'],\n                        default='human-readable',\n                        help='returns table in json format')\n    parser.add_argument('--raw', action='store_true',\n                        help='prints ALL defined properties without value '\n                             'transformation. By default, only rows '\n                             'with different values will be printed and '",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "mt_comp",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def mt_comp(mt: Machine) -> Tuple[str, int, int, int]:\n    \"\"\"Function to compare and sort machine by names.\n    It returns socket_name, major version, minor version, revision\"\"\"\n    # none, microvm, x-remote and etc.\n    if '-' not in mt.name or '.' not in mt.name:\n        return mt.name, 0, 0, 0\n    socket, ver = mt.name.rsplit('-', 1)\n    ver_list = list(map(int, ver.split('.', 2)))\n    ver_list += [0] * (3 - len(ver_list))\n    return socket, ver_list[0], ver_list[1], ver_list[2]",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "get_mt_definitions",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def get_mt_definitions(qemu_drivers: VMPropertyGetter,\n                       vm: QEMUMachine) -> List[Machine]:\n    \"\"\"Constructs list of machine definitions (primarily compat_props) via\n    info from QEMU\"\"\"\n    raw_mt_defs = vm.cmd('query-machines', compat_props=True)\n    mt_defs = []\n    for raw_mt in raw_mt_defs:\n        mt_defs.append(Machine(raw_mt, qemu_drivers))\n    mt_defs.sort(key=mt_comp)\n    return mt_defs",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "get_req_mt",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def get_req_mt(qemu_drivers: VMPropertyGetter, vm: QEMUMachine,\n               req_mt: Optional[List[str]], all_mt: bool) -> List[Machine]:\n    \"\"\"Returns list of requested by user machines\"\"\"\n    mt_defs = get_mt_definitions(qemu_drivers, vm)\n    if all_mt:\n        return mt_defs\n    if req_mt is None:\n        print('Enter machine types for comparision')\n        exit(0)\n    matched_mt = []",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "get_affected_props",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def get_affected_props(configs: List[Configuration]) -> Generator[Tuple[str,\n                                                                        str],\n                                                                  None, None]:\n    \"\"\"Helps to go through all affected in machine definitions drivers\n    and properties\"\"\"\n    driver_props: Dict[str, Set[Any]] = {}\n    for config in configs:\n        for mt in config.req_mt:\n            compat_props = mt.compat_props\n            for driver, prop in compat_props.items():",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "transform_value",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def transform_value(value: str) -> Union[str, bool]:\n    true_list = ['true', 'on']\n    false_list = ['false', 'off']\n    out = value.lower()\n    if out in true_list:\n        return True\n    if out in false_list:\n        return False\n    return value\ndef simplify_table(table: pd.DataFrame) -> pd.DataFrame:",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "simplify_table",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def simplify_table(table: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"transforms values to make it easier to compare it and drops rows\n    with the same values for all columns\"\"\"\n    table = table.map(transform_value)\n    return table[~table.iloc[:, 3:].eq(table.iloc[:, 2], axis=0).all(axis=1)]\n# constructs table in the format:\n#\n# Driver  | Property  | binary1  | binary1  | ...\n#         |           | machine1 | machine2 | ...\n# ------------------------------------------------------ ...",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "fill_prop_table",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def fill_prop_table(configs: List[Configuration],\n                    is_raw: bool) -> pd.DataFrame:\n    req_props = list(get_affected_props(configs))\n    if not req_props:\n        print('No drivers to compare. Check machine names')\n        exit(0)\n    driver_col, prop_col = tuple(zip(*req_props))\n    table = [pd.DataFrame({'Driver': driver_col}),\n             pd.DataFrame({'Property': prop_col})]\n    table.extend([config.get_table(req_props) for config in configs])",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "print_table",
        "kind": 2,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "def print_table(table: pd.DataFrame, table_format: str) -> None:\n    if table_format == 'json':\n        print(comp_table.to_json())\n    elif table_format == 'csv':\n        print(comp_table.to_csv())\n    else:\n        print(comp_table.to_markdown(index=False, stralign='center',\n                                     colalign=('center',), headers='keys',\n                                     tablefmt='fancy_grid',\n                                     disable_numparse=True))",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "default_qemu_args",
        "kind": 5,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "default_qemu_args = '-enable-kvm -machine none'\ndefault_qemu_binary = 'build/qemu-system-x86_64'\n# Methods for gettig the right values of drivers properties\n#\n# Use these methods as a 'whitelist' and add entries only if necessary. It's\n# important to be stable and predictable in analysis and tests.\n# Be careful:\n# * Class must be inherited from 'QEMUObject' and used in new_driver()\n# * Class has to implement get_prop method in order to get values\n# * Specialization always wins (with the given classes for 'device' and",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "default_qemu_binary",
        "kind": 5,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "default_qemu_binary = 'build/qemu-system-x86_64'\n# Methods for gettig the right values of drivers properties\n#\n# Use these methods as a 'whitelist' and add entries only if necessary. It's\n# important to be stable and predictable in analysis and tests.\n# Be careful:\n# * Class must be inherited from 'QEMUObject' and used in new_driver()\n# * Class has to implement get_prop method in order to get values\n# * Specialization always wins (with the given classes for 'device' and\n#   'x86_64-cpu', method of 'x86_64-cpu' will be used for '486-x86_64-cpu')",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "script_desc",
        "kind": 5,
        "importPath": "qemu.scripts.compare-machine-types",
        "description": "qemu.scripts.compare-machine-types",
        "peekOfCode": "script_desc = \"\"\"Script to compare machine types (their compat_props).\nExamples:\n* save info about all machines:  ./scripts/compare-machine-types.py --all \\\n--format csv --raw > table.csv\n* compare machines: ./scripts/compare-machine-types.py --mt pc-q35-2.12 \\\npc-q35-3.0\n* compare binaries and machines: ./scripts/compare-machine-types.py \\\n--mt pc-q35-6.2 pc-q35-7.0 --qemu-binary build/qemu-system-x86_64 \\\nbuild/qemu-exp\n  \\",
        "detail": "qemu.scripts.compare-machine-types",
        "documentation": {}
    },
    {
        "label": "print_uarch_abi_csv",
        "kind": 2,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "def print_uarch_abi_csv():\n    print(\"Model,baseline,v2,v3,v4\")\n    for name in models.keys():\n        print(name, end=\"\")\n        for level in range(len(levels)):\n            if models[name][\"levels\"][level]:\n                print(\",\", end=\"\")\n            else:\n                print(\",\", end=\"\")\n        print()",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "levels",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "levels = [\n    [ # x86-64 baseline\n        \"cmov\",\n        \"cx8\",\n        \"fpu\",\n        \"fxsr\",\n        \"mmx\",\n        \"syscall\",\n        \"sse\",\n        \"sse2\",",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "sock = sys.argv[1]\nshell = QEMUMonitorProtocol(sock)\nshell.connect()\nmodels = shell.cmd(\"query-cpu-definitions\")\n# These QMP props don't correspond to CPUID fatures\n# so ignore them\nskip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "shell",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "shell = QEMUMonitorProtocol(sock)\nshell.connect()\nmodels = shell.cmd(\"query-cpu-definitions\")\n# These QMP props don't correspond to CPUID fatures\n# so ignore them\nskip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",\n    \"vendor\",",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "models = shell.cmd(\"query-cpu-definitions\")\n# These QMP props don't correspond to CPUID fatures\n# so ignore them\nskip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",\n    \"vendor\",\n    \"model\",\n    \"model-id\",",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "skip",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "skip = [\n    \"family\",\n    \"min-level\",\n    \"min-xlevel\",\n    \"vendor\",\n    \"model\",\n    \"model-id\",\n    \"stepping\",\n]\nnames = []",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "names = []\nfor model in models:\n    if \"alias-of\" in model:\n        continue\n    names.append(model[\"name\"])\nmodels = {}\nfor name in sorted(names):\n    cpu = shell.cmd(\"query-cpu-model-expansion\",\n                    type=\"static\",\n                    model={ \"name\": name })",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "models",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "models = {}\nfor name in sorted(names):\n    cpu = shell.cmd(\"query-cpu-model-expansion\",\n                    type=\"static\",\n                    model={ \"name\": name })\n    got = {}\n    for (feature, present) in cpu[\"model\"][\"props\"].items():\n        if present and feature not in skip:\n            got[feature] = True\n    if name in [\"host\", \"max\", \"base\"]:",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "abi_models",
        "kind": 5,
        "importPath": "qemu.scripts.cpu-x86-uarch-abi",
        "description": "qemu.scripts.cpu-x86-uarch-abi",
        "peekOfCode": "abi_models = [\n    [],\n    [],\n    [],\n    [],\n]\nfor name in models.keys():\n    for level in range(len(levels)):\n        if models[name][\"levels\"][level]:\n            abi_models[level].append(name)",
        "detail": "qemu.scripts.cpu-x86-uarch-abi",
        "documentation": {}
    },
    {
        "label": "CycleError",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class CycleError(ValueError):\n    \"\"\"Subclass of ValueError raised if cycles exist in the graph\"\"\"\n    pass\nclass TopologicalSorter:\n    \"\"\"Topologically sort a graph\"\"\"\n    def __init__(self, graph=None):\n        self.graph = graph\n    def static_order(self):\n        # We do the sort right here, unlike the stdlib version\n        from functools import reduce",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "TopologicalSorter",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class TopologicalSorter:\n    \"\"\"Topologically sort a graph\"\"\"\n    def __init__(self, graph=None):\n        self.graph = graph\n    def static_order(self):\n        # We do the sort right here, unlike the stdlib version\n        from functools import reduce\n        data = {}\n        r = []\n        if not self.graph:",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Field",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class Field:\n    \"\"\"Class representing a simple instruction field\"\"\"\n    def __init__(self, sign, pos, len):\n        self.sign = sign\n        self.pos = pos\n        self.len = len\n        self.mask = ((1 << len) - 1) << pos\n    def __str__(self):\n        if self.sign:\n            s = 's'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "MultiField",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class MultiField:\n    \"\"\"Class representing a compound instruction field\"\"\"\n    def __init__(self, subs, mask):\n        self.subs = subs\n        self.sign = subs[0].sign\n        self.mask = mask\n    def __str__(self):\n        return str(self.subs)\n    def str_extract(self, lvalue_formatter):\n        global bitop_width",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ConstField",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class ConstField:\n    \"\"\"Class representing an argument field with constant value\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.mask = 0\n        self.sign = value < 0\n    def __str__(self):\n        return str(self.value)\n    def str_extract(self, lvalue_formatter):\n        return str(self.value)",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "FunctionField",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class FunctionField:\n    \"\"\"Class representing a field passed through a function\"\"\"\n    def __init__(self, func, base):\n        self.mask = base.mask\n        self.sign = base.sign\n        self.base = base\n        self.func = func\n    def __str__(self):\n        return self.func + '(' + str(self.base) + ')'\n    def str_extract(self, lvalue_formatter):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ParameterField",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class ParameterField:\n    \"\"\"Class representing a pseudo-field read from a function\"\"\"\n    def __init__(self, func):\n        self.mask = 0\n        self.sign = 0\n        self.func = func\n    def __str__(self):\n        return self.func\n    def str_extract(self, lvalue_formatter):\n        return self.func + '(ctx)'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "NamedField",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class NamedField:\n    \"\"\"Class representing a field already named in the pattern\"\"\"\n    def __init__(self, name, sign, len):\n        self.mask = 0\n        self.sign = sign\n        self.len = len\n        self.name = name\n    def __str__(self):\n        return self.name\n    def str_extract(self, lvalue_formatter):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Arguments",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class Arguments:\n    \"\"\"Class representing the extracted fields of a format\"\"\"\n    def __init__(self, nm, flds, types, extern):\n        self.name = nm\n        self.extern = extern\n        self.fields = flds\n        self.types = types\n    def __str__(self):\n        return self.name + ' ' + str(self.fields)\n    def struct_name(self):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "General",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class General:\n    \"\"\"Common code between instruction formats and instruction patterns\"\"\"\n    def __init__(self, name, lineno, base, fixb, fixm, udfm, fldm, flds, w):\n        self.name = name\n        self.file = input_file\n        self.lineno = lineno\n        self.base = base\n        self.fixedbits = fixb\n        self.fixedmask = fixm\n        self.undefmask = udfm",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Format",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class Format(General):\n    \"\"\"Class representing an instruction format\"\"\"\n    def extract_name(self):\n        global decode_function\n        return decode_function + '_extract_' + self.name\n    def output_extract(self):\n        output('static void ', self.extract_name(), '(DisasContext *ctx, ',\n               self.base.struct_name(), ' *a, ', insntype, ' insn)\\n{\\n')\n        self.output_fields(str_indent(4), lambda n: 'a->' + n)\n        output('}\\n\\n')",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class Pattern(General):\n    \"\"\"Class representing an instruction pattern\"\"\"\n    def output_decl(self):\n        global translate_scope\n        global translate_prefix\n        output('typedef ', self.base.base.struct_name(),\n               ' arg_', self.name, ';\\n')\n        output(translate_scope, 'bool ', translate_prefix, '_', self.name,\n               '(DisasContext *ctx, arg_', self.name, ' *a);\\n')\n    def output_code(self, i, extracted, outerbits, outermask):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "MultiPattern",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class MultiPattern(General):\n    \"\"\"Class representing a set of instruction patterns\"\"\"\n    def __init__(self, lineno):\n        self.file = input_file\n        self.lineno = lineno\n        self.pats = []\n        self.base = None\n        self.fixedbits = 0\n        self.fixedmask = 0\n        self.undefmask = 0",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "IncMultiPattern",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class IncMultiPattern(MultiPattern):\n    \"\"\"Class representing an overlapping set of instruction patterns\"\"\"\n    def output_code(self, i, extracted, outerbits, outermask):\n        global translate_prefix\n        ind = str_indent(i)\n        for p in self.pats:\n            if outermask != p.fixedmask:\n                innermask = p.fixedmask & ~outermask\n                innerbits = p.fixedbits & ~outermask\n                output(ind, f'if ((insn & {whexC(innermask)}) == {whexC(innerbits)}) {{\\n')",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class Tree:\n    \"\"\"Class representing a node in a decode tree\"\"\"\n    def __init__(self, fm, tm):\n        self.fixedmask = fm\n        self.thismask = tm\n        self.subs = []\n        self.base = None\n    def str1(self, i):\n        ind = str_indent(i)\n        r = ind + whex(self.fixedmask)",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ExcMultiPattern",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class ExcMultiPattern(MultiPattern):\n    \"\"\"Class representing a non-overlapping set of instruction patterns\"\"\"\n    def output_code(self, i, extracted, outerbits, outermask):\n        # Defer everything to our decomposed Tree node\n        self.tree.output_code(i, extracted, outerbits, outermask)\n    @staticmethod\n    def __build_tree(pats, outerbits, outermask):\n        # Find the intersection of all remaining fixedmask.\n        innermask = ~outermask & insnmask\n        for i in pats:",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "SizeTree",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class SizeTree:\n    \"\"\"Class representing a node in a size decode tree\"\"\"\n    def __init__(self, m, w):\n        self.mask = m\n        self.subs = []\n        self.base = None\n        self.width = w\n    def str1(self, i):\n        ind = str_indent(i)\n        r = ind + whex(self.mask) + ' [\\n'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "SizeLeaf",
        "kind": 6,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "class SizeLeaf:\n    \"\"\"Class representing a leaf node in a size decode tree\"\"\"\n    def __init__(self, m, w):\n        self.mask = m\n        self.width = w\n    def str1(self, i):\n        return str_indent(i) + whex(self.mask)\n    def __str__(self):\n        return self.str1(0)\n    def output_code(self, i, extracted, outerbits, outermask):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "error_with_file",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def error_with_file(file, lineno, *args):\n    \"\"\"Print an error message from file:line and args and exit.\"\"\"\n    global output_file\n    global output_fd\n    # For the test suite expected-errors case, don't print the\n    # string \"error: \", so they don't turn up as false positives\n    # if you grep the meson logs for strings like that.\n    end = 'error: ' if not testforerror else 'detected: '\n    prefix = ''\n    if file:",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def error(lineno, *args):\n    error_with_file(input_file, lineno, *args)\n# end error\ndef output(*args):\n    global output_fd\n    for a in args:\n        output_fd.write(a)\ndef output_autogen():\n    output('/* This file is autogenerated by scripts/decodetree.py.  */\\n\\n')\ndef str_indent(c):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def output(*args):\n    global output_fd\n    for a in args:\n        output_fd.write(a)\ndef output_autogen():\n    output('/* This file is autogenerated by scripts/decodetree.py.  */\\n\\n')\ndef str_indent(c):\n    \"\"\"Return a string with C spaces\"\"\"\n    return ' ' * c\ndef str_fields(fields):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_autogen",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def output_autogen():\n    output('/* This file is autogenerated by scripts/decodetree.py.  */\\n\\n')\ndef str_indent(c):\n    \"\"\"Return a string with C spaces\"\"\"\n    return ' ' * c\ndef str_fields(fields):\n    \"\"\"Return a string uniquely identifying FIELDS\"\"\"\n    r = ''\n    for n in sorted(fields.keys()):\n        r += '_' + n",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "str_indent",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def str_indent(c):\n    \"\"\"Return a string with C spaces\"\"\"\n    return ' ' * c\ndef str_fields(fields):\n    \"\"\"Return a string uniquely identifying FIELDS\"\"\"\n    r = ''\n    for n in sorted(fields.keys()):\n        r += '_' + n\n    return r[1:]\ndef whex(val):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "str_fields",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def str_fields(fields):\n    \"\"\"Return a string uniquely identifying FIELDS\"\"\"\n    r = ''\n    for n in sorted(fields.keys()):\n        r += '_' + n\n    return r[1:]\ndef whex(val):\n    \"\"\"Return a hex string for val padded for insnwidth\"\"\"\n    global insnwidth\n    return f'0x{val:0{insnwidth // 4}x}'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "whex",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def whex(val):\n    \"\"\"Return a hex string for val padded for insnwidth\"\"\"\n    global insnwidth\n    return f'0x{val:0{insnwidth // 4}x}'\ndef whexC(val):\n    \"\"\"Return a hex string for val padded for insnwidth,\n       and with the proper suffix for a C constant.\"\"\"\n    suffix = ''\n    if val >= 0x100000000:\n        suffix = 'ull'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "whexC",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def whexC(val):\n    \"\"\"Return a hex string for val padded for insnwidth,\n       and with the proper suffix for a C constant.\"\"\"\n    suffix = ''\n    if val >= 0x100000000:\n        suffix = 'ull'\n    elif val >= 0x80000000:\n        suffix = 'u'\n    return whex(val) + suffix\ndef str_match_bits(bits, mask):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "str_match_bits",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def str_match_bits(bits, mask):\n    \"\"\"Return a string pretty-printing BITS/MASK\"\"\"\n    global insnwidth\n    i = 1 << (insnwidth - 1)\n    space = 0x01010100\n    r = ''\n    while i != 0:\n        if i & mask:\n            if i & bits:\n                r += '1'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "is_pow2",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def is_pow2(x):\n    \"\"\"Return true iff X is equal to a power of 2.\"\"\"\n    return (x & (x - 1)) == 0\ndef ctz(x):\n    \"\"\"Return the number of times 2 factors into X.\"\"\"\n    assert x != 0\n    r = 0\n    while ((x >> r) & 1) == 0:\n        r += 1\n    return r",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ctz",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def ctz(x):\n    \"\"\"Return the number of times 2 factors into X.\"\"\"\n    assert x != 0\n    r = 0\n    while ((x >> r) & 1) == 0:\n        r += 1\n    return r\ndef is_contiguous(bits):\n    if bits == 0:\n        return -1",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "is_contiguous",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def is_contiguous(bits):\n    if bits == 0:\n        return -1\n    shift = ctz(bits)\n    if is_pow2((bits >> shift) + 1):\n        return shift\n    else:\n        return -1\ndef eq_fields_for_args(flds_a, arg):\n    if len(flds_a) != len(arg.fields):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "eq_fields_for_args",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def eq_fields_for_args(flds_a, arg):\n    if len(flds_a) != len(arg.fields):\n        return False\n    # Only allow inference on default types\n    for t in arg.types:\n        if t != 'int':\n            return False\n    for k, a in flds_a.items():\n        if k not in arg.fields:\n            return False",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "eq_fields_for_fmts",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def eq_fields_for_fmts(flds_a, flds_b):\n    if len(flds_a) != len(flds_b):\n        return False\n    for k, a in flds_a.items():\n        if k not in flds_b:\n            return False\n        b = flds_b[k]\n        if a.__class__ != b.__class__ or a != b:\n            return False\n    return True",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_field",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def parse_field(lineno, name, toks):\n    \"\"\"Parse one instruction field from TOKS at LINENO\"\"\"\n    global fields\n    global insnwidth\n    global re_C_ident\n    # A \"simple\" field will have only one entry;\n    # a \"multifield\" will have several.\n    subs = []\n    width = 0\n    func = None",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def parse_arguments(lineno, name, toks):\n    \"\"\"Parse one argument set from TOKS at LINENO\"\"\"\n    global arguments\n    global re_C_ident\n    global anyextern\n    flds = []\n    types = []\n    extern = False\n    for n in toks:\n        if re.fullmatch('!extern', n):",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "lookup_field",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def lookup_field(lineno, name):\n    global fields\n    if name in fields:\n        return fields[name]\n    error(lineno, 'undefined field', name)\ndef add_field(lineno, flds, new_name, f):\n    if new_name in flds:\n        error(lineno, 'duplicate field', new_name)\n    flds[new_name] = f\n    return flds",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "add_field",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def add_field(lineno, flds, new_name, f):\n    if new_name in flds:\n        error(lineno, 'duplicate field', new_name)\n    flds[new_name] = f\n    return flds\ndef add_field_byname(lineno, flds, new_name, old_name):\n    return add_field(lineno, flds, new_name, lookup_field(lineno, old_name))\ndef infer_argument_set(flds):\n    global arguments\n    global decode_function",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "add_field_byname",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def add_field_byname(lineno, flds, new_name, old_name):\n    return add_field(lineno, flds, new_name, lookup_field(lineno, old_name))\ndef infer_argument_set(flds):\n    global arguments\n    global decode_function\n    for arg in arguments.values():\n        if eq_fields_for_args(flds, arg):\n            return arg\n    name = decode_function + str(len(arguments))\n    arg = Arguments(name, flds.keys(), ['int'] * len(flds), False)",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "infer_argument_set",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def infer_argument_set(flds):\n    global arguments\n    global decode_function\n    for arg in arguments.values():\n        if eq_fields_for_args(flds, arg):\n            return arg\n    name = decode_function + str(len(arguments))\n    arg = Arguments(name, flds.keys(), ['int'] * len(flds), False)\n    arguments[name] = arg\n    return arg",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "infer_format",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def infer_format(arg, fieldmask, flds, width):\n    global arguments\n    global formats\n    global decode_function\n    const_flds = {}\n    var_flds = {}\n    for n, c in flds.items():\n        if c is ConstField:\n            const_flds[n] = c\n        else:",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_generic",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def parse_generic(lineno, parent_pat, name, toks):\n    \"\"\"Parse one instruction format from TOKS at LINENO\"\"\"\n    global fields\n    global arguments\n    global formats\n    global allpatterns\n    global re_arg_ident\n    global re_fld_ident\n    global re_fmt_ident\n    global re_C_ident",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "parse_file",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def parse_file(f, parent_pat):\n    \"\"\"Parse all of the patterns within a file\"\"\"\n    global re_arg_ident\n    global re_fld_ident\n    global re_fmt_ident\n    global re_pat_ident\n    # Read all of the lines of the file.  Concatenate lines\n    # ending in backslash; discard empty lines and comments.\n    toks = []\n    lineno = 0",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "build_size_tree",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def build_size_tree(pats, width, outerbits, outermask):\n    global insnwidth\n    # Collect the mask of bits that are fixed in this width\n    innermask = 0xff << (insnwidth - width)\n    innermask &= ~outermask\n    minwidth = None\n    onewidth = True\n    for i in pats:\n        innermask &= i.fixedmask\n        if minwidth is None:",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "prop_size",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def prop_size(tree):\n    \"\"\"Propagate minimum widths up the decode size tree\"\"\"\n    if isinstance(tree, SizeTree):\n        min = None\n        for (b, s) in tree.subs:\n            width = prop_size(s)\n            if min is None or min > width:\n                min = width\n        assert min >= tree.width\n        tree.width = min",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "def main():\n    global arguments\n    global formats\n    global allpatterns\n    global translate_scope\n    global translate_prefix\n    global output_fd\n    global output_file\n    global output_null\n    global input_file",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "insnwidth",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "insnwidth = 32\nbitop_width = 32\ninsnmask = 0xffffffff\nvariablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "bitop_width",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "bitop_width = 32\ninsnmask = 0xffffffff\nvariablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "insnmask",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "insnmask = 0xffffffff\nvariablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "variablewidth",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "variablewidth = False\nfields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "fields",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "fields = {}\narguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "arguments",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "arguments = {}\nformats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "formats",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "formats = {}\nallpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "allpatterns",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "allpatterns = []\nanyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "anyextern",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "anyextern = False\ntestforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "testforerror",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "testforerror = False\ntranslate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "translate_prefix",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "translate_prefix = 'trans'\ntranslate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "translate_scope",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "translate_scope = 'static '\ninput_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "input_file",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "input_file = ''\noutput_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "output_file = None\noutput_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_fd",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "output_fd = None\noutput_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "output_null",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "output_null = False\ninsntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "insntype",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "insntype = 'uint32_t'\ndecode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "decode_function",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "decode_function = 'decode'\n# An identifier for C.\nre_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_C_ident",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "re_C_ident = '[a-zA-Z][a-zA-Z0-9_]*'\n# Identifiers for Arguments, Fields, Formats and Patterns.\nre_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_arg_ident",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "re_arg_ident = '&[a-zA-Z0-9_]*'\nre_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_fld_ident",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "re_fld_ident = '%[a-zA-Z0-9_]*'\nre_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#\n# https://docs.python.org/3.9/library/graphlib.html#graphlib.TopologicalSorter",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_fmt_ident",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "re_fmt_ident = '@[a-zA-Z0-9_]*'\nre_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#\n# https://docs.python.org/3.9/library/graphlib.html#graphlib.TopologicalSorter\n#",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "re_pat_ident",
        "kind": 5,
        "importPath": "qemu.scripts.decodetree",
        "description": "qemu.scripts.decodetree",
        "peekOfCode": "re_pat_ident = '[a-zA-Z0-9_]*'\n# Local implementation of a topological sort. We use the same API that\n# the Python graphlib does, so that when QEMU moves forward to a\n# baseline of Python 3.9 or newer this code can all be dropped and\n# replaced with:\n#    from graphlib import TopologicalSorter, CycleError\n#\n# https://docs.python.org/3.9/library/graphlib.html#graphlib.TopologicalSorter\n#\n# We only implement the parts of TopologicalSorter we care about:",
        "detail": "qemu.scripts.decodetree",
        "documentation": {}
    },
    {
        "label": "ELF",
        "kind": 6,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "class ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None\n        self.notes = []\n        self.segments = []\n        self.notes_size = 0\n        self.endianness = None\n        self.elfclass = ELFCLASS64\n        if arch == 'aarch64-le':",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "Ident",
        "kind": 6,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "class Ident(ctypes.Structure):\n    \"\"\"Represents the ELF ident array in the ehdr structure.\"\"\"\n    _fields_ = [('ei_mag0', ctypes.c_ubyte),\n                ('ei_mag1', ctypes.c_ubyte),\n                ('ei_mag2', ctypes.c_ubyte),\n                ('ei_mag3', ctypes.c_ubyte),\n                ('ei_class', ctypes.c_ubyte),\n                ('ei_data', ctypes.c_ubyte),\n                ('ei_version', ctypes.c_ubyte),\n                ('ei_osabi', ctypes.c_ubyte),",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "DumpGuestMemory",
        "kind": 6,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "class DumpGuestMemory(gdb.Command):\n    \"\"\"Extract guest vmcore from qemu process coredump.\nThe two required arguments are FILE and ARCH:\nFILE identifies the target file to write the guest vmcore to.\nARCH specifies the architecture for which the core will be generated.\nThis GDB command reimplements the dump-guest-memory QMP command in\npython, using the representation of guest memory as captured in the qemu\ncoredump. The qemu process that has been dumped must have had the\ncommand line option \"-machine dump-guest-core=on\" which is the default.\nFor simplicity, the \"paging\", \"begin\" and \"end\" parameters of the QMP",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "le16_to_cpu",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "le32_to_cpu",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None\n        self.notes = []\n        self.segments = []",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "le64_to_cpu",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):\n        self.ehdr = None\n        self.notes = []\n        self.segments = []\n        self.notes_size = 0\n        self.endianness = None",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_arch_note",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def get_arch_note(endianness, len_name, len_desc):\n    \"\"\"Returns a Note class with the specified endianness.\"\"\"\n    if endianness == ELFDATA2LSB:\n        superclass = ctypes.LittleEndianStructure\n    else:\n        superclass = ctypes.BigEndianStructure\n    len_name = len_name + 1\n    class Note(superclass):\n        \"\"\"Represents an ELF note, includes the content.\"\"\"\n        _fields_ = [(\"n_namesz\", ctypes.c_uint32),",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_arch_ehdr",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def get_arch_ehdr(endianness, elfclass):\n    \"\"\"Returns a EHDR64 class with the specified endianness.\"\"\"\n    if endianness == ELFDATA2LSB:\n        superclass = ctypes.LittleEndianStructure\n    else:\n        superclass = ctypes.BigEndianStructure\n    class EHDR64(superclass):\n        \"\"\"Represents the 64 bit ELF header struct.\"\"\"\n        _fields_ = [('e_ident', Ident),\n                    ('e_type', ctypes.c_uint16),",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_arch_phdr",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def get_arch_phdr(endianness, elfclass):\n    \"\"\"Returns a 32 or 64 bit PHDR class with the specified endianness.\"\"\"\n    if endianness == ELFDATA2LSB:\n        superclass = ctypes.LittleEndianStructure\n    else:\n        superclass = ctypes.BigEndianStructure\n    class PHDR64(superclass):\n        \"\"\"Represents the 64 bit ELF program header struct.\"\"\"\n        _fields_ = [('p_type', ctypes.c_uint32),\n                    ('p_flags', ctypes.c_uint32),",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "int128_get64",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def int128_get64(val):\n    \"\"\"Returns low 64bit part of Int128 struct.\"\"\"\n    try:\n        assert val[\"hi\"] == 0\n        return val[\"lo\"]\n    except gdb.error:\n        u64t = gdb.lookup_type('uint64_t').array(2)\n        u64 = val.cast(u64t)\n        if sys.byteorder == 'little':\n            assert u64[1] == 0",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "qlist_foreach",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def qlist_foreach(head, field_str):\n    \"\"\"Generator for qlists.\"\"\"\n    var_p = head[\"lh_first\"]\n    while var_p != 0:\n        var = var_p.dereference()\n        var_p = var[field_str][\"le_next\"]\n        yield var\ndef qemu_map_ram_ptr(block, offset):\n    \"\"\"Returns qemu vaddr for given guest physical address.\"\"\"\n    return block[\"host\"] + offset",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "qemu_map_ram_ptr",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def qemu_map_ram_ptr(block, offset):\n    \"\"\"Returns qemu vaddr for given guest physical address.\"\"\"\n    return block[\"host\"] + offset\ndef memory_region_get_ram_ptr(memory_region):\n    if memory_region[\"alias\"] != 0:\n        return (memory_region_get_ram_ptr(memory_region[\"alias\"].dereference())\n                + memory_region[\"alias_offset\"])\n    return qemu_map_ram_ptr(memory_region[\"ram_block\"], 0)\ndef get_guest_phys_blocks():\n    \"\"\"Returns a list of ram blocks.",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "memory_region_get_ram_ptr",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def memory_region_get_ram_ptr(memory_region):\n    if memory_region[\"alias\"] != 0:\n        return (memory_region_get_ram_ptr(memory_region[\"alias\"].dereference())\n                + memory_region[\"alias_offset\"])\n    return qemu_map_ram_ptr(memory_region[\"ram_block\"], 0)\ndef get_guest_phys_blocks():\n    \"\"\"Returns a list of ram blocks.\n    Each block entry contains:\n    'target_start': guest block phys start address\n    'target_end':   guest block phys end address",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "get_guest_phys_blocks",
        "kind": 2,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "def get_guest_phys_blocks():\n    \"\"\"Returns a list of ram blocks.\n    Each block entry contains:\n    'target_start': guest block phys start address\n    'target_end':   guest block phys end address\n    'host_addr':    qemu vaddr of the block's start\n    \"\"\"\n    guest_phys_blocks = []\n    print(\"guest RAM blocks:\")\n    print(\"target_start     target_end       host_addr        message \"",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "TARGET_PAGE_SIZE",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "TARGET_PAGE_SIZE = 0x1000\nTARGET_PAGE_MASK = 0xFFFFFFFFFFFFF000\n# Special value for e_phnum. This indicates that the real number of\n# program headers is too large to fit into e_phnum. Instead the real\n# value is in the field sh_info of section 0.\nPN_XNUM = 0xFFFF\nEV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "TARGET_PAGE_MASK",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "TARGET_PAGE_MASK = 0xFFFFFFFFFFFFF000\n# Special value for e_phnum. This indicates that the real number of\n# program headers is too large to fit into e_phnum. Instead the real\n# value is in the field sh_info of section 0.\nPN_XNUM = 0xFFFF\nEV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "PN_XNUM",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "PN_XNUM = 0xFFFF\nEV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EV_CURRENT",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "EV_CURRENT = 1\nELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFCLASS32",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "ELFCLASS32 = 1\nELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFCLASS64",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "ELFCLASS64 = 2\nELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFDATA2LSB",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "ELFDATA2LSB = 1\nELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ELFDATA2MSB",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "ELFDATA2MSB = 2\nET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "ET_CORE",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "ET_CORE = 4\nPT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "PT_LOAD",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "PT_LOAD = 1\nPT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "PT_NOTE",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "PT_NOTE = 4\nEM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_386",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "EM_386 = 3\nEM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_PPC",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "EM_PPC = 20\nEM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_PPC64",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "EM_PPC64 = 21\nEM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_S390",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "EM_S390 = 22\nEM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_AARCH",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "EM_AARCH = 183\nEM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "EM_X86_64",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "EM_X86_64 = 62\nVMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "VMCOREINFO_FORMAT_ELF",
        "kind": 5,
        "importPath": "qemu.scripts.dump-guest-memory",
        "description": "qemu.scripts.dump-guest-memory",
        "peekOfCode": "VMCOREINFO_FORMAT_ELF = 1\ndef le16_to_cpu(val):\n    return struct.unpack(\"<H\", struct.pack(\"=H\", val))[0]\ndef le32_to_cpu(val):\n    return struct.unpack(\"<I\", struct.pack(\"=I\", val))[0]\ndef le64_to_cpu(val):\n    return struct.unpack(\"<Q\", struct.pack(\"=Q\", val))[0]\nclass ELF(object):\n    \"\"\"Representation of a ELF file.\"\"\"\n    def __init__(self, arch):",
        "detail": "qemu.scripts.dump-guest-memory",
        "documentation": {}
    },
    {
        "label": "writeliteral",
        "kind": 2,
        "importPath": "qemu.scripts.feature_to_c",
        "description": "qemu.scripts.feature_to_c",
        "peekOfCode": "def writeliteral(indent, bytes):\n    sys.stdout.write(' ' * indent)\n    sys.stdout.write('\"')\n    quoted = True\n    for c in bytes:\n        if not quoted:\n            sys.stdout.write('\\n')\n            sys.stdout.write(' ' * indent)\n            sys.stdout.write('\"')\n            quoted = True",
        "detail": "qemu.scripts.feature_to_c",
        "documentation": {}
    },
    {
        "label": "get_help",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def get_help(opt):\n    if opt[\"name\"] == \"libdir\":\n        return 'system default'\n    value = opt[\"value\"]\n    if isinstance(value, list):\n        return \",\".join(value)\n    if isinstance(value, bool):\n        return \"enabled\" if value else \"disabled\"\n    return str(value)\ndef wrap(left, text, indent):",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "wrap",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def wrap(left, text, indent):\n    spaces = \" \" * indent\n    if len(left) >= indent:\n        yield left\n        left = spaces\n    else:\n        left = (left + spaces)[0:indent]\n    yield from textwrap.wrap(\n        text, width=LINE_WIDTH, initial_indent=left, subsequent_indent=spaces\n    )",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "sh_print",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def sh_print(line=\"\"):\n    print('  printf \"%s\\\\n\"', shlex.quote(line))\ndef help_line(left, opt, indent, long):\n    right = f'{opt[\"description\"]}'\n    if long:\n        value = get_help(opt)\n        if value != \"auto\" and value != \"\":\n            right += f\" [{value}]\"\n    if \"choices\" in opt and long:\n        choices = \"/\".join(sorted(opt[\"choices\"]))",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "help_line",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def help_line(left, opt, indent, long):\n    right = f'{opt[\"description\"]}'\n    if long:\n        value = get_help(opt)\n        if value != \"auto\" and value != \"\":\n            right += f\" [{value}]\"\n    if \"choices\" in opt and long:\n        choices = \"/\".join(sorted(opt[\"choices\"]))\n        right += f\" (choices: {choices})\"\n    for x in wrap(\"  \" + left, right, indent):",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "allow_arg",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def allow_arg(opt):\n    if opt[\"type\"] == \"boolean\":\n        return False\n    if opt[\"type\"] != \"combo\":\n        return True\n    return not (set(opt[\"choices\"]) <= {\"auto\", \"disabled\", \"enabled\"})\n# Return whether the option (a dictionary) can be used without\n# arguments.  Booleans can only be used without arguments;\n# combos require an argument if they accept neither \"enabled\"\n# nor \"disabled\"",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "require_arg",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def require_arg(opt):\n    if opt[\"type\"] == \"boolean\":\n        return False\n    if opt[\"type\"] != \"combo\":\n        return True\n    return not ({\"enabled\", \"disabled\"}.intersection(opt[\"choices\"]))\ndef filter_options(json):\n    if \":\" in json[\"name\"]:\n        return False\n    if json[\"section\"] == \"user\":",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "filter_options",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def filter_options(json):\n    if \":\" in json[\"name\"]:\n        return False\n    if json[\"section\"] == \"user\":\n        return json[\"name\"] not in SKIP_OPTIONS\n    else:\n        return json[\"name\"] in BUILTIN_OPTIONS\ndef load_options(json):\n    json = [x for x in json if filter_options(x)]\n    return sorted(json, key=lambda x: x[\"name\"])",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "load_options",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def load_options(json):\n    json = [x for x in json if filter_options(x)]\n    return sorted(json, key=lambda x: x[\"name\"])\ndef cli_option(opt):\n    name = opt[\"name\"]\n    if name in OPTION_NAMES:\n        return OPTION_NAMES[name]\n    return name.replace(\"_\", \"-\")\ndef cli_help_key(opt):\n    key = cli_option(opt)",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "cli_option",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def cli_option(opt):\n    name = opt[\"name\"]\n    if name in OPTION_NAMES:\n        return OPTION_NAMES[name]\n    return name.replace(\"_\", \"-\")\ndef cli_help_key(opt):\n    key = cli_option(opt)\n    if require_arg(opt):\n        return key\n    if opt[\"type\"] == \"boolean\" and opt[\"value\"]:",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "cli_help_key",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def cli_help_key(opt):\n    key = cli_option(opt)\n    if require_arg(opt):\n        return key\n    if opt[\"type\"] == \"boolean\" and opt[\"value\"]:\n        return f\"disable-{key}\"\n    return f\"enable-{key}\"\ndef cli_metavar(opt):\n    if opt[\"type\"] == \"string\":\n        return \"VALUE\"",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "cli_metavar",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def cli_metavar(opt):\n    if opt[\"type\"] == \"string\":\n        return \"VALUE\"\n    if opt[\"type\"] == \"array\":\n        return \"CHOICES\" if \"choices\" in opt else \"VALUES\"\n    return \"CHOICE\"\ndef print_help(options):\n    print(\"meson_options_help() {\")\n    feature_opts = []\n    for opt in sorted(options, key=cli_help_key):",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "print_help",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def print_help(options):\n    print(\"meson_options_help() {\")\n    feature_opts = []\n    for opt in sorted(options, key=cli_help_key):\n        key = cli_help_key(opt)\n        # The first section includes options that have an arguments,\n        # and booleans (i.e., only one of enable/disable makes sense)\n        if require_arg(opt):\n            metavar = cli_metavar(opt)\n            left = f\"--{key}={metavar}\"",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "print_parse",
        "kind": 2,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "def print_parse(options):\n    print(\"_meson_option_parse() {\")\n    print(\"  case $1 in\")\n    for opt in options:\n        key = cli_option(opt)\n        name = opt[\"name\"]\n        if require_arg(opt):\n            if opt[\"type\"] == \"array\" and not \"choices\" in opt:\n                print(f'    --{key}=*) quote_sh \"-D{name}=$(meson_option_build_array $2)\" ;;')\n            else:",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "SKIP_OPTIONS",
        "kind": 5,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "SKIP_OPTIONS = {\n    \"default_devices\",\n    \"fuzzing_engine\",\n}\n# Options whose name doesn't match the option for backwards compatibility\n# reasons, because Meson gives them a funny name, or both\nOPTION_NAMES = {\n    \"b_coverage\": \"gcov\",\n    \"b_lto\": \"lto\",\n    \"coroutine_backend\": \"with-coroutine\",",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "OPTION_NAMES",
        "kind": 5,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "OPTION_NAMES = {\n    \"b_coverage\": \"gcov\",\n    \"b_lto\": \"lto\",\n    \"coroutine_backend\": \"with-coroutine\",\n    \"debug\": \"debug-info\",\n    \"malloc\": \"enable-malloc\",\n    \"pkgversion\": \"with-pkgversion\",\n    \"qemu_firmwarepath\": \"firmwarepath\",\n    \"qemu_suffix\": \"with-suffix\",\n    \"trace_backends\": \"enable-trace-backends\",",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "AUTO_OPTIONS",
        "kind": 5,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "AUTO_OPTIONS = {\n    \"plugins\",\n    \"werror\",\n}\n# Builtin options that should be definable via configure.  Some of the others\n# we really do not want (e.g. c_args is defined via the native file, not\n# via -D, because it's a mix of CFLAGS and --extra-cflags); for specific\n# cases \"../configure -D\" can be used as an escape hatch.\nBUILTIN_OPTIONS = {\n    \"b_coverage\",",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "BUILTIN_OPTIONS",
        "kind": 5,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "BUILTIN_OPTIONS = {\n    \"b_coverage\",\n    \"b_lto\",\n    \"bindir\",\n    \"datadir\",\n    \"debug\",\n    \"includedir\",\n    \"libdir\",\n    \"libexecdir\",\n    \"localedir\",",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "LINE_WIDTH",
        "kind": 5,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "LINE_WIDTH = 76\n# Convert the default value of an option to the string used in\n# the help message\ndef get_help(opt):\n    if opt[\"name\"] == \"libdir\":\n        return 'system default'\n    value = opt[\"value\"]\n    if isinstance(value, list):\n        return \",\".join(value)\n    if isinstance(value, bool):",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "json_data",
        "kind": 5,
        "importPath": "qemu.scripts.meson-buildoptions",
        "description": "qemu.scripts.meson-buildoptions",
        "peekOfCode": "json_data = sys.stdin.read()\ntry:\n    options = load_options(json.loads(json_data))\nexcept:\n    print(\"Failure in scripts/meson-buildoptions.py parsing stdin as json\",\n          file=sys.stderr)\n    print(json_data, file=sys.stderr)\n    sys.exit(1)\nprint(\"# This file is generated by meson-buildoptions.py, do not edit!\")\nprint_help(options)",
        "detail": "qemu.scripts.meson-buildoptions",
        "documentation": {}
    },
    {
        "label": "KconfigDataError",
        "kind": 6,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "class KconfigDataError(Exception):\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return self.msg\nallyesconfig = lambda x: True\nallnoconfig = lambda x: False\ndefconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "KconfigData",
        "kind": 6,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "class KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):\n            return KconfigData.NOT(self)\n        # Abstract methods\n        def add_edges_to(self, var):",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "KconfigParserError",
        "kind": 6,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "class KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)\n        self.msg = msg\n    def __str__(self):\n        return \"%s: %s\" % (self.loc, self.msg)",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "KconfigParser",
        "kind": 6,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "class KconfigParser:\n    @classmethod\n    def parse(self, fp, mode=None):\n        data = KconfigData(mode or KconfigParser.defconfig)\n        parser = KconfigParser(data)\n        parser.parse_file(fp)\n        return data\n    def __init__(self, data):\n        self.data = data\n    def parse_file(self, fp):",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "debug_print",
        "kind": 2,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "def debug_print(*args):\n    #print('# ' + (' '.join(str(x) for x in args)))\n    pass\n# -------------------------------------------\n# KconfigData implements the Kconfig semantics.  For now it can only\n# detect undefined symbols, i.e. symbols that were referenced in\n# assignments or dependencies but were not declared with \"config FOO\".\n#\n# Semantic actions are represented by methods called do_*.  The do_var\n# method return the semantic value of a variable (which right now is",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "__all__ = [ 'KconfigDataError', 'KconfigParserError',\n            'KconfigData', 'KconfigParser' ,\n            'defconfig', 'allyesconfig', 'allnoconfig', 'randconfig' ]\ndef debug_print(*args):\n    #print('# ' + (' '.join(str(x) for x in args)))\n    pass\n# -------------------------------------------\n# KconfigData implements the Kconfig semantics.  For now it can only\n# detect undefined symbols, i.e. symbols that were referenced in\n# assignments or dependencies but were not declared with \"config FOO\".",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "allyesconfig",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "allyesconfig = lambda x: True\nallnoconfig = lambda x: False\ndefconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "allnoconfig",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "allnoconfig = lambda x: False\ndefconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "defconfig",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "defconfig = lambda x: x\nrandconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):\n            return KconfigData.NOT(self)",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "randconfig",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "randconfig = lambda x: random.randint(0, 1) == 1\nclass KconfigData:\n    class Expr:\n        def __and__(self, rhs):\n            return KconfigData.AND(self, rhs)\n        def __or__(self, rhs):\n            return KconfigData.OR(self, rhs)\n        def __invert__(self):\n            return KconfigData.NOT(self)\n        # Abstract methods",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOKENS",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOKENS = {}\nTOK_NONE = -1\nTOK_LPAREN = 0;   TOKENS[TOK_LPAREN] = '\"(\"';\nTOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_NONE",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_NONE = -1\nTOK_LPAREN = 0;   TOKENS[TOK_LPAREN] = '\"(\"';\nTOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_LPAREN",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_LPAREN = 0;   TOKENS[TOK_LPAREN] = '\"(\"';\nTOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_RPAREN",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_RPAREN = 1;   TOKENS[TOK_RPAREN] = '\")\"';\nTOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_EQUAL",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_EQUAL = 2;    TOKENS[TOK_EQUAL] = '\"=\"';\nTOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_AND",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_AND = 3;      TOKENS[TOK_AND] = '\"&&\"';\nTOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_OR",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_OR = 4;       TOKENS[TOK_OR] = '\"||\"';\nTOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_NOT",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_NOT = 5;      TOKENS[TOK_NOT] = '\"!\"';\nTOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_DEPENDS",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_DEPENDS = 6;  TOKENS[TOK_DEPENDS] = '\"depends\"';\nTOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_ON",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_ON = 7;       TOKENS[TOK_ON] = '\"on\"';\nTOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_SELECT",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_SELECT = 8;   TOKENS[TOK_SELECT] = '\"select\"';\nTOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_IMPLY",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_IMPLY = 9;    TOKENS[TOK_IMPLY] = '\"imply\"';\nTOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_CONFIG",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_CONFIG = 10;  TOKENS[TOK_CONFIG] = '\"config\"';\nTOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_DEFAULT",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_DEFAULT = 11; TOKENS[TOK_DEFAULT] = '\"default\"';\nTOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_Y",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_Y = 12;       TOKENS[TOK_Y] = '\"y\"';\nTOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_N",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_N = 13;       TOKENS[TOK_N] = '\"n\"';\nTOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_SOURCE",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_SOURCE = 14;  TOKENS[TOK_SOURCE] = '\"source\"';\nTOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_BOOL",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_BOOL = 15;    TOKENS[TOK_BOOL] = '\"bool\"';\nTOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_IF",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_IF = 16;      TOKENS[TOK_IF] = '\"if\"';\nTOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_ID",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_ID = 17;      TOKENS[TOK_ID] = 'identifier';\nTOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)\n        self.msg = msg",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "TOK_EOF",
        "kind": 5,
        "importPath": "qemu.scripts.minikconf",
        "description": "qemu.scripts.minikconf",
        "peekOfCode": "TOK_EOF = 18;     TOKENS[TOK_EOF] = 'end of file';\nclass KconfigParserError(Exception):\n    def __init__(self, parser, msg, tok=None):\n        self.loc = parser.location()\n        tok = tok or parser.tok\n        if tok != TOK_NONE:\n            location = TOKENS.get(tok, None) or ('\"%s\"' % tok)\n            msg = '%s before %s' % (msg, location)\n        self.msg = msg\n    def __str__(self):",
        "detail": "qemu.scripts.minikconf",
        "documentation": {}
    },
    {
        "label": "find_command",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-collect",
        "description": "qemu.scripts.modinfo-collect",
        "peekOfCode": "def find_command(src, target, compile_commands):\n    for command in compile_commands:\n        if command['file'] != src:\n            continue\n        if target != '' and command['command'].find(target) == -1:\n            continue\n        return command['command']\n    return 'false'\ndef process_command(src, command):\n    skip = False",
        "detail": "qemu.scripts.modinfo-collect",
        "documentation": {}
    },
    {
        "label": "process_command",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-collect",
        "description": "qemu.scripts.modinfo-collect",
        "peekOfCode": "def process_command(src, command):\n    skip = False\n    out = []\n    for item in shlex.split(command):\n        if skip:\n            skip = False\n            continue\n        if item == '-MF' or item == '-MQ' or item == '-o':\n            skip = True\n            continue",
        "detail": "qemu.scripts.modinfo-collect",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-collect",
        "description": "qemu.scripts.modinfo-collect",
        "peekOfCode": "def main(args):\n    target = ''\n    if args[0] == '--target':\n        args.pop(0)\n        target = args.pop(0)\n        print(\"MODINFO_DEBUG target %s\" % target)\n        arch = target[:-8] # cut '-softmmu'\n        print(\"MODINFO_START arch \\\"%s\\\" MODINFO_END\" % arch)\n    with open('compile_commands.json') as f:\n        compile_commands = json.load(f)",
        "detail": "qemu.scripts.modinfo-collect",
        "documentation": {}
    },
    {
        "label": "print_array",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-generate",
        "description": "qemu.scripts.modinfo-generate",
        "peekOfCode": "def print_array(name, values):\n    if len(values) == 0:\n        return\n    list = \", \".join(values)\n    print(\"    .%s = ((const char*[]){ %s, NULL }),\" % (name, list))\ndef parse_line(line):\n    kind = \"\"\n    data = \"\"\n    get_kind = False\n    get_data = False",
        "detail": "qemu.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "parse_line",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-generate",
        "description": "qemu.scripts.modinfo-generate",
        "peekOfCode": "def parse_line(line):\n    kind = \"\"\n    data = \"\"\n    get_kind = False\n    get_data = False\n    for item in line.split():\n        if item == \"MODINFO_START\":\n            get_kind = True\n            continue\n        if item.startswith(\"MODINFO_END\"):",
        "detail": "qemu.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-generate",
        "description": "qemu.scripts.modinfo-generate",
        "peekOfCode": "def generate(name, lines, enabled):\n    arch = \"\"\n    objs = []\n    deps = []\n    opts = []\n    for line in lines:\n        if line.find(\"MODINFO_START\") != -1:\n            (kind, data) = parse_line(line)\n            if kind == 'obj':\n                objs.append(data)",
        "detail": "qemu.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "print_pre",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-generate",
        "description": "qemu.scripts.modinfo-generate",
        "peekOfCode": "def print_pre():\n    print(\"/* generated by scripts/modinfo-generate.py */\")\n    print(\"#include \\\"qemu/osdep.h\\\"\")\n    print(\"#include \\\"qemu/module.h\\\"\")\n    print(\"const QemuModinfo qemu_modinfo[] = {{\")\ndef print_post():\n    print(\"    /* end of list */\")\n    print(\"}};\")\ndef main(args):\n    if len(args) < 3 or args[0] != '--devices':",
        "detail": "qemu.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "print_post",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-generate",
        "description": "qemu.scripts.modinfo-generate",
        "peekOfCode": "def print_post():\n    print(\"    /* end of list */\")\n    print(\"}};\")\ndef main(args):\n    if len(args) < 3 or args[0] != '--devices':\n        print('Expected: modinfo-generate.py --devices '\n              'config-device.mak [modinfo files]', file=sys.stderr)\n        exit(1)\n    # get all devices enabled in kconfig, from *-config-device.mak\n    enabled = set()",
        "detail": "qemu.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.modinfo-generate",
        "description": "qemu.scripts.modinfo-generate",
        "peekOfCode": "def main(args):\n    if len(args) < 3 or args[0] != '--devices':\n        print('Expected: modinfo-generate.py --devices '\n              'config-device.mak [modinfo files]', file=sys.stderr)\n        exit(1)\n    # get all devices enabled in kconfig, from *-config-device.mak\n    enabled = set()\n    with open(args[1]) as file:\n        for line in file.readlines():\n            config = line.split('=')",
        "detail": "qemu.scripts.modinfo-generate",
        "documentation": {}
    },
    {
        "label": "Suite",
        "kind": 6,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "class Suite(object):\n    def __init__(self):\n        self.deps = set()\n        self.speeds = ['quick']\n    def names(self, base):\n        return [base if speed == 'quick' else f'{base}-{speed}' for speed in self.speeds]\nprint('''\nSPEED = quick\n.speed.quick = $(foreach s,$(sort $(filter-out %-slow %-thorough, $1)), --suite $s)\n.speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "process_tests",
        "kind": 2,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "def process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])\n    deps = itertools.chain.from_iterable(deps)\n    deps = list(deps)\n    test_suites = test['suite'] or ['default']",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "emit_prolog",
        "kind": 2,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "def emit_prolog(suites, prefix):\n    all_targets = ' '.join((f'{prefix}-{k}' for k in suites.keys()))\n    all_xml = ' '.join((f'{prefix}-report-{k}.junit.xml' for k in suites.keys()))\n    print()\n    print(f'all-{prefix}-targets = {all_targets}')\n    print(f'all-{prefix}-xml = {all_xml}')\n    print(f'.PHONY: {prefix} do-meson-{prefix} {prefix}-report.junit.xml $(all-{prefix}-targets) $(all-{prefix}-xml)')\n    print(f'ifeq ($(filter {prefix}, $(MAKECMDGOALS)),)')\n    print(f'.{prefix}.mtestargs += $(call .speed.$(SPEED), $(.{prefix}.mtest-suites))')\n    print(f'endif')",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "emit_suite_deps",
        "kind": 2,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "def emit_suite_deps(name, suite, prefix):\n    deps = ' '.join(suite.deps)\n    targets = [f'{prefix}-{name}', f'{prefix}-report-{name}.junit.xml', f'{prefix}', f'{prefix}-report.junit.xml',\n               f'{prefix}-build']\n    print()\n    print(f'.{prefix}-{name}.deps = {deps}')\n    for t in targets:\n        print(f'.ninja-goals.{t} += $(.{prefix}-{name}.deps)')\ndef emit_suite(name, suite, prefix):\n    emit_suite_deps(name, suite, prefix)",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "emit_suite",
        "kind": 2,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "def emit_suite(name, suite, prefix):\n    emit_suite_deps(name, suite, prefix)\n    targets = f'{prefix}-{name} {prefix}-report-{name}.junit.xml {prefix} {prefix}-report.junit.xml'\n    print(f'ifneq ($(filter {targets}, $(MAKECMDGOALS)),)')\n    print(f'.{prefix}.mtest-suites += ' + ' '.join(suite.names(name)))\n    print(f'endif')\ntargets = {t['id']: [os.path.relpath(f) for f in t['filename']]\n           for t in introspect['targets']}\ntestsuites = defaultdict(Suite)\nfor test in introspect['tests']:",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "SPEED",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "SPEED = quick\n.speed.quick = $(foreach s,$(sort $(filter-out %-slow %-thorough, $1)), --suite $s)\n.speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)\n.speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".speed.quick",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": ".speed.quick = $(foreach s,$(sort $(filter-out %-slow %-thorough, $1)), --suite $s)\n.speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)\n.speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".speed.slow",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": ".speed.slow = $(foreach s,$(sort $(filter-out %-thorough, $1)), --suite $s)\n.speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".speed.thorough",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": ".speed.thorough = $(foreach s,$(sort $1), --suite $s)\nTIMEOUT_MULTIPLIER ?= 1\n.mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".mtestargs",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": ".mtestargs = --no-rebuild -t $(TIMEOUT_MULTIPLIER)\nifneq ($(SPEED), quick)\n.mtestargs += --setup $(SPEED)\nendif\n.mtestargs += $(subst -j,--num-processes , $(filter-out -j, $(lastword -j1 $(filter -j%, $(MAKEFLAGS)))))\n.check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".check.mtestargs",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": ".check.mtestargs = $(MTESTARGS) $(.mtestargs) $(if $(V),--verbose,--print-errorlogs)\n.bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": ".bench.mtestargs",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": ".bench.mtestargs = $(MTESTARGS) $(.mtestargs) --benchmark --verbose''')\nintrospect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])\n    deps = itertools.chain.from_iterable(deps)",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "introspect",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "introspect = json.load(sys.stdin)\ndef process_tests(test, targets, suites):\n    executable = test['cmd'][0]\n    try:\n        executable = os.path.relpath(executable)\n    except:\n        pass\n    deps = (targets.get(x, []) for x in test['depends'])\n    deps = itertools.chain.from_iterable(deps)\n    deps = list(deps)",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "targets",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "targets = {t['id']: [os.path.relpath(f) for f in t['filename']]\n           for t in introspect['targets']}\ntestsuites = defaultdict(Suite)\nfor test in introspect['tests']:\n    process_tests(test, targets, testsuites)\nemit_prolog(testsuites, 'check')\nfor name, suite in testsuites.items():\n    emit_suite(name, suite, 'check')\nbenchsuites = defaultdict(Suite)\nfor test in introspect['benchmarks']:",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "testsuites",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "testsuites = defaultdict(Suite)\nfor test in introspect['tests']:\n    process_tests(test, targets, testsuites)\nemit_prolog(testsuites, 'check')\nfor name, suite in testsuites.items():\n    emit_suite(name, suite, 'check')\nbenchsuites = defaultdict(Suite)\nfor test in introspect['benchmarks']:\n    process_tests(test, targets, benchsuites)\nemit_prolog(benchsuites, 'bench')",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "benchsuites",
        "kind": 5,
        "importPath": "qemu.scripts.mtest2make",
        "description": "qemu.scripts.mtest2make",
        "peekOfCode": "benchsuites = defaultdict(Suite)\nfor test in introspect['benchmarks']:\n    process_tests(test, targets, benchsuites)\nemit_prolog(benchsuites, 'bench')\nfor name, suite in benchsuites.items():\n    emit_suite(name, suite, 'bench')",
        "detail": "qemu.scripts.mtest2make",
        "documentation": {}
    },
    {
        "label": "signcode",
        "kind": 2,
        "importPath": "qemu.scripts.nsis",
        "description": "qemu.scripts.nsis",
        "peekOfCode": "def signcode(path):\n    cmd = os.environ.get(\"SIGNCODE\")\n    if not cmd:\n        return\n    subprocess.run([cmd, path])\ndef find_deps(exe_or_dll, search_path, analyzed_deps):\n    deps = [exe_or_dll]\n    output = subprocess.check_output([\"objdump\", \"-p\", exe_or_dll], text=True)\n    output = output.split(\"\\n\")\n    for line in output:",
        "detail": "qemu.scripts.nsis",
        "documentation": {}
    },
    {
        "label": "find_deps",
        "kind": 2,
        "importPath": "qemu.scripts.nsis",
        "description": "qemu.scripts.nsis",
        "peekOfCode": "def find_deps(exe_or_dll, search_path, analyzed_deps):\n    deps = [exe_or_dll]\n    output = subprocess.check_output([\"objdump\", \"-p\", exe_or_dll], text=True)\n    output = output.split(\"\\n\")\n    for line in output:\n        if not line.lstrip().startswith(\"DLL Name: \"):\n            continue\n        dep = line.split(\"DLL Name: \")[1].strip()\n        if dep in analyzed_deps:\n            continue",
        "detail": "qemu.scripts.nsis",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.nsis",
        "description": "qemu.scripts.nsis",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"QEMU NSIS build helper.\")\n    parser.add_argument(\"outfile\")\n    parser.add_argument(\"prefix\")\n    parser.add_argument(\"srcdir\")\n    parser.add_argument(\"dlldir\")\n    parser.add_argument(\"cpu\")\n    parser.add_argument(\"nsisargs\", nargs=\"*\")\n    args = parser.parse_args()\n    # canonicalize the Windows native prefix path",
        "detail": "qemu.scripts.nsis",
        "documentation": {}
    },
    {
        "label": "do_probe",
        "kind": 2,
        "importPath": "qemu.scripts.probe-gdb-support",
        "description": "qemu.scripts.probe-gdb-support",
        "peekOfCode": "def do_probe(gdb):\n    try:\n        gdb_out = check_output([gdb,\n                               \"-ex\", \"set architecture\",\n                               \"-ex\", \"quit\"], stderr=STDOUT, encoding=\"utf-8\")\n    except (OSError) as e:\n        sys.exit(e)\n    except CalledProcessError as e:\n        sys.exit(f'{e}. Output:\\n\\n{e.output}')\n    found_gdb_archs = re.search(r'Valid arguments are (.*)', gdb_out)",
        "detail": "qemu.scripts.probe-gdb-support",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.probe-gdb-support",
        "description": "qemu.scripts.probe-gdb-support",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description='Probe GDB Architectures')\n    parser.add_argument('gdb', help='Path to GDB binary.')\n    args = parser.parse_args()\n    supported = do_probe(args.gdb)\n    print(\" \".join(supported))\nif __name__ == '__main__':\n    main()",
        "detail": "qemu.scripts.probe-gdb-support",
        "documentation": {}
    },
    {
        "label": "MAP",
        "kind": 5,
        "importPath": "qemu.scripts.probe-gdb-support",
        "description": "qemu.scripts.probe-gdb-support",
        "peekOfCode": "MAP = {\n    \"alpha\" : [\"alpha\"],\n    \"aarch64\" : [\"aarch64\", \"aarch64_be\"],\n    \"armv7\": [\"arm\"],\n    \"armv8-a\" : [\"aarch64\", \"aarch64_be\"],\n    \"avr\" : [\"avr\"],\n    # no hexagon in upstream gdb\n    \"hppa1.0\" : [\"hppa\"],\n    \"i386\" : [\"i386\"],\n    \"i386:x86-64\" : [\"x86_64\"],",
        "detail": "qemu.scripts.probe-gdb-support",
        "documentation": {}
    },
    {
        "label": "tmatch",
        "kind": 2,
        "importPath": "qemu.scripts.python_qmp_updater",
        "description": "qemu.scripts.python_qmp_updater",
        "peekOfCode": "def tmatch(template: str, text: str,\n           padding: str, res: str) -> Optional[re.Match[str]]:\n    return re.match(template.format(padding=padding, res=res), text,\n                    flags=re.MULTILINE)\ndef find_closing_brace(text: str, start: int) -> int:\n    \"\"\"\n    Having '(' at text[start] search for pairing ')' and return its index.\n    \"\"\"\n    assert text[start] == '('\n    height = 1",
        "detail": "qemu.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "find_closing_brace",
        "kind": 2,
        "importPath": "qemu.scripts.python_qmp_updater",
        "description": "qemu.scripts.python_qmp_updater",
        "peekOfCode": "def find_closing_brace(text: str, start: int) -> int:\n    \"\"\"\n    Having '(' at text[start] search for pairing ')' and return its index.\n    \"\"\"\n    assert text[start] == '('\n    height = 1\n    for i in range(start + 1, len(text)):\n        if text[i] == '(':\n            height += 1\n        elif text[i] == ')':",
        "detail": "qemu.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "update",
        "kind": 2,
        "importPath": "qemu.scripts.python_qmp_updater",
        "description": "qemu.scripts.python_qmp_updater",
        "peekOfCode": "def update(text: str) -> str:\n    result = ''\n    while True:\n        m = start_reg.search(text)\n        if m is None:\n            result += text\n            break\n        result += text[:m.start()]\n        args_ind = m.end()\n        args_end = find_closing_brace(text, args_ind - 1)",
        "detail": "qemu.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "start_reg",
        "kind": 5,
        "importPath": "qemu.scripts.python_qmp_updater",
        "description": "qemu.scripts.python_qmp_updater",
        "peekOfCode": "start_reg = re.compile(r'^(?P<padding> *)(?P<res>\\w+) = (?P<vm>.*).qmp\\(',\n                       flags=re.MULTILINE)\nsuccess_reg_templ = re.sub('\\n *', '', r\"\"\"\n    (\\n*{padding}(?P<comment>\\#.*$))?\n    \\n*{padding}\n    (\n        self.assert_qmp\\({res},\\ 'return',\\ {{}}\\)\n    |\n        assert\\ {res}\\['return'\\]\\ ==\\ {{}}\n    |",
        "detail": "qemu.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "success_reg_templ",
        "kind": 5,
        "importPath": "qemu.scripts.python_qmp_updater",
        "description": "qemu.scripts.python_qmp_updater",
        "peekOfCode": "success_reg_templ = re.sub('\\n *', '', r\"\"\"\n    (\\n*{padding}(?P<comment>\\#.*$))?\n    \\n*{padding}\n    (\n        self.assert_qmp\\({res},\\ 'return',\\ {{}}\\)\n    |\n        assert\\ {res}\\['return'\\]\\ ==\\ {{}}\n    |\n        assert\\ {res}\\ ==\\ {{'return':\\ {{}}}}\n    |",
        "detail": "qemu.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "some_check_templ",
        "kind": 5,
        "importPath": "qemu.scripts.python_qmp_updater",
        "description": "qemu.scripts.python_qmp_updater",
        "peekOfCode": "some_check_templ = re.sub('\\n *', '', r\"\"\"\n    (\\n*{padding}(?P<comment>\\#.*$))?\n    \\s*self.assert_qmp\\({res},\"\"\")\ndef tmatch(template: str, text: str,\n           padding: str, res: str) -> Optional[re.Match[str]]:\n    return re.match(template.format(padding=padding, res=res), text,\n                    flags=re.MULTILINE)\ndef find_closing_brace(text: str, start: int) -> int:\n    \"\"\"\n    Having '(' at text[start] search for pairing ')' and return its index.",
        "detail": "qemu.scripts.python_qmp_updater",
        "documentation": {}
    },
    {
        "label": "bitmap_set",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):\n    return d * math.ceil(num / d)",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "bitmap_is_set",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):\n    return d * math.ceil(num / d)\n# Holes in the input file contain only zeroes so we can skip them and\n# save time. This function returns the indexes of the clusters that",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "bitmap_iterator",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):\n    return d * math.ceil(num / d)\n# Holes in the input file contain only zeroes so we can skip them and\n# save time. This function returns the indexes of the clusters that\n# are known to contain data. Those are the ones that we need to read.\ndef clusters_with_data(fd, cluster_size):",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "align_up",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def align_up(num, d):\n    return d * math.ceil(num / d)\n# Holes in the input file contain only zeroes so we can skip them and\n# save time. This function returns the indexes of the clusters that\n# are known to contain data. Those are the ones that we need to read.\ndef clusters_with_data(fd, cluster_size):\n    data_to = 0\n    while True:\n        try:\n            data_from = os.lseek(fd, data_to, os.SEEK_DATA)",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "clusters_with_data",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def clusters_with_data(fd, cluster_size):\n    data_to = 0\n    while True:\n        try:\n            data_from = os.lseek(fd, data_to, os.SEEK_DATA)\n            data_to = align_up(os.lseek(fd, data_from, os.SEEK_HOLE), cluster_size)\n            for idx in range(data_from // cluster_size, data_to // cluster_size):\n                yield idx\n        except OSError as err:\n            if err.errno == errno.ENXIO:  # End of file reached",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "get_input_as_raw_file",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def get_input_as_raw_file(input_file, input_format):\n    if input_format == \"raw\":\n        yield input_file\n        return\n    try:\n        temp_dir = tempfile.mkdtemp()\n        pid_file = os.path.join(temp_dir, \"pid\")\n        raw_file = os.path.join(temp_dir, \"raw\")\n        open(raw_file, \"wb\").close()\n        ret = subprocess.run(",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "write_features",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def write_features(cluster, offset, data_file_name):\n    if data_file_name is not None:\n        encoded_name = data_file_name.encode(\"utf-8\")\n        padded_name_len = align_up(len(encoded_name), 8)\n        struct.pack_into(f\">II{padded_name_len}s\", cluster, offset,\n                         QCOW2_DATA_FILE_NAME_STRING,\n                         len(encoded_name),\n                         encoded_name)\n        offset += 8 + padded_name_len\n    qcow2_features = [",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "write_qcow2_content",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def write_qcow2_content(input_file, cluster_size, refcount_bits, data_file_name, data_file_raw):\n    # Some basic values\n    l1_entries_per_table = cluster_size // 8\n    l2_entries_per_table = cluster_size // 8\n    refcounts_per_table  = cluster_size // 8\n    refcounts_per_block  = cluster_size * 8 // refcount_bits\n    # Virtual disk size, number of data clusters and L1 entries\n    disk_size = align_up(os.path.getsize(input_file), 512)\n    total_data_clusters = math.ceil(disk_size / cluster_size)\n    l1_entries = math.ceil(total_data_clusters / l2_entries_per_table)",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "def main():\n    # Command-line arguments\n    parser = argparse.ArgumentParser(\n        description=\"This program converts a QEMU disk image to qcow2 \"\n        \"and writes it to the standard output\"\n    )\n    parser.add_argument(\"input_file\", help=\"name of the input file\")\n    parser.add_argument(\n        \"-f\",\n        dest=\"input_format\",",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_DEFAULT_CLUSTER_SIZE",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_DEFAULT_CLUSTER_SIZE = 65536\nQCOW2_DEFAULT_REFCOUNT_BITS = 16\nQCOW2_FEATURE_NAME_TABLE = 0x6803F857\nQCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_DEFAULT_REFCOUNT_BITS",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_DEFAULT_REFCOUNT_BITS = 16\nQCOW2_FEATURE_NAME_TABLE = 0x6803F857\nQCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_FEATURE_NAME_TABLE",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_FEATURE_NAME_TABLE = 0x6803F857\nQCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_DATA_FILE_NAME_STRING",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_DATA_FILE_NAME_STRING = 0x44415441\nQCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_V3_HEADER_LENGTH",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_V3_HEADER_LENGTH = 112  # Header length in QEMU 9.0. Must be a multiple of 8\nQCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_INCOMPAT_DATA_FILE_BIT",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_INCOMPAT_DATA_FILE_BIT = 2\nQCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW2_AUTOCLEAR_DATA_FILE_RAW_BIT = 1\nQCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QCOW_OFLAG_COPIED",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QCOW_OFLAG_COPIED = 1 << 63\nQEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QEMU_STORAGE_DAEMON",
        "kind": 5,
        "importPath": "qemu.scripts.qcow2-to-stdout",
        "description": "qemu.scripts.qcow2-to-stdout",
        "peekOfCode": "QEMU_STORAGE_DAEMON = \"qemu-storage-daemon\"\ndef bitmap_set(bitmap, idx):\n    bitmap[idx // 8] |= 1 << (idx % 8)\ndef bitmap_is_set(bitmap, idx):\n    return (bitmap[idx // 8] & (1 << (idx % 8))) != 0\ndef bitmap_iterator(bitmap, length):\n    for idx in range(length):\n        if bitmap_is_set(bitmap, idx):\n            yield idx\ndef align_up(num, d):",
        "detail": "qemu.scripts.qcow2-to-stdout",
        "documentation": {}
    },
    {
        "label": "QemuCommand",
        "kind": 6,
        "importPath": "qemu.scripts.qemu-gdb",
        "description": "qemu.scripts.qemu-gdb",
        "peekOfCode": "class QemuCommand(gdb.Command):\n    '''Prefix for QEMU debug support commands'''\n    def __init__(self):\n        gdb.Command.__init__(self, 'qemu', gdb.COMMAND_DATA,\n                             gdb.COMPLETE_NONE, True)\nQemuCommand()\ncoroutine.CoroutineCommand()\nmtree.MtreeCommand()\naio.HandlersCommand()\ntcg.TCGLockStatusCommand()",
        "detail": "qemu.scripts.qemu-gdb",
        "documentation": {}
    },
    {
        "label": "extract_symbols",
        "kind": 2,
        "importPath": "qemu.scripts.qemu-plugin-symbols",
        "description": "qemu.scripts.qemu-plugin-symbols",
        "peekOfCode": "def extract_symbols(plugin_header):\n    with open(plugin_header) as file:\n        content = file.read()\n    # Remove QEMU_PLUGIN_API macro definition.\n    content = content.replace('#define QEMU_PLUGIN_API', '')\n    expected = content.count('QEMU_PLUGIN_API')\n    # Find last word between QEMU_PLUGIN_API and (, matching on several lines.\n    # We use *? non-greedy quantifier.\n    syms = re.findall(r'QEMU_PLUGIN_API.*?(\\w+)\\s*\\(', content, re.DOTALL)\n    syms.sort()",
        "detail": "qemu.scripts.qemu-plugin-symbols",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.qemu-plugin-symbols",
        "description": "qemu.scripts.qemu-plugin-symbols",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(description='Extract QEMU plugin symbols')\n    parser.add_argument('plugin_header', help='Path to QEMU plugin header.')\n    args = parser.parse_args()\n    syms = extract_symbols(args.plugin_header)\n    print('{')\n    for s in syms:\n        print(\"  {};\".format(s))\n    print('};')\nif __name__ == '__main__':",
        "detail": "qemu.scripts.qemu-plugin-symbols",
        "documentation": {}
    },
    {
        "label": "sha",
        "kind": 5,
        "importPath": "qemu.scripts.qemu-stamp",
        "description": "qemu.scripts.qemu-stamp",
        "peekOfCode": "sha = hashlib.sha1()\nis_file = False\nfor arg in sys.argv[1:]:\n    if arg == '--':\n        is_file = True\n        continue\n    if is_file:\n        with open(arg, 'rb') as f:\n            for chunk in iter(lambda: f.read(65536), b''):\n                sha.update(chunk)",
        "detail": "qemu.scripts.qemu-stamp",
        "documentation": {}
    },
    {
        "label": "is_file",
        "kind": 5,
        "importPath": "qemu.scripts.qemu-stamp",
        "description": "qemu.scripts.qemu-stamp",
        "peekOfCode": "is_file = False\nfor arg in sys.argv[1:]:\n    if arg == '--':\n        is_file = True\n        continue\n    if is_file:\n        with open(arg, 'rb') as f:\n            for chunk in iter(lambda: f.read(65536), b''):\n                sha.update(chunk)\n    else:",
        "detail": "qemu.scripts.qemu-stamp",
        "documentation": {}
    },
    {
        "label": "print_cocci_rule",
        "kind": 2,
        "importPath": "qemu.scripts.qom-cast-macro-clean-cocci-gen",
        "description": "qemu.scripts.qom-cast-macro-clean-cocci-gen",
        "peekOfCode": "def print_cocci_rule(qom_typedef, qom_cast_macro):\n    print(f'''@@\ntypedef {qom_typedef};\n{qom_typedef} *obj;\n@@\n-    {qom_cast_macro}(obj)\n+    obj\n''')\npatterns = [\n    r'DECLARE_INSTANCE_CHECKER\\((\\w+),\\W*(\\w+),\\W*TYPE_\\w+\\)',",
        "detail": "qemu.scripts.qom-cast-macro-clean-cocci-gen",
        "documentation": {}
    },
    {
        "label": "patterns",
        "kind": 5,
        "importPath": "qemu.scripts.qom-cast-macro-clean-cocci-gen",
        "description": "qemu.scripts.qom-cast-macro-clean-cocci-gen",
        "peekOfCode": "patterns = [\n    r'DECLARE_INSTANCE_CHECKER\\((\\w+),\\W*(\\w+),\\W*TYPE_\\w+\\)',\n    r'DECLARE_OBJ_CHECKERS\\((\\w+),\\W*\\w+,\\W*(\\w+),\\W*TYPE_\\w+\\)',\n    r'OBJECT_DECLARE_TYPE\\((\\w+),\\W*\\w+,\\W*(\\w+)\\)',\n    r'OBJECT_DECLARE_SIMPLE_TYPE\\((\\w+),\\W*(\\w+)\\)',\n    r'INTERFACE_CHECK\\((\\w+),\\W*\\(\\w+\\),\\W*TYPE_(\\w+)\\)',\n]\nfor fn in sys.argv[1:]:\n    try:\n        content = open(fn, 'rt').read()",
        "detail": "qemu.scripts.qom-cast-macro-clean-cocci-gen",
        "documentation": {}
    },
    {
        "label": "LibvirtGuest",
        "kind": 6,
        "importPath": "qemu.scripts.render_block_graph",
        "description": "qemu.scripts.render_block_graph",
        "peekOfCode": "class LibvirtGuest():\n    def __init__(self, name):\n        self.name = name\n    def cmd(self, cmd):\n        # only supports qmp commands without parameters\n        m = {'execute': cmd}\n        ar = ['virsh', 'qemu-monitor-command', self.name, json.dumps(m)]\n        reply = json.loads(subprocess.check_output(ar))\n        if 'error' in reply:\n            raise QMPError(reply)",
        "detail": "qemu.scripts.render_block_graph",
        "documentation": {}
    },
    {
        "label": "perm",
        "kind": 2,
        "importPath": "qemu.scripts.render_block_graph",
        "description": "qemu.scripts.render_block_graph",
        "peekOfCode": "def perm(arr):\n    s = 'w' if 'write' in arr else '_'\n    s += 'r' if 'consistent-read' in arr else '_'\n    s += 'u' if 'write-unchanged' in arr else '_'\n    s += 's' if 'resize' in arr else '_'\n    return s\ndef render_block_graph(qmp, filename, format='png'):\n    '''\n    Render graph in text (dot) representation into \"@filename\" and\n    representation in @format into \"@filename.@format\"",
        "detail": "qemu.scripts.render_block_graph",
        "documentation": {}
    },
    {
        "label": "render_block_graph",
        "kind": 2,
        "importPath": "qemu.scripts.render_block_graph",
        "description": "qemu.scripts.render_block_graph",
        "peekOfCode": "def render_block_graph(qmp, filename, format='png'):\n    '''\n    Render graph in text (dot) representation into \"@filename\" and\n    representation in @format into \"@filename.@format\"\n    '''\n    bds_nodes = qmp.cmd('query-named-block-nodes')\n    bds_nodes = {n['node-name']: n for n in bds_nodes}\n    job_nodes = qmp.cmd('query-block-jobs')\n    job_nodes = {n['device']: n for n in job_nodes}\n    block_graph = qmp.cmd('x-debug-query-block-graph')",
        "detail": "qemu.scripts.render_block_graph",
        "documentation": {}
    },
    {
        "label": "ReplayState",
        "kind": 6,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "class ReplayState(object):\n    def __init__(self):\n        self.event = -1\n        self.event_count = 0\n        self.already_read = False\n        self.current_checkpoint = 0\n        self.checkpoint = 0\n    def set_event(self, ev):\n        self.event = ev\n        self.event_count += 1",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_byte",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def read_byte(fin):\n    \"Read a single byte\"\n    return struct.unpack('>B', fin.read(1))[0]\ndef read_event(fin):\n    \"Read a single byte event, but save some state\"\n    if replay_state.already_read:\n        return replay_state.get_event()\n    else:\n        replay_state.set_event(read_byte(fin))\n        return replay_state.event",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_event",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def read_event(fin):\n    \"Read a single byte event, but save some state\"\n    if replay_state.already_read:\n        return replay_state.get_event()\n    else:\n        replay_state.set_event(read_byte(fin))\n        return replay_state.event\ndef read_word(fin):\n    \"Read a 16 bit word\"\n    return struct.unpack('>H', fin.read(2))[0]",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_word",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def read_word(fin):\n    \"Read a 16 bit word\"\n    return struct.unpack('>H', fin.read(2))[0]\ndef read_dword(fin):\n    \"Read a 32 bit word\"\n    return struct.unpack('>I', fin.read(4))[0]\ndef read_qword(fin):\n    \"Read a 64 bit word\"\n    return struct.unpack('>Q', fin.read(8))[0]\ndef read_array(fin):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_dword",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def read_dword(fin):\n    \"Read a 32 bit word\"\n    return struct.unpack('>I', fin.read(4))[0]\ndef read_qword(fin):\n    \"Read a 64 bit word\"\n    return struct.unpack('>Q', fin.read(8))[0]\ndef read_array(fin):\n    \"Read a sized array\"\n    size = read_dword(fin)\n    data = fin.read(size)",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_qword",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def read_qword(fin):\n    \"Read a 64 bit word\"\n    return struct.unpack('>Q', fin.read(8))[0]\ndef read_array(fin):\n    \"Read a sized array\"\n    size = read_dword(fin)\n    data = fin.read(size)\n    return data\n# Generic decoder structure\nDecoder = namedtuple(\"Decoder\", \"eid name fn\")",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "read_array",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def read_array(fin):\n    \"Read a sized array\"\n    size = read_dword(fin)\n    data = fin.read(size)\n    return data\n# Generic decoder structure\nDecoder = namedtuple(\"Decoder\", \"eid name fn\")\ndef call_decode(table, index, dumpfile):\n    \"Search decode table for next step\"\n    decoder = next((d for d in table if d.eid == index), None)",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "call_decode",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def call_decode(table, index, dumpfile):\n    \"Search decode table for next step\"\n    decoder = next((d for d in table if d.eid == index), None)\n    if not decoder:\n        print(\"Could not decode index: %d\" % (index))\n        print(\"Entry is: %s\" % (decoder))\n        print(\"Decode Table is:\\n%s\" % (table))\n        raise(Exception(\"unknown event\"))\n    else:\n        return decoder.fn(decoder.eid, decoder.name, dumpfile)",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "print_event",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def print_event(eid, name, string=None, event_count=None):\n    \"Print event with count\"\n    if not event_count:\n        event_count = replay_state.event_count\n    if string:\n        print(\"%d:%s(%d) %s\" % (event_count, name, eid, string))\n    else:\n        print(\"%d:%s(%d)\" % (event_count, name, eid))\n# Decoders for each event type\ndef decode_unimp(eid, name, _unused_dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_unimp",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_unimp(eid, name, _unused_dumpfile):\n    \"Unimplemented decoder, will trigger exit\"\n    print(\"%s not handled - will now stop\" % (name))\n    raise(Exception(\"unhandled event\"))\ndef decode_plain(eid, name, _unused_dumpfile):\n    \"Plain events without additional data\"\n    print_event(eid, name, \"no data\")\n    return True\n# Checkpoint decoder\ndef swallow_async_qword(eid, name, dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_plain",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_plain(eid, name, _unused_dumpfile):\n    \"Plain events without additional data\"\n    print_event(eid, name, \"no data\")\n    return True\n# Checkpoint decoder\ndef swallow_async_qword(eid, name, dumpfile):\n    \"Swallow a qword of data without looking at it\"\n    step_id = read_qword(dumpfile)\n    print(\"  %s(%d) @ %d\" % (name, eid, step_id))\n    return True",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "swallow_async_qword",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def swallow_async_qword(eid, name, dumpfile):\n    \"Swallow a qword of data without looking at it\"\n    step_id = read_qword(dumpfile)\n    print(\"  %s(%d) @ %d\" % (name, eid, step_id))\n    return True\ndef swallow_bytes(eid, name, dumpfile, nr):\n    \"\"\"Swallow nr bytes of data without looking at it\"\"\"\n    dumpfile.seek(nr, os.SEEK_CUR)\ntotal_insns = 0\ndef decode_instruction(eid, name, dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "swallow_bytes",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def swallow_bytes(eid, name, dumpfile, nr):\n    \"\"\"Swallow nr bytes of data without looking at it\"\"\"\n    dumpfile.seek(nr, os.SEEK_CUR)\ntotal_insns = 0\ndef decode_instruction(eid, name, dumpfile):\n    global total_insns\n    ins_diff = read_dword(dumpfile)\n    total_insns += ins_diff\n    print_event(eid, name, \"+ %d -> %d\" % (ins_diff, total_insns))\n    return True",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_instruction",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_instruction(eid, name, dumpfile):\n    global total_insns\n    ins_diff = read_dword(dumpfile)\n    total_insns += ins_diff\n    print_event(eid, name, \"+ %d -> %d\" % (ins_diff, total_insns))\n    return True\ndef decode_interrupt(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_exception(eid, name, dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_interrupt",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_interrupt(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_exception(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\n# v12 does away with the additional event byte and encodes it in the main type\n# Between v8 and v9, REPLAY_ASYNC_BH_ONESHOT was added, but we don't decode\n# those versions so leave it out.\nasync_decode_table = [ Decoder(0, \"REPLAY_ASYNC_EVENT_BH\", swallow_async_qword),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_exception",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_exception(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\n# v12 does away with the additional event byte and encodes it in the main type\n# Between v8 and v9, REPLAY_ASYNC_BH_ONESHOT was added, but we don't decode\n# those versions so leave it out.\nasync_decode_table = [ Decoder(0, \"REPLAY_ASYNC_EVENT_BH\", swallow_async_qword),\n                       Decoder(1, \"REPLAY_ASYNC_INPUT\", decode_unimp),\n                       Decoder(2, \"REPLAY_ASYNC_INPUT_SYNC\", decode_unimp),\n                       Decoder(3, \"REPLAY_ASYNC_CHAR_READ\", decode_unimp),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_old",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_async_old(eid, name, dumpfile):\n    \"\"\"Decode an ASYNC event (pre-v8)\"\"\"\n    print_event(eid, name)\n    async_event_kind = read_byte(dumpfile)\n    async_event_checkpoint = read_byte(dumpfile)\n    if async_event_checkpoint != replay_state.current_checkpoint:\n        print(\"  mismatch between checkpoint %d and async data %d\" % (\n            replay_state.current_checkpoint, async_event_checkpoint))\n        return True\n    return call_decode(async_decode_table, async_event_kind, dumpfile)",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_bh",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_async_bh(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_bh_oneshot(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_char_read(eid, name, dumpfile):\n    char_id = read_byte(dumpfile)",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_bh_oneshot",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_async_bh_oneshot(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_char_read(eid, name, dumpfile):\n    char_id = read_byte(dumpfile)\n    size = read_dword(dumpfile)\n    print_event(eid, name, \"device:%x chars:%s\" % (char_id, dumpfile.read(size)))\n    return True\ndef decode_async_block(eid, name, dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_char_read",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_async_char_read(eid, name, dumpfile):\n    char_id = read_byte(dumpfile)\n    size = read_dword(dumpfile)\n    print_event(eid, name, \"device:%x chars:%s\" % (char_id, dumpfile.read(size)))\n    return True\ndef decode_async_block(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_net(eid, name, dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_block",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_async_block(eid, name, dumpfile):\n    op_id = read_qword(dumpfile)\n    print_event(eid, name)\n    return True\ndef decode_async_net(eid, name, dumpfile):\n    net_id = read_byte(dumpfile)\n    flags = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    print_event(eid, name, \"net:%x flags:%x bytes:%d\" % (net_id, flags, size))",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_async_net",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_async_net(eid, name, dumpfile):\n    net_id = read_byte(dumpfile)\n    flags = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    print_event(eid, name, \"net:%x flags:%x bytes:%d\" % (net_id, flags, size))\n    return True\ndef decode_shutdown(eid, name, dumpfile):\n    print_event(eid, name)\n    return True",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_shutdown",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_shutdown(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_char_write(eid, name, dumpfile):\n    res = read_dword(dumpfile)\n    offset = read_dword(dumpfile)\n    print_event(eid, name, \"%d -> %d\" % (offset, res))\n    return True\ndef decode_audio_out(eid, name, dumpfile):\n    audio_data = read_dword(dumpfile)",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_char_write",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_char_write(eid, name, dumpfile):\n    res = read_dword(dumpfile)\n    offset = read_dword(dumpfile)\n    print_event(eid, name, \"%d -> %d\" % (offset, res))\n    return True\ndef decode_audio_out(eid, name, dumpfile):\n    audio_data = read_dword(dumpfile)\n    print_event(eid, name, \"%d\" % (audio_data))\n    return True\ndef decode_random(eid, name, dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_audio_out",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_audio_out(eid, name, dumpfile):\n    audio_data = read_dword(dumpfile)\n    print_event(eid, name, \"%d\" % (audio_data))\n    return True\ndef decode_random(eid, name, dumpfile):\n    ret = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    if (ret):\n        print_event(eid, name, \"%d bytes (getrandom failed)\" % (size))",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_random",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_random(eid, name, dumpfile):\n    ret = read_dword(dumpfile)\n    size = read_dword(dumpfile)\n    swallow_bytes(eid, name, dumpfile, size)\n    if (ret):\n        print_event(eid, name, \"%d bytes (getrandom failed)\" % (size))\n    else:\n        print_event(eid, name, \"%d bytes\" % (size))\n    return True\ndef decode_clock(eid, name, dumpfile):",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_clock",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_clock(eid, name, dumpfile):\n    clock_data = read_qword(dumpfile)\n    print_event(eid, name, \"0x%x\" % (clock_data))\n    return True\ndef __decode_checkpoint(eid, name, dumpfile, old):\n    \"\"\"Decode a checkpoint.\n    Checkpoints contain a series of async events with their own specific data.\n    \"\"\"\n    replay_state.set_checkpoint()\n    # save event count as we peek ahead",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_checkpoint_old",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_checkpoint_old(eid, name, dumpfile):\n    return __decode_checkpoint(eid, name, dumpfile, False)\ndef decode_checkpoint(eid, name, dumpfile):\n    return __decode_checkpoint(eid, name, dumpfile, True)\ndef decode_checkpoint_init(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_checkpoint",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_checkpoint(eid, name, dumpfile):\n    return __decode_checkpoint(eid, name, dumpfile, True)\ndef decode_checkpoint_init(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False\n# pre-MTTCG merge\nv5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_checkpoint_init",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_checkpoint_init(eid, name, dumpfile):\n    print_event(eid, name)\n    return True\ndef decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False\n# pre-MTTCG merge\nv5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_end",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_end(eid, name, dumpfile):\n    print_event(eid, name)\n    return False\n# pre-MTTCG merge\nv5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_CHAR_WRITE\", decode_char_write),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def parse_arguments():\n    \"Grab arguments for script\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-f\", \"--file\", help='record/replay dump to read from',\n                        required=True)\n    return parser.parse_args()\ndef decode_file(filename):\n    \"Decode a record/replay dump\"\n    dumpfile = open(filename, \"rb\")\n    dumpsize = path.getsize(filename)",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "decode_file",
        "kind": 2,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "def decode_file(filename):\n    \"Decode a record/replay dump\"\n    dumpfile = open(filename, \"rb\")\n    dumpsize = path.getsize(filename)\n    # read and throwaway the header\n    version = read_dword(dumpfile)\n    junk = read_qword(dumpfile)\n    # see REPLAY_VERSION\n    print(\"HEADER: version 0x%x\" % (version))\n    if version == 0xe0200c:",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "replay_state",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "replay_state = ReplayState()\n# Simple read functions that mirror replay-internal.c\n# The file-stream is big-endian and manually written out a byte at a time.\ndef read_byte(fin):\n    \"Read a single byte\"\n    return struct.unpack('>B', fin.read(1))[0]\ndef read_event(fin):\n    \"Read a single byte event, but save some state\"\n    if replay_state.already_read:\n        return replay_state.get_event()",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "Decoder = namedtuple(\"Decoder\", \"eid name fn\")\ndef call_decode(table, index, dumpfile):\n    \"Search decode table for next step\"\n    decoder = next((d for d in table if d.eid == index), None)\n    if not decoder:\n        print(\"Could not decode index: %d\" % (index))\n        print(\"Entry is: %s\" % (decoder))\n        print(\"Decode Table is:\\n%s\" % (table))\n        raise(Exception(\"unknown event\"))\n    else:",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "total_insns",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "total_insns = 0\ndef decode_instruction(eid, name, dumpfile):\n    global total_insns\n    ins_diff = read_dword(dumpfile)\n    total_insns += ins_diff\n    print_event(eid, name, \"+ %d -> %d\" % (ins_diff, total_insns))\n    return True\ndef decode_interrupt(eid, name, dumpfile):\n    print_event(eid, name)\n    return True",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "async_decode_table",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "async_decode_table = [ Decoder(0, \"REPLAY_ASYNC_EVENT_BH\", swallow_async_qword),\n                       Decoder(1, \"REPLAY_ASYNC_INPUT\", decode_unimp),\n                       Decoder(2, \"REPLAY_ASYNC_INPUT_SYNC\", decode_unimp),\n                       Decoder(3, \"REPLAY_ASYNC_CHAR_READ\", decode_unimp),\n                       Decoder(4, \"REPLAY_ASYNC_EVENT_BLOCK\", decode_unimp),\n                       Decoder(5, \"REPLAY_ASYNC_EVENT_NET\", decode_unimp),\n]\n# See replay_read_events/replay_read_event\ndef decode_async_old(eid, name, dumpfile):\n    \"\"\"Decode an ASYNC event (pre-v8)\"\"\"",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v5_event_table",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "v5_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_CHAR_WRITE\", decode_char_write),\n                  Decoder(6, \"EVENT_CHAR_READ_ALL\", decode_unimp),\n                  Decoder(7, \"EVENT_CHAR_READ_ALL_ERROR\", decode_unimp),\n                  Decoder(8, \"EVENT_CLOCK_HOST\", decode_clock),\n                  Decoder(9, \"EVENT_CLOCK_VIRTUAL_RT\", decode_clock),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v6_event_table",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "v6_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_plain),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_CHAR_WRITE\", decode_char_write),\n                  Decoder(6, \"EVENT_CHAR_READ_ALL\", decode_unimp),\n                  Decoder(7, \"EVENT_CHAR_READ_ALL_ERROR\", decode_unimp),\n                  Decoder(8, \"EVENT_AUDIO_OUT\", decode_audio_out),\n                  Decoder(9, \"EVENT_AUDIO_IN\", decode_unimp),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v7_event_table",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "v7_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_unimp),\n                  Decoder(3, \"EVENT_ASYNC\", decode_async_old),\n                  Decoder(4, \"EVENT_SHUTDOWN\", decode_unimp),\n                  Decoder(5, \"EVENT_SHUTDOWN_HOST_ERR\", decode_unimp),\n                  Decoder(6, \"EVENT_SHUTDOWN_HOST_QMP\", decode_unimp),\n                  Decoder(7, \"EVENT_SHUTDOWN_HOST_SIGNAL\", decode_unimp),\n                  Decoder(8, \"EVENT_SHUTDOWN_HOST_UI\", decode_unimp),\n                  Decoder(9, \"EVENT_SHUTDOWN_GUEST_SHUTDOWN\", decode_unimp),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "v12_event_table",
        "kind": 5,
        "importPath": "qemu.scripts.replay-dump",
        "description": "qemu.scripts.replay-dump",
        "peekOfCode": "v12_event_table = [Decoder(0, \"EVENT_INSTRUCTION\", decode_instruction),\n                  Decoder(1, \"EVENT_INTERRUPT\", decode_interrupt),\n                  Decoder(2, \"EVENT_EXCEPTION\", decode_exception),\n                  Decoder(3, \"EVENT_ASYNC_BH\", decode_async_bh),\n                  Decoder(4, \"EVENT_ASYNC_BH_ONESHOT\", decode_async_bh_oneshot),\n                  Decoder(5, \"EVENT_ASYNC_INPUT\", decode_unimp),\n                  Decoder(6, \"EVENT_ASYNC_INPUT_SYNC\", decode_unimp),\n                  Decoder(7, \"EVENT_ASYNC_CHAR_READ\", decode_async_char_read),\n                  Decoder(8, \"EVENT_ASYNC_BLOCK\", decode_async_block),\n                  Decoder(9, \"EVENT_ASYNC_NET\", decode_async_net),",
        "detail": "qemu.scripts.replay-dump",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.shaderinclude",
        "description": "qemu.scripts.shaderinclude",
        "peekOfCode": "def main(args):\n    file_path = args[1]\n    basename = os.path.basename(file_path)\n    varname = basename.replace('-', '_').replace('.', '_')\n    with os.fdopen(sys.stdout.fileno(), \"wt\", closefd=False, newline='\\n') as stdout:\n        with open(file_path, \"r\", encoding='utf-8') as file:\n            print(f'static GLchar {varname}_src[] =', file=stdout)\n            for line in file:\n                line = line.rstrip()\n                print(f'    \"{line}\\\\n\"', file=stdout)",
        "detail": "qemu.scripts.shaderinclude",
        "documentation": {}
    },
    {
        "label": "fin",
        "kind": 5,
        "importPath": "qemu.scripts.signrom",
        "description": "qemu.scripts.signrom",
        "peekOfCode": "fin = open(sys.argv[1], 'rb')\nfout = open(sys.argv[2], 'wb')\nmagic = fin.read(2)\nif magic != b'\\x55\\xaa':\n    sys.exit(\"%s: option ROM does not begin with magic 55 aa\" % sys.argv[1])\nsize_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:",
        "detail": "qemu.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "fout",
        "kind": 5,
        "importPath": "qemu.scripts.signrom",
        "description": "qemu.scripts.signrom",
        "peekOfCode": "fout = open(sys.argv[2], 'wb')\nmagic = fin.read(2)\nif magic != b'\\x55\\xaa':\n    sys.exit(\"%s: option ROM does not begin with magic 55 aa\" % sys.argv[1])\nsize_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))",
        "detail": "qemu.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "magic",
        "kind": 5,
        "importPath": "qemu.scripts.signrom",
        "description": "qemu.scripts.signrom",
        "peekOfCode": "magic = fin.read(2)\nif magic != b'\\x55\\xaa':\n    sys.exit(\"%s: option ROM does not begin with magic 55 aa\" % sys.argv[1])\nsize_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)",
        "detail": "qemu.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "size_byte",
        "kind": 5,
        "importPath": "qemu.scripts.signrom",
        "description": "qemu.scripts.signrom",
        "peekOfCode": "size_byte = ord(fin.read(1))\nfin.seek(0)\ndata = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)\nelif len(data) < size:\n    # Add padding if necessary, rounding the whole input to a multiple of\n    # 512 bytes according to the third byte of the input.",
        "detail": "qemu.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "qemu.scripts.signrom",
        "description": "qemu.scripts.signrom",
        "peekOfCode": "data = fin.read()\nsize = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)\nelif len(data) < size:\n    # Add padding if necessary, rounding the whole input to a multiple of\n    # 512 bytes according to the third byte of the input.\n    # size-1 because a final byte is added below to store the checksum.\n    data = data.ljust(size-1, b'\\0')",
        "detail": "qemu.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "qemu.scripts.signrom",
        "description": "qemu.scripts.signrom",
        "peekOfCode": "size = size_byte * 512\nif len(data) > size:\n    sys.stderr.write('error: ROM is too large (%d > %d)\\n' % (len(data), size))\n    sys.exit(1)\nelif len(data) < size:\n    # Add padding if necessary, rounding the whole input to a multiple of\n    # 512 bytes according to the third byte of the input.\n    # size-1 because a final byte is added below to store the checksum.\n    data = data.ljust(size-1, b'\\0')\nelse:",
        "detail": "qemu.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "checksum",
        "kind": 5,
        "importPath": "qemu.scripts.signrom",
        "description": "qemu.scripts.signrom",
        "peekOfCode": "checksum = 0\nfor b in data:\n    checksum = (checksum - b) & 255\nfout.write(struct.pack('B', checksum))\nfin.close()\nfout.close()",
        "detail": "qemu.scripts.signrom",
        "documentation": {}
    },
    {
        "label": "SimpleException",
        "kind": 6,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "class SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')\n    return struct.unpack(hfmt, hdr)\ndef get_mapping(fobj):",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "Analyzer",
        "kind": 6,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "class Analyzer:\n    \"\"\"[Deprecated. Refer to Analyzer2 instead.]\n    A trace file analyzer which processes trace records.\n    An analyzer can be passed to run() or process().  The begin() method is\n    invoked, then each trace record is processed, and finally the end() method\n    is invoked. When Analyzer is used as a context-manager (using the `with`\n    statement), begin() and end() are called automatically.\n    If a method matching a trace event name exists, it is invoked to process\n    that trace record.  Otherwise the catchall() method is invoked.\n    Example:",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "Analyzer2",
        "kind": 6,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "class Analyzer2(Analyzer):\n    \"\"\"A trace file analyzer which processes trace records.\n    An analyzer can be passed to run() or process().  The begin() method is\n    invoked, then each trace record is processed, and finally the end() method\n    is invoked. When Analyzer is used as a context-manager (using the `with`\n    statement), begin() and end() are called automatically.\n    If a method matching a trace event name exists, it is invoked to process\n    that trace record.  Otherwise the catchall() method is invoked.\n    The methods are called with a set of keyword-arguments. These can be ignored\n    using `**kwargs` or defined like any keyword-argument.",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_header",
        "kind": 2,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "def read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')\n    return struct.unpack(hfmt, hdr)\ndef get_mapping(fobj):\n    (event_id, ) = struct.unpack('=Q', fobj.read(8))\n    (len, ) = struct.unpack('=L', fobj.read(4))",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "get_mapping",
        "kind": 2,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "def get_mapping(fobj):\n    (event_id, ) = struct.unpack('=Q', fobj.read(8))\n    (len, ) = struct.unpack('=L', fobj.read(4))\n    name = fobj.read(len).decode()\n    return (event_id, name)\ndef read_record(fobj):\n    \"\"\"Deserialize a trace record from a file into a tuple (event_num, timestamp, pid, args).\"\"\"\n    event_id, timestamp_ns, record_length, record_pid = read_header(fobj, rec_header_fmt)\n    args_payload = fobj.read(record_length - rec_header_fmt_len)\n    return (event_id, timestamp_ns, record_pid, args_payload)",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_record",
        "kind": 2,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "def read_record(fobj):\n    \"\"\"Deserialize a trace record from a file into a tuple (event_num, timestamp, pid, args).\"\"\"\n    event_id, timestamp_ns, record_length, record_pid = read_header(fobj, rec_header_fmt)\n    args_payload = fobj.read(record_length - rec_header_fmt_len)\n    return (event_id, timestamp_ns, record_pid, args_payload)\ndef read_trace_header(fobj):\n    \"\"\"Read and verify trace file header\"\"\"\n    _header_event_id, _header_magic, log_version = read_header(fobj, log_header_fmt)\n    if _header_event_id != header_event_id:\n        raise ValueError(f'Not a valid trace file, header id {_header_event_id} != {header_event_id}')",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_trace_header",
        "kind": 2,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "def read_trace_header(fobj):\n    \"\"\"Read and verify trace file header\"\"\"\n    _header_event_id, _header_magic, log_version = read_header(fobj, log_header_fmt)\n    if _header_event_id != header_event_id:\n        raise ValueError(f'Not a valid trace file, header id {_header_event_id} != {header_event_id}')\n    if _header_magic != header_magic:\n        raise ValueError(f'Not a valid trace file, header magic {_header_magic} != {header_magic}')\n    if log_version not in [0, 2, 3, 4]:\n        raise ValueError(f'Unknown version {log_version} of tracelog format!')\n    if log_version != 4:",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "read_trace_records",
        "kind": 2,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "def read_trace_records(events, fobj, read_header):\n    \"\"\"Deserialize trace records from a file, yielding record tuples (event, event_num, timestamp, pid, arg1, ..., arg6).\n    Args:\n        event_mapping (str -> Event): events dict, indexed by name\n        fobj (file): input file\n        read_header (bool): whether headers were read from fobj\n    \"\"\"\n    frameinfo = inspect.getframeinfo(inspect.currentframe())\n    dropped_event = Event.build(\"Dropped_Event(uint64_t num_events_dropped)\",\n                                frameinfo.lineno + 1, frameinfo.filename)",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "def process(events, log, analyzer, read_header=True):\n    \"\"\"Invoke an analyzer on each event in a log.\n    Args:\n        events (file-object or list or str): events list or file-like object or file path as str to read event data from\n        log (file-object or str): file-like object or file path as str to read log data from\n        analyzer (Analyzer): Instance of Analyzer to interpret the event data\n        read_header (bool, optional): Whether to read header data from the log data. Defaults to True.\n    \"\"\"\n    if isinstance(events, str):\n        with open(events, 'r') as f:",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "def run(analyzer):\n    \"\"\"Execute an analyzer on a trace file given on the command-line.\n    This function is useful as a driver for simple analysis scripts.  More\n    advanced scripts will want to call process() instead.\"\"\"\n    try:\n        # NOTE: See built-in `argparse` module for a more robust cli interface\n        *no_header, trace_event_path, trace_file_path = sys.argv[1:]\n        assert no_header == [] or no_header == ['--no-header'], 'Invalid no-header argument'\n    except (AssertionError, ValueError):\n        raise SimpleException(f'usage: {sys.argv[0]} [--no-header] <trace-events> <trace-file>\\n')",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "__all__ = ['Analyzer', 'Analyzer2', 'process', 'run']\n# This is the binary format that the QEMU \"simple\" trace backend\n# emits. There is no specification documentation because the format is\n# not guaranteed to be stable. Trace files must be parsed with the\n# same trace-events-all file and the same simpletrace.py file that\n# QEMU was built with.\nheader_event_id = 0xffffffffffffffff\nheader_magic    = 0xf2b177cb0aa429b4\ndropped_event_id = 0xfffffffffffffffe\nrecord_type_mapping = 0",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "header_event_id",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "header_event_id = 0xffffffffffffffff\nheader_magic    = 0xf2b177cb0aa429b4\ndropped_event_id = 0xfffffffffffffffe\nrecord_type_mapping = 0\nrecord_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "dropped_event_id",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "dropped_event_id = 0xfffffffffffffffe\nrecord_type_mapping = 0\nrecord_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "record_type_mapping",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "record_type_mapping = 0\nrecord_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "record_type_event",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "record_type_event = 1\nlog_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "log_header_fmt",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "log_header_fmt = '=QQQ'\nrec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "rec_header_fmt",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "rec_header_fmt = '=QQII'\nrec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "rec_header_fmt_len",
        "kind": 5,
        "importPath": "qemu.scripts.simpletrace",
        "description": "qemu.scripts.simpletrace",
        "peekOfCode": "rec_header_fmt_len = struct.calcsize(rec_header_fmt)\nclass SimpleException(Exception):\n    pass\ndef read_header(fobj, hfmt):\n    '''Read a trace record header'''\n    hlen = struct.calcsize(hfmt)\n    hdr = fobj.read(hlen)\n    if len(hdr) != hlen:\n        raise SimpleException('Error reading header. Wrong filetype provided?')\n    return struct.unpack(hfmt, hdr)",
        "detail": "qemu.scripts.simpletrace",
        "documentation": {}
    },
    {
        "label": "destdir_join",
        "kind": 2,
        "importPath": "qemu.scripts.symlink-install-tree",
        "description": "qemu.scripts.symlink-install-tree",
        "peekOfCode": "def destdir_join(d1: str, d2: str) -> str:\n    if not d1:\n        return d2\n    # c:\\destdir + c:\\prefix must produce c:\\destdir\\prefix\n    return str(PurePath(d1, *PurePath(d2).parts[1:]))\nintrospect = os.environ.get('MESONINTROSPECT')\nout = subprocess.run([*shlex.split(introspect), '--installed'],\n                     stdout=subprocess.PIPE, check=True).stdout\nfor source, dest in json.loads(out).items():\n    bundle_dest = destdir_join('qemu-bundle', dest)",
        "detail": "qemu.scripts.symlink-install-tree",
        "documentation": {}
    },
    {
        "label": "introspect",
        "kind": 5,
        "importPath": "qemu.scripts.symlink-install-tree",
        "description": "qemu.scripts.symlink-install-tree",
        "peekOfCode": "introspect = os.environ.get('MESONINTROSPECT')\nout = subprocess.run([*shlex.split(introspect), '--installed'],\n                     stdout=subprocess.PIPE, check=True).stdout\nfor source, dest in json.loads(out).items():\n    bundle_dest = destdir_join('qemu-bundle', dest)\n    path = os.path.dirname(bundle_dest)\n    try:\n        os.makedirs(path, exist_ok=True)\n    except BaseException as e:\n        print(f'error making directory {path}', file=sys.stderr)",
        "detail": "qemu.scripts.symlink-install-tree",
        "documentation": {}
    },
    {
        "label": "out",
        "kind": 5,
        "importPath": "qemu.scripts.symlink-install-tree",
        "description": "qemu.scripts.symlink-install-tree",
        "peekOfCode": "out = subprocess.run([*shlex.split(introspect), '--installed'],\n                     stdout=subprocess.PIPE, check=True).stdout\nfor source, dest in json.loads(out).items():\n    bundle_dest = destdir_join('qemu-bundle', dest)\n    path = os.path.dirname(bundle_dest)\n    try:\n        os.makedirs(path, exist_ok=True)\n    except BaseException as e:\n        print(f'error making directory {path}', file=sys.stderr)\n        raise e",
        "detail": "qemu.scripts.symlink-install-tree",
        "documentation": {}
    },
    {
        "label": "error_opt",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool",
        "description": "qemu.scripts.tracetool",
        "peekOfCode": "def error_opt(msg = None):\n    if msg is not None:\n        error_write(\"Error: \" + msg + \"\\n\")\n    backend_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                                for n,d in tracetool.backend.get_list() ])\n    format_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                               for n,d in tracetool.format.get_list() ])\n    error_write(\"\"\"\\\nUsage: %(script)s --format=<format> --backends=<backends> [<options>] <trace-events> ... <output>\nBackends:",
        "detail": "qemu.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.tracetool",
        "description": "qemu.scripts.tracetool",
        "peekOfCode": "def main(args):\n    global _SCRIPT\n    _SCRIPT = args[0]\n    long_opts = [\"backends=\", \"format=\", \"help\", \"list-backends\",\n                 \"check-backends\", \"group=\"]\n    long_opts += [\"binary=\", \"probe-prefix=\"]\n    try:\n        opts, args = getopt.getopt(args[1:], \"\", long_opts)\n    except getopt.GetoptError as err:\n        error_opt(str(err))",
        "detail": "qemu.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "__maintainer__",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool",
        "description": "qemu.scripts.tracetool",
        "peekOfCode": "__maintainer__ = \"Stefan Hajnoczi\"\n__email__      = \"stefanha@redhat.com\"\nimport sys\nimport getopt\nfrom tracetool import error_write, out, out_open\nimport tracetool.backend\nimport tracetool.format\n_SCRIPT = \"\"\ndef error_opt(msg = None):\n    if msg is not None:",
        "detail": "qemu.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "_SCRIPT",
        "kind": 5,
        "importPath": "qemu.scripts.tracetool",
        "description": "qemu.scripts.tracetool",
        "peekOfCode": "_SCRIPT = \"\"\ndef error_opt(msg = None):\n    if msg is not None:\n        error_write(\"Error: \" + msg + \"\\n\")\n    backend_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                                for n,d in tracetool.backend.get_list() ])\n    format_descr = \"\\n\".join([ \"    %-15s %s\" % (n, d)\n                               for n,d in tracetool.format.get_list() ])\n    error_write(\"\"\"\\\nUsage: %(script)s --format=<format> --backends=<backends> [<options>] <trace-events> ... <output>",
        "detail": "qemu.scripts.tracetool",
        "documentation": {}
    },
    {
        "label": "write_setup_dir",
        "kind": 2,
        "importPath": "qemu.scripts.u2f-setup-gen",
        "description": "qemu.scripts.u2f-setup-gen",
        "peekOfCode": "def write_setup_dir(dirpath: str, privkey_pem: bytes, cert_pem: bytes,\n                    entropy: bytes, counter: int) -> None:\n    \"\"\"\n    Write the setup directory.\n    Args:\n        dirpath: The directory path.\n        key_pem: The private key PEM.\n        cert_pem: The certificate PEM.\n        entropy: The 48 bytes of entropy.\n        counter: The counter value.",
        "detail": "qemu.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "generate_ec_key_pair",
        "kind": 2,
        "importPath": "qemu.scripts.u2f-setup-gen",
        "description": "qemu.scripts.u2f-setup-gen",
        "peekOfCode": "def generate_ec_key_pair() -> Tuple[str, str]:\n    \"\"\"\n    Generate an ec key pair.\n    Returns:\n        The private and public key PEM.\n    \"\"\"\n    # Key generation\n    privkey = ec.generate_private_key(ec.SECP256R1, default_backend())\n    pubkey = privkey.public_key()\n    # PEM serialization",
        "detail": "qemu.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "generate_certificate",
        "kind": 2,
        "importPath": "qemu.scripts.u2f-setup-gen",
        "description": "qemu.scripts.u2f-setup-gen",
        "peekOfCode": "def generate_certificate(privkey_pem: str, pubkey_pem: str) -> str:\n    \"\"\"\n    Generate a x509 certificate from a key pair.\n    Args:\n        privkey_pem: The private key PEM.\n        pubkey_pem: The public key PEM.\n    Returns:\n        The certificate PEM.\n    \"\"\"\n    # Convert key pair",
        "detail": "qemu.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "generate_setup_dir",
        "kind": 2,
        "importPath": "qemu.scripts.u2f-setup-gen",
        "description": "qemu.scripts.u2f-setup-gen",
        "peekOfCode": "def generate_setup_dir(dirpath: str) -> None:\n    \"\"\"\n    Generates the setup directory.\n    Args:\n        dirpath: The directory path.\n    \"\"\"\n    # Key pair\n    privkey_pem, pubkey_pem = generate_ec_key_pair()\n    # Certificate\n    certificate_pem = generate_certificate(privkey_pem, pubkey_pem)",
        "detail": "qemu.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.u2f-setup-gen",
        "description": "qemu.scripts.u2f-setup-gen",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    Main function\n    \"\"\"\n    # Dir path\n    if len(sys.argv) != 2:\n        sys.stderr.write(f'Usage: {sys.argv[0]} <setup_dir>\\n')\n        exit(2)\n    dirpath = sys.argv[1]\n    # Dir non existence",
        "detail": "qemu.scripts.u2f-setup-gen",
        "documentation": {}
    },
    {
        "label": "filter_lines_set",
        "kind": 2,
        "importPath": "qemu.scripts.undefsym",
        "description": "qemu.scripts.undefsym",
        "peekOfCode": "def filter_lines_set(stdout, from_staticlib):\n    linesSet = set()\n    for line in stdout.splitlines():\n        tokens = line.split(b' ')\n        if len(tokens) >= 2:\n            if from_staticlib and tokens[1] == b'U':\n                continue\n            if not from_staticlib and tokens[1] != b'U':\n                continue\n            new_line = b'-Wl,-u,' + tokens[0]",
        "detail": "qemu.scripts.undefsym",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.undefsym",
        "description": "qemu.scripts.undefsym",
        "peekOfCode": "def main(args):\n    if len(args) <= 3:\n        sys.exit(0)\n    nm = args[1]\n    staticlib = args[2]\n    pc = subprocess.run([nm, \"-P\", \"-g\", staticlib], stdout=subprocess.PIPE)\n    if pc.returncode != 0:\n        sys.exit(1)\n    staticlib_syms = filter_lines_set(pc.stdout, True)\n    shared_modules = args[3:]",
        "detail": "qemu.scripts.undefsym",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.scripts.userfaultfd-wrlat",
        "description": "qemu.scripts.userfaultfd-wrlat",
        "peekOfCode": "def usage():\n    print(\"USAGE: %s [interval [count]]\" % argv[0])\n    exit()\n# define BPF program\nbpf_text = \"\"\"\n#include <uapi/linux/ptrace.h>\n#include <linux/mm.h>\nBPF_HASH(ev_start, u32, u64);\nBPF_HISTOGRAM(ev_delta_hist, u64);\n/* Trace UFFD page fault start event. */",
        "detail": "qemu.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "bpf_text",
        "kind": 5,
        "importPath": "qemu.scripts.userfaultfd-wrlat",
        "description": "qemu.scripts.userfaultfd-wrlat",
        "peekOfCode": "bpf_text = \"\"\"\n#include <uapi/linux/ptrace.h>\n#include <linux/mm.h>\nBPF_HASH(ev_start, u32, u64);\nBPF_HISTOGRAM(ev_delta_hist, u64);\n/* Trace UFFD page fault start event. */\nstatic void do_event_start()\n{\n    /* Using \"(u32)\" to drop group ID which is upper 32 bits */\n    u32 tid = (u32) bpf_get_current_pid_tgid();",
        "detail": "qemu.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "interval",
        "kind": 5,
        "importPath": "qemu.scripts.userfaultfd-wrlat",
        "description": "qemu.scripts.userfaultfd-wrlat",
        "peekOfCode": "interval = 10\ncount = -1\nif len(argv) > 1:\n    try:\n        interval = int(argv[1])\n        if interval == 0:\n            raise\n        if len(argv) > 2:\n            count = int(argv[2])\n    except:    # also catches -h, --help",
        "detail": "qemu.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 5,
        "importPath": "qemu.scripts.userfaultfd-wrlat",
        "description": "qemu.scripts.userfaultfd-wrlat",
        "peekOfCode": "count = -1\nif len(argv) > 1:\n    try:\n        interval = int(argv[1])\n        if interval == 0:\n            raise\n        if len(argv) > 2:\n            count = int(argv[2])\n    except:    # also catches -h, --help\n        usage()",
        "detail": "qemu.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "qemu.scripts.userfaultfd-wrlat",
        "description": "qemu.scripts.userfaultfd-wrlat",
        "peekOfCode": "b = BPF(text=bpf_text)\n# attach KRPOBEs\nb.attach_kprobe(event=\"handle_userfault\", fn_name=\"probe_handle_userfault\")\nb.attach_kretprobe(event=\"handle_userfault\", fn_name=\"retprobe_handle_userfault\")\n# header\nprint(\"Tracing UFFD-WP write fault latency... Hit Ctrl-C to end.\")\n# output\nloop = 0\ndo_exit = 0\nwhile (1):",
        "detail": "qemu.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "loop",
        "kind": 5,
        "importPath": "qemu.scripts.userfaultfd-wrlat",
        "description": "qemu.scripts.userfaultfd-wrlat",
        "peekOfCode": "loop = 0\ndo_exit = 0\nwhile (1):\n    if count > 0:\n        loop += 1\n        if loop > count:\n            exit()\n    try:\n        sleep(interval)\n    except KeyboardInterrupt:",
        "detail": "qemu.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "do_exit",
        "kind": 5,
        "importPath": "qemu.scripts.userfaultfd-wrlat",
        "description": "qemu.scripts.userfaultfd-wrlat",
        "peekOfCode": "do_exit = 0\nwhile (1):\n    if count > 0:\n        loop += 1\n        if loop > count:\n            exit()\n    try:\n        sleep(interval)\n    except KeyboardInterrupt:\n        pass; do_exit = 1",
        "detail": "qemu.scripts.userfaultfd-wrlat",
        "documentation": {}
    },
    {
        "label": "bump_taint",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def bump_taint():\n    global taint\n    # Ensure we don't wrap around or reset to 0 -- the shell only has\n    # an 8-bit return value.\n    if taint < 255:\n        taint = taint + 1\ndef check_fields_match(name, s_field, d_field):\n    if s_field == d_field:\n        return True\n    # Some fields changed names between qemu versions.  This list",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_fields_match",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_fields_match(name, s_field, d_field):\n    if s_field == d_field:\n        return True\n    # Some fields changed names between qemu versions.  This list\n    # is used to allow such changes in each section / description.\n    changed_names = {\n        'apic': ['timer', 'timer_expiry'],\n        'e1000': ['dev', 'parent_obj'],\n        'ehci': ['dev', 'pcidev'],\n        'I440FX': ['dev', 'parent_obj'],",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "get_changed_sec_name",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def get_changed_sec_name(sec):\n    # Section names can change -- see commit 292b1634 for an example.\n    changes = {\n        \"ICH9 LPC\": \"ICH9-LPC\",\n        \"e1000-82540em\": \"e1000\",\n    }\n    for item in changes:\n        if item == sec:\n            return changes[item]\n        if changes[item] == sec:",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "exists_in_substruct",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def exists_in_substruct(fields, item):\n    # Some QEMU versions moved a few fields inside a substruct.  This\n    # kept the on-wire format the same.  This function checks if\n    # something got shifted inside a substruct.  For example, the\n    # change in commit 1f42d22233b4f3d1a2933ff30e8d6a6d9ee2d08f\n    if not \"Description\" in fields:\n        return False\n    if not \"Fields\" in fields[\"Description\"]:\n        return False\n    substruct_fields = fields[\"Description\"][\"Fields\"]",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "size_total",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def size_total(entry):\n    size = entry[\"size\"]\n    if \"num\" not in entry:\n        return size\n    return size * entry[\"num\"]\ndef check_fields(src_fields, dest_fields, desc, sec):\n    # This function checks for all the fields in a section.  If some\n    # fields got embedded into a substruct, this function will also\n    # attempt to check inside the substruct.\n    d_iter = iter(dest_fields)",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_fields",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_fields(src_fields, dest_fields, desc, sec):\n    # This function checks for all the fields in a section.  If some\n    # fields got embedded into a substruct, this function will also\n    # attempt to check inside the substruct.\n    d_iter = iter(dest_fields)\n    s_iter = iter(src_fields)\n    # Using these lists as stacks to store previous value of s_iter\n    # and d_iter, so that when time comes to exit out of a substruct,\n    # we can go back one level up and continue from where we left off.\n    s_iter_list = []",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_subsections",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_subsections(src_sub, dest_sub, desc, sec):\n    for s_item in src_sub:\n        found = False\n        for d_item in dest_sub:\n            if s_item[\"name\"] != d_item[\"name\"]:\n                continue\n            found = True\n            check_descriptions(s_item, d_item, sec)\n        if not found:\n            print(\"Section \\\"\" + sec + \"\\\", Description \\\"\" + desc + \"\\\":\", end=' ')",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_description_in_list",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_description_in_list(s_item, d_item, sec, desc):\n    if not \"Description\" in s_item:\n        return\n    if not \"Description\" in d_item:\n        print(\"Section \\\"\" + sec + \"\\\", Description \\\"\" + desc + \"\\\",\", end=' ')\n        print(\"Field \\\"\" + s_item[\"field\"] + \"\\\": missing description\")\n        bump_taint()\n        return\n    check_descriptions(s_item[\"Description\"], d_item[\"Description\"], sec)\ndef check_descriptions(src_desc, dest_desc, sec):",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_descriptions",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_descriptions(src_desc, dest_desc, sec):\n    check_version(src_desc, dest_desc, sec, src_desc[\"name\"])\n    if not check_fields_match(sec, src_desc[\"name\"], dest_desc[\"name\"]):\n        print(\"Section \\\"\" + sec + \"\\\":\", end=' ')\n        print(\"Description \\\"\" + src_desc[\"name\"] + \"\\\"\", end=' ')\n        print(\"missing, got \\\"\" + dest_desc[\"name\"] + \"\\\" instead; skipping\")\n        bump_taint()\n        return\n    for f in src_desc:\n        if not f in dest_desc:",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_version",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_version(s, d, sec, desc=None):\n    if s[\"version_id\"] > d[\"version_id\"]:\n        print(\"Section \\\"\" + sec + \"\\\"\", end=' ')\n        if desc:\n            print(\"Description \\\"\" + desc + \"\\\":\", end=' ')\n        print(\"version error:\", s[\"version_id\"], \">\", d[\"version_id\"])\n        bump_taint()\n    if not \"minimum_version_id\" in d:\n        return\n    if s[\"version_id\"] < d[\"minimum_version_id\"]:",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_size",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_size(s, d, sec, desc=None, field=None):\n    if s[\"size\"] != d[\"size\"]:\n        print(\"Section \\\"\" + sec + \"\\\"\", end=' ')\n        if desc:\n            print(\"Description \\\"\" + desc + \"\\\"\", end=' ')\n        if field:\n            print(\"Field \\\"\" + field + \"\\\"\", end=' ')\n        print(\"size mismatch:\", s[\"size\"], \",\", d[\"size\"])\n        bump_taint()\ndef check_machine_type(s, d):",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "check_machine_type",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def check_machine_type(s, d):\n    if s[\"Name\"] != d[\"Name\"]:\n        print(\"Warning: checking incompatible machine types:\", end=' ')\n        print(\"\\\"\" + s[\"Name\"] + \"\\\", \\\"\" + d[\"Name\"] + \"\\\"\")\ndef main():\n    help_text = \"Parse JSON-formatted vmstate dumps from QEMU in files SRC and DEST.  Checks whether migration from SRC to DEST QEMU versions would break based on the VMSTATE information contained within the JSON outputs.  The JSON output is created from a QEMU invocation with the -dump-vmstate parameter and a filename argument to it.  Other parameters to QEMU do not matter, except the -M (machine type) parameter.\"\n    parser = argparse.ArgumentParser(description=help_text)\n    parser.add_argument('-s', '--src', type=argparse.FileType('r'),\n                        required=True,\n                        help='json dump from src qemu')",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "def main():\n    help_text = \"Parse JSON-formatted vmstate dumps from QEMU in files SRC and DEST.  Checks whether migration from SRC to DEST QEMU versions would break based on the VMSTATE information contained within the JSON outputs.  The JSON output is created from a QEMU invocation with the -dump-vmstate parameter and a filename argument to it.  Other parameters to QEMU do not matter, except the -M (machine type) parameter.\"\n    parser = argparse.ArgumentParser(description=help_text)\n    parser.add_argument('-s', '--src', type=argparse.FileType('r'),\n                        required=True,\n                        help='json dump from src qemu')\n    parser.add_argument('-d', '--dest', type=argparse.FileType('r'),\n                        required=True,\n                        help='json dump from dest qemu')\n    parser.add_argument('--reverse', required=False, default=False,",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "taint",
        "kind": 5,
        "importPath": "qemu.scripts.vmstate-static-checker",
        "description": "qemu.scripts.vmstate-static-checker",
        "peekOfCode": "taint = 0\ndef bump_taint():\n    global taint\n    # Ensure we don't wrap around or reset to 0 -- the shell only has\n    # an 8-bit return value.\n    if taint < 255:\n        taint = taint + 1\ndef check_fields_match(name, s_field, d_field):\n    if s_field == d_field:\n        return True",
        "detail": "qemu.scripts.vmstate-static-checker",
        "documentation": {}
    },
    {
        "label": "TestXmlPreprocess",
        "kind": 6,
        "importPath": "qemu.scripts.xml-preprocess-test",
        "description": "qemu.scripts.xml-preprocess-test",
        "peekOfCode": "class TestXmlPreprocess(unittest.TestCase):\n    \"\"\"Tests for xml-preprocess.Preprocessor\"\"\"\n    def test_preprocess_xml(self):\n        with tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as temp_file:\n            temp_file.write(\"<root></root>\")\n            temp_file_name = temp_file.name\n        result = xmlpp.preprocess_xml(temp_file_name)\n        self.assertEqual(result, \"<root></root>\")\n        os.remove(temp_file_name)\n    def test_save_xml(self):",
        "detail": "qemu.scripts.xml-preprocess-test",
        "documentation": {}
    },
    {
        "label": "xmlpp",
        "kind": 5,
        "importPath": "qemu.scripts.xml-preprocess-test",
        "description": "qemu.scripts.xml-preprocess-test",
        "peekOfCode": "xmlpp = importlib.import_module(\"xml-preprocess\")\nclass TestXmlPreprocess(unittest.TestCase):\n    \"\"\"Tests for xml-preprocess.Preprocessor\"\"\"\n    def test_preprocess_xml(self):\n        with tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as temp_file:\n            temp_file.write(\"<root></root>\")\n            temp_file_name = temp_file.name\n        result = xmlpp.preprocess_xml(temp_file_name)\n        self.assertEqual(result, \"<root></root>\")\n        os.remove(temp_file_name)",
        "detail": "qemu.scripts.xml-preprocess-test",
        "documentation": {}
    },
    {
        "label": "Preprocessor",
        "kind": 6,
        "importPath": "qemu.scripts.xml-preprocess",
        "description": "qemu.scripts.xml-preprocess",
        "peekOfCode": "class Preprocessor():\n    \"\"\"This class holds the XML preprocessing state\"\"\"\n    def __init__(self):\n        self.sys_vars = {\n            \"ARCH\": platform.architecture()[0],\n            \"SOURCE\": os.path.abspath(__file__),\n            \"CURRENT\": os.getcwd(),\n        }\n        self.cus_vars = {}\n    def _pp_include(self, xml_str: str) -> str:",
        "detail": "qemu.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "preprocess_xml",
        "kind": 2,
        "importPath": "qemu.scripts.xml-preprocess",
        "description": "qemu.scripts.xml-preprocess",
        "peekOfCode": "def preprocess_xml(path: str) -> str:\n    with open(path, \"r\", encoding=\"utf-8\") as original_file:\n        input_xml = original_file.read()\n        proc = Preprocessor()\n        return proc.preprocess(input_xml)\ndef save_xml(xml_str: str, path: Optional[str]):\n    xml = minidom.parseString(xml_str)\n    with open(path, \"w\", encoding=\"utf-8\") if path else sys.stdout as output_file:\n        output_file.write(xml.toprettyxml())\ndef main():",
        "detail": "qemu.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "save_xml",
        "kind": 2,
        "importPath": "qemu.scripts.xml-preprocess",
        "description": "qemu.scripts.xml-preprocess",
        "peekOfCode": "def save_xml(xml_str: str, path: Optional[str]):\n    xml = minidom.parseString(xml_str)\n    with open(path, \"w\", encoding=\"utf-8\") if path else sys.stdout as output_file:\n        output_file.write(xml.toprettyxml())\ndef main():\n    if len(sys.argv) < 2:\n        print(\"Usage: xml-preprocessor input.xml [output.xml]\")\n        sys.exit(1)\n    output_file = None\n    if len(sys.argv) == 3:",
        "detail": "qemu.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.scripts.xml-preprocess",
        "description": "qemu.scripts.xml-preprocess",
        "peekOfCode": "def main():\n    if len(sys.argv) < 2:\n        print(\"Usage: xml-preprocessor input.xml [output.xml]\")\n        sys.exit(1)\n    output_file = None\n    if len(sys.argv) == 3:\n        output_file = sys.argv[2]\n    input_file = sys.argv[1]\n    output_xml = preprocess_xml(input_file)\n    save_xml(output_xml, output_file)",
        "detail": "qemu.scripts.xml-preprocess",
        "documentation": {}
    },
    {
        "label": "gen_analyze_func",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_analyze_funcs",
        "description": "qemu.target.hexagon.gen_analyze_funcs",
        "peekOfCode": "def gen_analyze_func(f, tag, regs, imms):\n    f.write(f\"static void analyze_{tag}(DisasContext *ctx)\\n\")\n    f.write(\"{\\n\")\n    f.write(\"    Insn *insn G_GNUC_UNUSED = ctx->insn;\\n\")\n    if (hex_common.is_hvx_insn(tag)):\n        if hex_common.has_hvx_helper(tag):\n            f.write(\n                \"    const bool G_GNUC_UNUSED insn_has_hvx_helper = true;\\n\"\n            )\n            f.write(\"    ctx_start_hvx_insn(ctx);\\n\")",
        "detail": "qemu.target.hexagon.gen_analyze_funcs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_analyze_funcs",
        "description": "qemu.target.hexagon.gen_analyze_funcs",
        "peekOfCode": "def main():\n    args = hex_common.parse_common_args(\n        \"Emit functions analyzing register accesses\"\n    )\n    tagregs = hex_common.get_tagregs()\n    tagimms = hex_common.get_tagimms()\n    with open(args.out, \"w\") as f:\n        f.write(\"#ifndef HEXAGON_ANALYZE_FUNCS_C_INC\\n\")\n        f.write(\"#define HEXAGON_ANALYZE_FUNCS_C_INC\\n\\n\")\n        for tag in hex_common.tags:",
        "detail": "qemu.target.hexagon.gen_analyze_funcs",
        "documentation": {}
    },
    {
        "label": "ordered_unique",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "def ordered_unique(l):\n    return sorted(set(l), key=l.index)\nnum_registers = {\"R\": 32, \"V\": 32}\noperand_letters = {\n    \"P\",\n    \"i\",\n    \"I\",\n    \"r\",\n    \"s\",\n    \"t\",",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "skip_tag",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "def skip_tag(tag, class_to_decode):\n    enc_class = iset.iset[tag][\"enc_class\"]\n    return enc_class != class_to_decode\n##\n## Generate the QEMU decodetree file for each instruction in class_to_decode\n##     For A2_add: Rd32=add(Rs32,Rt32)\n##     We produce:\n##     %A2_add_Rd   0:5\n##     %A2_add_Rs   16:5\n##     %A2_add_Rt   8:5",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "gen_decodetree_file",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "def gen_decodetree_file(f, class_to_decode):\n    is_subinsn = class_to_decode.startswith(\"SUBINSN_\")\n    f.write(f\"## DO NOT MODIFY - This file is generated by {sys.argv[0]}\\n\\n\")\n    if not is_subinsn:\n        f.write(\"%PP\\t14:2\\n\\n\")\n    for tag in sorted(encs.keys(), key=iset.tags.index):\n        if skip_tag(tag, class_to_decode):\n            continue\n        enc = encs[tag]\n        enc_str = \"\".join(reversed(encs[tag]))",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        description=\"Emit opaque macro calls with instruction semantics\"\n    )\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"class_to_decode\", help=\"instruction class to decode\")\n    parser.add_argument(\"out\", help=\"output file\")\n    args = parser.parse_args()\n    hex_common.read_semantics_file(args.semantics)\n    with open(args.out, \"w\") as f:",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "encs",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "encs = {\n    tag: \"\".join(reversed(iset.iset[tag][\"enc\"].replace(\" \", \"\")))\n    for tag in iset.tags\n    if iset.iset[tag][\"enc\"] != \"MISSING ENCODING\"\n}\nregre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\ndef ordered_unique(l):\n    return sorted(set(l), key=l.index)\nnum_registers = {\"R\": 32, \"V\": 32}",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "regre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "regre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\ndef ordered_unique(l):\n    return sorted(set(l), key=l.index)\nnum_registers = {\"R\": 32, \"V\": 32}\noperand_letters = {\n    \"P\",\n    \"i\",\n    \"I\",\n    \"r\",",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "immre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "immre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\ndef ordered_unique(l):\n    return sorted(set(l), key=l.index)\nnum_registers = {\"R\": 32, \"V\": 32}\noperand_letters = {\n    \"P\",\n    \"i\",\n    \"I\",\n    \"r\",\n    \"s\",",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "num_registers",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "num_registers = {\"R\": 32, \"V\": 32}\noperand_letters = {\n    \"P\",\n    \"i\",\n    \"I\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "operand_letters",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "operand_letters = {\n    \"P\",\n    \"i\",\n    \"I\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "tags_with_unused_d_encoding",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "tags_with_unused_d_encoding = {\n    \"R6_release_at_vi\",\n    \"R6_release_st_vi\",\n    \"S4_stored_rl_at_vi\",\n    \"S4_stored_rl_st_vi\",\n    \"S2_storew_rl_at_vi\",\n    \"S2_stored_rl_at_vi\",\n    \"S2_storew_rl_st_vi\",\n}\ntags_with_unused_t_encoding = {",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "tags_with_unused_t_encoding",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_decodetree",
        "description": "qemu.target.hexagon.gen_decodetree",
        "peekOfCode": "tags_with_unused_t_encoding = {\n    \"R6_release_at_vi\",\n    \"R6_release_st_vi\",\n}\ndef skip_tag(tag, class_to_decode):\n    enc_class = iset.iset[tag][\"enc_class\"]\n    return enc_class != class_to_decode\n##\n## Generate the QEMU decodetree file for each instruction in class_to_decode\n##     For A2_add: Rd32=add(Rs32,Rt32)",
        "detail": "qemu.target.hexagon.gen_decodetree",
        "documentation": {}
    },
    {
        "label": "gen_helper_function",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_helper_funcs",
        "description": "qemu.target.hexagon.gen_helper_funcs",
        "peekOfCode": "def gen_helper_function(f, tag, tagregs, tagimms):\n    regs = tagregs[tag]\n    imms = tagimms[tag]\n    ret_type = hex_common.helper_ret_type(tag, regs).func_arg\n    declared = []\n    for arg in hex_common.helper_args(tag, regs, imms):\n        declared.append(arg.func_arg)\n    arguments = \", \".join(declared)\n    f.write(f\"{ret_type} HELPER({tag})({arguments})\\n\")\n    f.write(\"{\\n\")",
        "detail": "qemu.target.hexagon.gen_helper_funcs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_helper_funcs",
        "description": "qemu.target.hexagon.gen_helper_funcs",
        "peekOfCode": "def main():\n    args = hex_common.parse_common_args(\n        \"Emit helper function definitions for each instruction\"\n    )\n    tagregs = hex_common.get_tagregs()\n    tagimms = hex_common.get_tagimms()\n    with open(args.out, \"w\") as f:\n        for tag in hex_common.tags:\n            ## Skip the priv instructions\n            if \"A_PRIV\" in hex_common.attribdict[tag]:",
        "detail": "qemu.target.hexagon.gen_helper_funcs",
        "documentation": {}
    },
    {
        "label": "gen_helper_prototype",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_helper_protos",
        "description": "qemu.target.hexagon.gen_helper_protos",
        "peekOfCode": "def gen_helper_prototype(f, tag, tagregs, tagimms):\n    regs = tagregs[tag]\n    imms = tagimms[tag]\n    declared = []\n    ret_type = hex_common.helper_ret_type(tag, regs).proto_arg\n    declared.append(ret_type)\n    for arg in hex_common.helper_args(tag, regs, imms):\n        declared.append(arg.proto_arg)\n    arguments = \", \".join(declared)\n    ## Add the TCG_CALL_NO_RWG_SE flag to helpers that don't take the env",
        "detail": "qemu.target.hexagon.gen_helper_protos",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_helper_protos",
        "description": "qemu.target.hexagon.gen_helper_protos",
        "peekOfCode": "def main():\n    args = hex_common.parse_common_args(\n        \"Emit helper function prototypes for each instruction\"\n    )\n    tagregs = hex_common.get_tagregs()\n    tagimms = hex_common.get_tagimms()\n    with open(args.out, \"w\") as f:\n        for tag in hex_common.tags:\n            ## Skip the priv instructions\n            if \"A_PRIV\" in hex_common.attribdict[tag]:",
        "detail": "qemu.target.hexagon.gen_helper_protos",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_idef_parser_funcs",
        "description": "qemu.target.hexagon.gen_idef_parser_funcs",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        \"Emit instruction implementations that can be fed to idef-parser\"\n    )\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"out\", help=\"output file\")\n    args = parser.parse_args()\n    hex_common.read_semantics_file(args.semantics)\n    hex_common.calculate_attribs()\n    hex_common.init_registers()",
        "detail": "qemu.target.hexagon.gen_idef_parser_funcs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_op_attribs",
        "description": "qemu.target.hexagon.gen_op_attribs",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        \"Emit opaque macro calls containing instruction attributes\"\n    )\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"out\", help=\"output file\")\n    args = parser.parse_args()\n    hex_common.read_semantics_file(args.semantics)\n    hex_common.calculate_attribs()\n    ##",
        "detail": "qemu.target.hexagon.gen_op_attribs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_opcodes_def",
        "description": "qemu.target.hexagon.gen_opcodes_def",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        description=\"Emit opaque macro calls with instruction names\"\n    )\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"out\", help=\"output file\")\n    args = parser.parse_args()\n    hex_common.read_semantics_file(args.semantics)\n    ##\n    ##     Generate a list of all the opcodes",
        "detail": "qemu.target.hexagon.gen_opcodes_def",
        "documentation": {}
    },
    {
        "label": "regprinter",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_printinsn",
        "description": "qemu.target.hexagon.gen_printinsn",
        "peekOfCode": "def regprinter(m):\n    str = m.group(1)\n    str += \":\".join([\"%d\"] * len(m.group(2)))\n    str += m.group(3)\n    if (\"S\" in m.group(1)) and (len(m.group(2)) == 1):\n        str += \"/%s\"\n    elif (\"C\" in m.group(1)) and (len(m.group(2)) == 1):\n        str += \"/%s\"\n    return str\ndef spacify(s):",
        "detail": "qemu.target.hexagon.gen_printinsn",
        "documentation": {}
    },
    {
        "label": "spacify",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_printinsn",
        "description": "qemu.target.hexagon.gen_printinsn",
        "peekOfCode": "def spacify(s):\n    # Regular expression that matches any operator that contains '=' character:\n    opswithequal_re = \"[-+^&|!<>=]?=\"\n    # Regular expression that matches any assignment operator.\n    assignment_re = \"[-+^&|]?=\"\n    # Out of the operators that contain the = sign, if the operator is also an\n    # assignment, spaces will be added around it, unless it's enclosed within\n    # parentheses, or spaces are already present.\n    equals = re.compile(opswithequal_re)\n    assign = re.compile(assignment_re)",
        "detail": "qemu.target.hexagon.gen_printinsn",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_printinsn",
        "description": "qemu.target.hexagon.gen_printinsn",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        \"Emit opaque macro calls with information for printing string representations of instrucions\"\n    )\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"out\", help=\"output file\")\n    args = parser.parse_args()\n    hex_common.read_semantics_file(args.semantics)\n    immext_casere = re.compile(r\"IMMEXT\\(([A-Za-z])\")\n    with open(args.out, \"w\") as f:",
        "detail": "qemu.target.hexagon.gen_printinsn",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_tcg_func_table",
        "description": "qemu.target.hexagon.gen_tcg_func_table",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        \"Emit opaque macro calls with instruction semantics\"\n    )\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"out\", help=\"output file\")\n    args = parser.parse_args()\n    hex_common.read_semantics_file(args.semantics)\n    hex_common.calculate_attribs()\n    tagregs = hex_common.get_tagregs()",
        "detail": "qemu.target.hexagon.gen_tcg_func_table",
        "documentation": {}
    },
    {
        "label": "gen_tcg_func",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_tcg_funcs",
        "description": "qemu.target.hexagon.gen_tcg_funcs",
        "peekOfCode": "def gen_tcg_func(f, tag, regs, imms):\n    f.write(f\"static void generate_{tag}(DisasContext *ctx)\\n\")\n    f.write(\"{\\n\")\n    f.write(\"    Insn *insn G_GNUC_UNUSED = ctx->insn;\\n\")\n    if hex_common.need_ea(tag):\n        f.write(\"    TCGv EA G_GNUC_UNUSED = tcg_temp_new();\\n\")\n    ## Declare all the operands (regs and immediates)\n    i = 0\n    for regtype, regid in regs:\n        reg = hex_common.get_register(tag, regtype, regid)",
        "detail": "qemu.target.hexagon.gen_tcg_funcs",
        "documentation": {}
    },
    {
        "label": "gen_def_tcg_func",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_tcg_funcs",
        "description": "qemu.target.hexagon.gen_tcg_funcs",
        "peekOfCode": "def gen_def_tcg_func(f, tag, tagregs, tagimms):\n    regs = tagregs[tag]\n    imms = tagimms[tag]\n    gen_tcg_func(f, tag, regs, imms)\ndef main():\n    args = hex_common.parse_common_args(\n        \"Emit functions calling generated code implementing instruction semantics (helpers, idef-parser)\"\n    )\n    tagregs = hex_common.get_tagregs()\n    tagimms = hex_common.get_tagimms()",
        "detail": "qemu.target.hexagon.gen_tcg_funcs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_tcg_funcs",
        "description": "qemu.target.hexagon.gen_tcg_funcs",
        "peekOfCode": "def main():\n    args = hex_common.parse_common_args(\n        \"Emit functions calling generated code implementing instruction semantics (helpers, idef-parser)\"\n    )\n    tagregs = hex_common.get_tagregs()\n    tagimms = hex_common.get_tagimms()\n    with open(args.out, \"w\") as f:\n        f.write(\"#ifndef HEXAGON_TCG_FUNCS_H\\n\")\n        f.write(\"#define HEXAGON_TCG_FUNCS_H\\n\\n\")\n        if args.idef_parser:",
        "detail": "qemu.target.hexagon.gen_tcg_funcs",
        "documentation": {}
    },
    {
        "label": "ordered_unique",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "def ordered_unique(l):\n    return sorted(set(l), key=l.index)\ndef code_fmt(txt):\n    return textwrap.indent(textwrap.dedent(txt), \"    \")\nopen_curly = \"{\"\nclose_curly = \"}\"\ndef mark_which_imm_extended(f, tag):\n    immre = re.compile(r\"IMMEXT\\([rRsSuUm]\")\n    imm = immre.findall(hex_common.semdict[tag])\n    if len(imm) == 0:",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "code_fmt",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "def code_fmt(txt):\n    return textwrap.indent(textwrap.dedent(txt), \"    \")\nopen_curly = \"{\"\nclose_curly = \"}\"\ndef mark_which_imm_extended(f, tag):\n    immre = re.compile(r\"IMMEXT\\([rRsSuUm]\")\n    imm = immre.findall(hex_common.semdict[tag])\n    if len(imm) == 0:\n        # No extended operand found\n        return",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "mark_which_imm_extended",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "def mark_which_imm_extended(f, tag):\n    immre = re.compile(r\"IMMEXT\\([rRsSuUm]\")\n    imm = immre.findall(hex_common.semdict[tag])\n    if len(imm) == 0:\n        # No extended operand found\n        return\n    letter = re.split(\"\\\\(\", imm[0])[1]\n    f.write(code_fmt(f\"\"\"\\\n        insn->which_extended = {0 if letter.islower() else 1};\n    \"\"\"))",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "gen_trans_funcs",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "def gen_trans_funcs(f):\n    f.write(f\"/* DO NOT MODIFY - This file is generated by {sys.argv[0]} */\\n\\n\")\n    for tag in sorted(encs.keys(), key=iset.tags.index):\n        regs = ordered_unique(regre.findall(iset.iset[tag][\"syntax\"]))\n        imms = ordered_unique(immre.findall(iset.iset[tag][\"syntax\"]))\n        f.write(textwrap.dedent(f\"\"\"\\\n            static bool trans_{tag}(DisasContext *ctx, arg_{tag} *args)\n            {open_curly}\n                Insn *insn = ctx->insn;\n                insn->opcode = {tag};",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        description=\"Emit trans_*() functions to be called by \" \\\n                    \"instruction decoder\"\n    )\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"out\", help=\"output file\")\n    args = parser.parse_args()\n    hex_common.read_semantics_file(args.semantics)\n    hex_common.init_registers()",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "encs",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "encs = {\n    tag: \"\".join(reversed(iset.iset[tag][\"enc\"].replace(\" \", \"\")))\n    for tag in iset.tags\n    if iset.iset[tag][\"enc\"] != \"MISSING ENCODING\"\n}\nregre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\ndef ordered_unique(l):\n    return sorted(set(l), key=l.index)\ndef code_fmt(txt):",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "regre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "regre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\ndef ordered_unique(l):\n    return sorted(set(l), key=l.index)\ndef code_fmt(txt):\n    return textwrap.indent(textwrap.dedent(txt), \"    \")\nopen_curly = \"{\"\nclose_curly = \"}\"\ndef mark_which_imm_extended(f, tag):\n    immre = re.compile(r\"IMMEXT\\([rRsSuUm]\")",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "immre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "immre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\ndef ordered_unique(l):\n    return sorted(set(l), key=l.index)\ndef code_fmt(txt):\n    return textwrap.indent(textwrap.dedent(txt), \"    \")\nopen_curly = \"{\"\nclose_curly = \"}\"\ndef mark_which_imm_extended(f, tag):\n    immre = re.compile(r\"IMMEXT\\([rRsSuUm]\")\n    imm = immre.findall(hex_common.semdict[tag])",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "open_curly",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "open_curly = \"{\"\nclose_curly = \"}\"\ndef mark_which_imm_extended(f, tag):\n    immre = re.compile(r\"IMMEXT\\([rRsSuUm]\")\n    imm = immre.findall(hex_common.semdict[tag])\n    if len(imm) == 0:\n        # No extended operand found\n        return\n    letter = re.split(\"\\\\(\", imm[0])[1]\n    f.write(code_fmt(f\"\"\"\\",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "close_curly",
        "kind": 5,
        "importPath": "qemu.target.hexagon.gen_trans_funcs",
        "description": "qemu.target.hexagon.gen_trans_funcs",
        "peekOfCode": "close_curly = \"}\"\ndef mark_which_imm_extended(f, tag):\n    immre = re.compile(r\"IMMEXT\\([rRsSuUm]\")\n    imm = immre.findall(hex_common.semdict[tag])\n    if len(imm) == 0:\n        # No extended operand found\n        return\n    letter = re.split(\"\\\\(\", imm[0])[1]\n    f.write(code_fmt(f\"\"\"\\\n        insn->which_extended = {0 if letter.islower() else 1};",
        "detail": "qemu.target.hexagon.gen_trans_funcs",
        "documentation": {}
    },
    {
        "label": "Macro",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Macro(object):\n    __slots__ = [\"key\", \"name\", \"beh\", \"attribs\", \"re\"]\n    def __init__(self, name, beh, attribs):\n        self.key = name\n        self.name = name\n        self.beh = beh\n        self.attribs = set(attribs)\n        self.re = re.compile(\"\\\\b\" + name + \"\\\\b\")\ndef MACROATTRIB(macname, beh, attribstring):\n    attribstring = attribstring.replace(\"(\", \"\").replace(\")\", \"\")",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "HelperArg",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class HelperArg:\n    def __init__(self, proto_arg, call_arg, func_arg):\n        self.proto_arg = proto_arg\n        self.call_arg = call_arg\n        self.func_arg = func_arg\nclass Register:\n    def __init__(self, regtype, regid):\n        self.regtype = regtype\n        self.regid = regid\n        self.reg_num = f\"{regtype}{regid}N\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "Register",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Register:\n    def __init__(self, regtype, regid):\n        self.regtype = regtype\n        self.regid = regid\n        self.reg_num = f\"{regtype}{regid}N\"\n    def decl_reg_num(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            const int {self.reg_num} = insn->regno[{regno}];\n        \"\"\"))\n    def idef_arg(self, declared):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "Scalar",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Scalar:\n    def is_scalar_reg(self):\n        return True\n    def is_hvx_reg(self):\n        return False\n    def helper_arg_name(self):\n        return self.reg_tcg()\nclass Single(Scalar):\n    def helper_proto_type(self):\n        return \"s32\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "Single",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Single(Scalar):\n    def helper_proto_type(self):\n        return \"s32\"\n    def helper_arg_type(self):\n        return \"int32_t\"\nclass Pair(Scalar):\n    def helper_proto_type(self):\n        return \"s64\"\n    def helper_arg_type(self):\n        return \"int64_t\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "Pair",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Pair(Scalar):\n    def helper_proto_type(self):\n        return \"s64\"\n    def helper_arg_type(self):\n        return \"int64_t\"\nclass Hvx:\n    def is_scalar_reg(self):\n        return False\n    def is_hvx_reg(self):\n        return True",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "Hvx",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Hvx:\n    def is_scalar_reg(self):\n        return False\n    def is_hvx_reg(self):\n        return True\n    def hvx_off(self):\n        return f\"{self.reg_tcg()}_off\"\n    def helper_proto_type(self):\n        return \"ptr\"\n    def helper_arg_type(self):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "Dest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Dest:\n    def reg_tcg(self):\n        return f\"{self.regtype}{self.regid}V\"\n    def is_written(self):\n        return True\n    def is_writeonly(self):\n        return True\n    def is_read(self):\n        return False\n    def is_readwrite(self):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "Source",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class Source:\n    def is_written(self):\n        return False\n    def is_writeonly(self):\n        return False\n    def is_read(self):\n        return True\n    def is_readwrite(self):\n        return False\nclass OldSource(Source):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "OldSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class OldSource(Source):\n    def reg_tcg(self):\n        return f\"{self.regtype}{self.regid}V\"\n    def is_old(self):\n        return True\n    def is_new(self):\n        return False\nclass NewSource(Source):\n    def reg_tcg(self):\n        return f\"{self.regtype}{self.regid}N\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "NewSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class NewSource(Source):\n    def reg_tcg(self):\n        return f\"{self.regtype}{self.regid}N\"\n    def is_old(self):\n        return False\n    def is_new(self):\n        return True\nclass ReadWrite:\n    def reg_tcg(self):\n        return f\"{self.regtype}{self.regid}V\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "ReadWrite",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class ReadWrite:\n    def reg_tcg(self):\n        return f\"{self.regtype}{self.regid}V\"\n    def is_written(self):\n        return True\n    def is_writeonly(self):\n        return False\n    def is_read(self):\n        return True\n    def is_readwrite(self):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "GprDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class GprDest(Register, Single, Dest):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = get_result_gpr(ctx, {self.reg_num});\n        \"\"\"))\n    def log_write(self, f, tag):\n        f.write(code_fmt(f\"\"\"\\\n            gen_log_reg_write(ctx, {self.reg_num}, {self.reg_tcg()});\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "GprSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class GprSource(Register, Single, OldSource):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = hex_gpr[{self.reg_num}];\n        \"\"\"))\n    def analyze_read(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            ctx_log_reg_read(ctx, {self.reg_num});\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "GprNewSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class GprNewSource(Register, Single, NewSource):\n    def decl_tcg(self, f, tag, regno):\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = get_result_gpr(ctx, insn->regno[{regno}]);\n        \"\"\"))\n    def analyze_read(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            ctx_log_reg_read_new(ctx, {self.reg_num});\n        \"\"\"))\nclass GprReadWrite(Register, Single, ReadWrite):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "GprReadWrite",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class GprReadWrite(Register, Single, ReadWrite):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = get_result_gpr(ctx, {self.reg_num});\n        \"\"\"))\n        ## For read/write registers, we need to get the original value into\n        ## the result TCGv.  For predicated instructions, this is done in\n        ## gen_start_packet.  For un-predicated instructions, we do it here.\n        if not is_predicated(tag):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "ControlDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class ControlDest(Register, Single, Dest):\n    def decl_reg_num(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            const int {self.reg_num} = insn->regno[{regno}]  + HEX_REG_SA0;\n        \"\"\"))\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = get_result_gpr(ctx, {self.reg_num});\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "ControlSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class ControlSource(Register, Single, OldSource):\n    def decl_reg_num(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            const int {self.reg_num} = insn->regno[{regno}]  + HEX_REG_SA0;\n        \"\"\"))\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno);\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = tcg_temp_new();\n            gen_read_ctrl_reg(ctx, {self.reg_num}, {self.reg_tcg()});",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "ModifierSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class ModifierSource(Register, Single, OldSource):\n    def decl_reg_num(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            const int {self.reg_num} = insn->regno[{regno}] + HEX_REG_M0;\n        \"\"\"))\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = hex_gpr[{self.reg_num}];\n            TCGv CS G_GNUC_UNUSED =",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "PredDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class PredDest(Register, Single, Dest):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = tcg_temp_new();\n        \"\"\"))\n    def log_write(self, f, tag):\n        f.write(code_fmt(f\"\"\"\\\n            gen_log_pred_write(ctx, {self.reg_num}, {self.reg_tcg()});\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "PredSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class PredSource(Register, Single, OldSource):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = hex_pred[{self.reg_num}];\n        \"\"\"))\n    def analyze_read(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            ctx_log_pred_read(ctx, {self.reg_num});\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "PredNewSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class PredNewSource(Register, Single, NewSource):\n    def decl_tcg(self, f, tag, regno):\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = get_result_pred(ctx, insn->regno[{regno}]);\n        \"\"\"))\n    def analyze_read(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            ctx_log_pred_read_new(ctx, {self.reg_num});\n        \"\"\"))\nclass PredReadWrite(Register, Single, ReadWrite):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "PredReadWrite",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class PredReadWrite(Register, Single, ReadWrite):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv {self.reg_tcg()} = tcg_temp_new();\n            tcg_gen_mov_tl({self.reg_tcg()}, hex_pred[{self.reg_num}]);\n        \"\"\"))\n    def log_write(self, f, tag):\n        f.write(code_fmt(f\"\"\"\\\n            gen_log_pred_write(ctx, {self.reg_num}, {self.reg_tcg()});",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "PairDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class PairDest(Register, Pair, Dest):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv_i64 {self.reg_tcg()} =\n                get_result_gpr_pair(ctx, {self.reg_num});\n        \"\"\"))\n    def log_write(self, f, tag):\n        f.write(code_fmt(f\"\"\"\\\n            gen_log_reg_write_pair(ctx, {self.reg_num}, {self.reg_tcg()});",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "PairSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class PairSource(Register, Pair, OldSource):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv_i64 {self.reg_tcg()} = tcg_temp_new_i64();\n            tcg_gen_concat_i32_i64({self.reg_tcg()},\n                                    hex_gpr[{self.reg_num}],\n                                    hex_gpr[{self.reg_num} + 1]);\n        \"\"\"))\n    def analyze_read(self, f, regno):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "PairReadWrite",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class PairReadWrite(Register, Pair, ReadWrite):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv_i64 {self.reg_tcg()} =\n                get_result_gpr_pair(ctx, {self.reg_num});\n            tcg_gen_concat_i32_i64({self.reg_tcg()},\n                                   hex_gpr[{self.reg_num}],\n                                   hex_gpr[{self.reg_num} + 1]);\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "ControlPairDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class ControlPairDest(Register, Pair, Dest):\n    def decl_reg_num(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            const int {self.reg_num} = insn->regno[{regno}] + HEX_REG_SA0;\n        \"\"\"))\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv_i64 {self.reg_tcg()} =\n                get_result_gpr_pair(ctx, {self.reg_num});",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "ControlPairSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class ControlPairSource(Register, Pair, OldSource):\n    def decl_reg_num(self, f, regno):\n        f.write(code_fmt(f\"\"\"\\\n            const int {self.reg_num} = insn->regno[{regno}] + HEX_REG_SA0;\n        \"\"\"))\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            TCGv_i64 {self.reg_tcg()} = tcg_temp_new_i64();\n            gen_read_ctrl_reg_pair(ctx, {self.reg_num}, {self.reg_tcg()});",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegDest(Register, Hvx, Dest):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                {vreg_offset_func(tag)}(ctx, {self.reg_num}, 1, true);\n        \"\"\"))\n        if not skip_qemu_helper(tag):\n            f.write(code_fmt(f\"\"\"\\\n                TCGv_ptr {self.reg_tcg()} = tcg_temp_new_ptr();",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegSource(Register, Hvx, OldSource):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} = vreg_src_off(ctx, {self.reg_num});\n        \"\"\"))\n        if not skip_qemu_helper(tag):\n            f.write(code_fmt(f\"\"\"\\\n                TCGv_ptr {self.reg_tcg()} = tcg_temp_new_ptr();\n                tcg_gen_addi_ptr({self.reg_tcg()}, tcg_env, {self.hvx_off()});",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegNewSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegNewSource(Register, Hvx, NewSource):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        if skip_qemu_helper(tag):\n            f.write(code_fmt(f\"\"\"\\\n                const intptr_t {self.hvx_off()} =\n                    ctx_future_vreg_off(ctx, {self.reg_num}, 1, true);\n            \"\"\"))\n    def helper_hvx_desc(self, f):\n        f.write(code_fmt(f\"\"\"\\",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegReadWrite",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegReadWrite(Register, Hvx, ReadWrite):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                {vreg_offset_func(tag)}(ctx, {self.reg_num}, 1, true);\n            tcg_gen_gvec_mov(MO_64, {self.hvx_off()},\n                             vreg_src_off(ctx, {self.reg_num}),\n                             sizeof(MMVector), sizeof(MMVector));\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegTmp",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegTmp(Register, Hvx, ReadWrite):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} = offsetof(CPUHexagonState, vtmp);\n        \"\"\"))\n        if not skip_qemu_helper(tag):\n            f.write(code_fmt(f\"\"\"\\\n                TCGv_ptr {self.reg_tcg()} = tcg_temp_new_ptr();\n                tcg_gen_addi_ptr({self.reg_tcg()}, tcg_env, {self.hvx_off()});",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegPairDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegPairDest(Register, Hvx, Dest):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                {vreg_offset_func(tag)}(ctx, {self.reg_num}, 2, true);\n        \"\"\"))\n        if not skip_qemu_helper(tag):\n            f.write(code_fmt(f\"\"\"\\\n                TCGv_ptr {self.reg_tcg()} = tcg_temp_new_ptr();",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegPairSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegPairSource(Register, Hvx, OldSource):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                offsetof(CPUHexagonState, {self.reg_tcg()});\n            tcg_gen_gvec_mov(MO_64, {self.hvx_off()},\n                             vreg_src_off(ctx, {self.reg_num}),\n                             sizeof(MMVector), sizeof(MMVector));\n            tcg_gen_gvec_mov(MO_64, {self.hvx_off()} + sizeof(MMVector),",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "VRegPairReadWrite",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class VRegPairReadWrite(Register, Hvx, ReadWrite):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                offsetof(CPUHexagonState, {self.reg_tcg()});\n            tcg_gen_gvec_mov(MO_64, {self.hvx_off()},\n                             vreg_src_off(ctx, {self.reg_num}),\n                             sizeof(MMVector), sizeof(MMVector));\n            tcg_gen_gvec_mov(MO_64, {self.hvx_off()} + sizeof(MMVector),",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "QRegDest",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class QRegDest(Register, Hvx, Dest):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                get_result_qreg(ctx, {self.reg_num});\n        \"\"\"))\n        if not skip_qemu_helper(tag):\n            f.write(code_fmt(f\"\"\"\\\n                TCGv_ptr {self.reg_tcg()} = tcg_temp_new_ptr();",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "QRegSource",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class QRegSource(Register, Hvx, OldSource):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                offsetof(CPUHexagonState, QRegs[{self.reg_num}]);\n        \"\"\"))\n        if not skip_qemu_helper(tag):\n            f.write(code_fmt(f\"\"\"\\\n                TCGv_ptr {self.reg_tcg()} = tcg_temp_new_ptr();",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "QRegReadWrite",
        "kind": 6,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "class QRegReadWrite(Register, Hvx, ReadWrite):\n    def decl_tcg(self, f, tag, regno):\n        self.decl_reg_num(f, regno)\n        f.write(code_fmt(f\"\"\"\\\n            const intptr_t {self.hvx_off()} =\n                get_result_qreg(ctx, {self.reg_num});\n            tcg_gen_gvec_mov(MO_64, {self.hvx_off()},\n                             offsetof(CPUHexagonState, QRegs[{self.reg_num}]),\n                             sizeof(MMQReg), sizeof(MMQReg));\n        \"\"\"))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "uniquify",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def uniquify(seq):\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if x not in seen and not seen_add(x)]\nregre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\nreg_or_immre = re.compile(\n    r\"(((?<!DUP)[MNRCOPQXSGVZA])([stuvwxyzdefg]+)\"\n    r\"([.]?[LlHh]?)(\\d+S?))|([#]([rRsSuUm])(\\d+)[:]?(\\d+)?)\"\n)",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "expand_macro_attribs",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def expand_macro_attribs(macro, allmac_re):\n    if macro.key not in finished_macros:\n        # Get a list of all things that might be macros\n        l = allmac_re.findall(macro.beh)\n        for submacro in l:\n            if not submacro:\n                continue\n            if not macros[submacro]:\n                raise Exception(f\"Couldn't find macro: <{l}>\")\n            macro.attribs |= expand_macro_attribs(macros[submacro], allmac_re)",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "add_qemu_macro_attrib",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def add_qemu_macro_attrib(name, attrib):\n    macros[name].attribs.add(attrib)\nimmextre = re.compile(r\"f(MUST_)?IMMEXT[(]([UuSsRr])\")\ndef is_cond_jump(tag):\n    if tag == \"J2_rte\":\n        return False\n    if \"A_HWLOOP0_END\" in attribdict[tag] or \"A_HWLOOP1_END\" in attribdict[tag]:\n        return False\n    return re.compile(r\"(if.*fBRANCH)|(if.*fJUMPR)\").search(semdict[tag]) != None\ndef is_cond_call(tag):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "is_cond_jump",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def is_cond_jump(tag):\n    if tag == \"J2_rte\":\n        return False\n    if \"A_HWLOOP0_END\" in attribdict[tag] or \"A_HWLOOP1_END\" in attribdict[tag]:\n        return False\n    return re.compile(r\"(if.*fBRANCH)|(if.*fJUMPR)\").search(semdict[tag]) != None\ndef is_cond_call(tag):\n    return re.compile(r\"(if.*fCALL)\").search(semdict[tag]) != None\ndef calculate_attribs():\n    add_qemu_macro_attrib(\"fREAD_PC\", \"A_IMPLICIT_READS_PC\")",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "is_cond_call",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def is_cond_call(tag):\n    return re.compile(r\"(if.*fCALL)\").search(semdict[tag]) != None\ndef calculate_attribs():\n    add_qemu_macro_attrib(\"fREAD_PC\", \"A_IMPLICIT_READS_PC\")\n    add_qemu_macro_attrib(\"fTRAP\", \"A_IMPLICIT_READS_PC\")\n    add_qemu_macro_attrib(\"fSET_OVERFLOW\", \"A_IMPLICIT_WRITES_USR\")\n    add_qemu_macro_attrib(\"fSET_LPCFG\", \"A_IMPLICIT_WRITES_USR\")\n    add_qemu_macro_attrib(\"fLOAD\", \"A_SCALAR_LOAD\")\n    add_qemu_macro_attrib(\"fSTORE\", \"A_SCALAR_STORE\")\n    add_qemu_macro_attrib('fLSBNEW0', 'A_IMPLICIT_READS_P0')",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "calculate_attribs",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def calculate_attribs():\n    add_qemu_macro_attrib(\"fREAD_PC\", \"A_IMPLICIT_READS_PC\")\n    add_qemu_macro_attrib(\"fTRAP\", \"A_IMPLICIT_READS_PC\")\n    add_qemu_macro_attrib(\"fSET_OVERFLOW\", \"A_IMPLICIT_WRITES_USR\")\n    add_qemu_macro_attrib(\"fSET_LPCFG\", \"A_IMPLICIT_WRITES_USR\")\n    add_qemu_macro_attrib(\"fLOAD\", \"A_SCALAR_LOAD\")\n    add_qemu_macro_attrib(\"fSTORE\", \"A_SCALAR_STORE\")\n    add_qemu_macro_attrib('fLSBNEW0', 'A_IMPLICIT_READS_P0')\n    add_qemu_macro_attrib('fLSBNEW0NOT', 'A_IMPLICIT_READS_P0')\n    add_qemu_macro_attrib('fREAD_P0', 'A_IMPLICIT_READS_P0')",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "SEMANTICS",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def SEMANTICS(tag, beh, sem):\n    # print tag,beh,sem\n    behdict[tag] = beh\n    semdict[tag] = sem\n    attribdict[tag] = set()\n    tags.append(tag)  # dicts have no order, this is for order\ndef ATTRIBUTES(tag, attribstring):\n    attribstring = attribstring.replace(\"ATTRIBS\", \"\").replace(\"(\", \"\").replace(\")\", \"\")\n    if not attribstring:\n        return",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "ATTRIBUTES",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def ATTRIBUTES(tag, attribstring):\n    attribstring = attribstring.replace(\"ATTRIBS\", \"\").replace(\"(\", \"\").replace(\")\", \"\")\n    if not attribstring:\n        return\n    attribs = attribstring.split(\",\")\n    for attrib in attribs:\n        attribdict[tag].add(attrib.strip())\nclass Macro(object):\n    __slots__ = [\"key\", \"name\", \"beh\", \"attribs\", \"re\"]\n    def __init__(self, name, beh, attribs):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "MACROATTRIB",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def MACROATTRIB(macname, beh, attribstring):\n    attribstring = attribstring.replace(\"(\", \"\").replace(\")\", \"\")\n    if attribstring:\n        attribs = attribstring.split(\",\")\n    else:\n        attribs = []\n    macros[macname] = Macro(macname, beh, attribs)\ndef compute_tag_regs(tag, full):\n    tagregs = regre.findall(behdict[tag])\n    if not full:",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "compute_tag_regs",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def compute_tag_regs(tag, full):\n    tagregs = regre.findall(behdict[tag])\n    if not full:\n        tagregs = map(lambda reg: reg[:2], tagregs)\n    return uniquify(tagregs)\ndef compute_tag_immediates(tag):\n    return uniquify(immre.findall(behdict[tag]))\n##\n##  tagregs is the main data structure we'll use\n##  tagregs[tag] will contain the registers used by an instruction",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "compute_tag_immediates",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def compute_tag_immediates(tag):\n    return uniquify(immre.findall(behdict[tag]))\n##\n##  tagregs is the main data structure we'll use\n##  tagregs[tag] will contain the registers used by an instruction\n##  Within each entry, we'll use the regtype and regid fields\n##      regtype can be one of the following\n##          C                control register\n##          N                new register value\n##          P                predicate register",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "get_tagregs",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def get_tagregs(full=False):\n    compute_func = lambda tag: compute_tag_regs(tag, full)\n    return dict(zip(tags, list(map(compute_func, tags))))\ndef get_tagimms():\n    return dict(zip(tags, list(map(compute_tag_immediates, tags))))\ndef need_p0(tag):\n    return \"A_IMPLICIT_READS_P0\" in attribdict[tag]\ndef need_sp(tag):\n    return \"A_IMPLICIT_READS_SP\" in attribdict[tag]\ndef is_hvx_insn(tag):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "get_tagimms",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def get_tagimms():\n    return dict(zip(tags, list(map(compute_tag_immediates, tags))))\ndef need_p0(tag):\n    return \"A_IMPLICIT_READS_P0\" in attribdict[tag]\ndef need_sp(tag):\n    return \"A_IMPLICIT_READS_SP\" in attribdict[tag]\ndef is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef need_env(tag):\n    return (\"A_STORE\" in attribdict[tag] or",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_p0",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_p0(tag):\n    return \"A_IMPLICIT_READS_P0\" in attribdict[tag]\ndef need_sp(tag):\n    return \"A_IMPLICIT_READS_SP\" in attribdict[tag]\ndef is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef need_env(tag):\n    return (\"A_STORE\" in attribdict[tag] or\n            \"A_LOAD\" in attribdict[tag] or\n            \"A_CVI_GATHER\" in attribdict[tag] or",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_sp",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_sp(tag):\n    return \"A_IMPLICIT_READS_SP\" in attribdict[tag]\ndef is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef need_env(tag):\n    return (\"A_STORE\" in attribdict[tag] or\n            \"A_LOAD\" in attribdict[tag] or\n            \"A_CVI_GATHER\" in attribdict[tag] or\n            \"A_CVI_SCATTER\" in attribdict[tag] or\n            \"A_IMPLICIT_WRITES_USR\" in attribdict[tag])",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "is_hvx_insn",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef need_env(tag):\n    return (\"A_STORE\" in attribdict[tag] or\n            \"A_LOAD\" in attribdict[tag] or\n            \"A_CVI_GATHER\" in attribdict[tag] or\n            \"A_CVI_SCATTER\" in attribdict[tag] or\n            \"A_IMPLICIT_WRITES_USR\" in attribdict[tag])\ndef need_slot(tag):\n    if (",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_env",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_env(tag):\n    return (\"A_STORE\" in attribdict[tag] or\n            \"A_LOAD\" in attribdict[tag] or\n            \"A_CVI_GATHER\" in attribdict[tag] or\n            \"A_CVI_SCATTER\" in attribdict[tag] or\n            \"A_IMPLICIT_WRITES_USR\" in attribdict[tag])\ndef need_slot(tag):\n    if (\n        \"A_CVI_SCATTER\" not in attribdict[tag]\n        and \"A_CVI_GATHER\" not in attribdict[tag]",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_slot",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_slot(tag):\n    if (\n        \"A_CVI_SCATTER\" not in attribdict[tag]\n        and \"A_CVI_GATHER\" not in attribdict[tag]\n        and (\"A_STORE\" in attribdict[tag]\n             or \"A_LOAD\" in attribdict[tag])\n    ):\n        return 1\n    else:\n        return 0",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_part1",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_part1(tag):\n    return re.compile(r\"fPART1\").search(semdict[tag])\ndef need_ea(tag):\n    return re.compile(r\"\\bEA\\b\").search(semdict[tag])\ndef need_PC(tag):\n    return \"A_IMPLICIT_READS_PC\" in attribdict[tag]\ndef need_next_PC(tag):\n    return \"A_CALL\" in attribdict[tag]\ndef need_pkt_has_multi_cof(tag):\n    return \"A_COF\" in attribdict[tag]",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_ea",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_ea(tag):\n    return re.compile(r\"\\bEA\\b\").search(semdict[tag])\ndef need_PC(tag):\n    return \"A_IMPLICIT_READS_PC\" in attribdict[tag]\ndef need_next_PC(tag):\n    return \"A_CALL\" in attribdict[tag]\ndef need_pkt_has_multi_cof(tag):\n    return \"A_COF\" in attribdict[tag]\ndef need_pkt_need_commit(tag):\n    return 'A_IMPLICIT_WRITES_USR' in attribdict[tag]",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_PC",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_PC(tag):\n    return \"A_IMPLICIT_READS_PC\" in attribdict[tag]\ndef need_next_PC(tag):\n    return \"A_CALL\" in attribdict[tag]\ndef need_pkt_has_multi_cof(tag):\n    return \"A_COF\" in attribdict[tag]\ndef need_pkt_need_commit(tag):\n    return 'A_IMPLICIT_WRITES_USR' in attribdict[tag]\ndef skip_qemu_helper(tag):\n    return tag in overrides.keys()",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_next_PC",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_next_PC(tag):\n    return \"A_CALL\" in attribdict[tag]\ndef need_pkt_has_multi_cof(tag):\n    return \"A_COF\" in attribdict[tag]\ndef need_pkt_need_commit(tag):\n    return 'A_IMPLICIT_WRITES_USR' in attribdict[tag]\ndef skip_qemu_helper(tag):\n    return tag in overrides.keys()\ndef is_idef_parser_enabled(tag):\n    return tag in idef_parser_enabled",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_pkt_has_multi_cof",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_pkt_has_multi_cof(tag):\n    return \"A_COF\" in attribdict[tag]\ndef need_pkt_need_commit(tag):\n    return 'A_IMPLICIT_WRITES_USR' in attribdict[tag]\ndef skip_qemu_helper(tag):\n    return tag in overrides.keys()\ndef is_idef_parser_enabled(tag):\n    return tag in idef_parser_enabled\ndef is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "need_pkt_need_commit",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def need_pkt_need_commit(tag):\n    return 'A_IMPLICIT_WRITES_USR' in attribdict[tag]\ndef skip_qemu_helper(tag):\n    return tag in overrides.keys()\ndef is_idef_parser_enabled(tag):\n    return tag in idef_parser_enabled\ndef is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef has_hvx_helper(tag):\n    return (is_hvx_insn(tag) and",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "skip_qemu_helper",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def skip_qemu_helper(tag):\n    return tag in overrides.keys()\ndef is_idef_parser_enabled(tag):\n    return tag in idef_parser_enabled\ndef is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef has_hvx_helper(tag):\n    return (is_hvx_insn(tag) and\n            not skip_qemu_helper(tag) and\n            not is_idef_parser_enabled(tag))",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "is_idef_parser_enabled",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def is_idef_parser_enabled(tag):\n    return tag in idef_parser_enabled\ndef is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef has_hvx_helper(tag):\n    return (is_hvx_insn(tag) and\n            not skip_qemu_helper(tag) and\n            not is_idef_parser_enabled(tag))\ndef imm_name(immlett):\n    return f\"{immlett}iV\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "is_hvx_insn",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def is_hvx_insn(tag):\n    return \"A_CVI\" in attribdict[tag]\ndef has_hvx_helper(tag):\n    return (is_hvx_insn(tag) and\n            not skip_qemu_helper(tag) and\n            not is_idef_parser_enabled(tag))\ndef imm_name(immlett):\n    return f\"{immlett}iV\"\ndef read_semantics_file(name):\n    eval_line = \"\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "has_hvx_helper",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def has_hvx_helper(tag):\n    return (is_hvx_insn(tag) and\n            not skip_qemu_helper(tag) and\n            not is_idef_parser_enabled(tag))\ndef imm_name(immlett):\n    return f\"{immlett}iV\"\ndef read_semantics_file(name):\n    eval_line = \"\"\n    for line in open(name, \"rt\").readlines():\n        if not line.startswith(\"#\"):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "imm_name",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def imm_name(immlett):\n    return f\"{immlett}iV\"\ndef read_semantics_file(name):\n    eval_line = \"\"\n    for line in open(name, \"rt\").readlines():\n        if not line.startswith(\"#\"):\n            eval_line += line\n            if line.endswith(\"\\\\\\n\"):\n                eval_line.rstrip(\"\\\\\\n\")\n            else:",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "read_semantics_file",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def read_semantics_file(name):\n    eval_line = \"\"\n    for line in open(name, \"rt\").readlines():\n        if not line.startswith(\"#\"):\n            eval_line += line\n            if line.endswith(\"\\\\\\n\"):\n                eval_line.rstrip(\"\\\\\\n\")\n            else:\n                eval(eval_line.strip())\n                eval_line = \"\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "read_overrides_file",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def read_overrides_file(name):\n    overridere = re.compile(r\"#define fGEN_TCG_([A-Za-z0-9_]+)\\(.*\")\n    for line in open(name, \"rt\").readlines():\n        if not overridere.match(line):\n            continue\n        tag = overridere.findall(line)[0]\n        overrides[tag] = True\ndef read_idef_parser_enabled_file(name):\n    global idef_parser_enabled\n    with open(name, \"r\") as idef_parser_enabled_file:",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "read_idef_parser_enabled_file",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def read_idef_parser_enabled_file(name):\n    global idef_parser_enabled\n    with open(name, \"r\") as idef_parser_enabled_file:\n        lines = idef_parser_enabled_file.read().strip().split(\"\\n\")\n        idef_parser_enabled = set(lines)\ndef is_predicated(tag):\n    return \"A_CONDEXEC\" in attribdict[tag]\ndef code_fmt(txt):\n    return textwrap.indent(textwrap.dedent(txt), \"    \")\ndef hvx_newv(tag):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "is_predicated",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def is_predicated(tag):\n    return \"A_CONDEXEC\" in attribdict[tag]\ndef code_fmt(txt):\n    return textwrap.indent(textwrap.dedent(txt), \"    \")\ndef hvx_newv(tag):\n    if \"A_CVI_NEW\" in attribdict[tag]:\n        return \"EXT_NEW\"\n    elif \"A_CVI_TMP\" in attribdict[tag] or \"A_CVI_TMP_DST\" in attribdict[tag]:\n        return \"EXT_TMP\"\n    else:",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "code_fmt",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def code_fmt(txt):\n    return textwrap.indent(textwrap.dedent(txt), \"    \")\ndef hvx_newv(tag):\n    if \"A_CVI_NEW\" in attribdict[tag]:\n        return \"EXT_NEW\"\n    elif \"A_CVI_TMP\" in attribdict[tag] or \"A_CVI_TMP_DST\" in attribdict[tag]:\n        return \"EXT_TMP\"\n    else:\n        return \"EXT_DFL\"\ndef vreg_offset_func(tag):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "hvx_newv",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def hvx_newv(tag):\n    if \"A_CVI_NEW\" in attribdict[tag]:\n        return \"EXT_NEW\"\n    elif \"A_CVI_TMP\" in attribdict[tag] or \"A_CVI_TMP_DST\" in attribdict[tag]:\n        return \"EXT_TMP\"\n    else:\n        return \"EXT_DFL\"\ndef vreg_offset_func(tag):\n    if \"A_CVI_TMP\" in attribdict[tag] or \"A_CVI_TMP_DST\" in attribdict[tag]:\n        return \"ctx_tmp_vreg_off\"",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "vreg_offset_func",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def vreg_offset_func(tag):\n    if \"A_CVI_TMP\" in attribdict[tag] or \"A_CVI_TMP_DST\" in attribdict[tag]:\n        return \"ctx_tmp_vreg_off\"\n    else:\n        return \"ctx_future_vreg_off\"\nclass HelperArg:\n    def __init__(self, proto_arg, call_arg, func_arg):\n        self.proto_arg = proto_arg\n        self.call_arg = call_arg\n        self.func_arg = func_arg",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "init_registers",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def init_registers():\n    regs = {\n        GprDest(\"R\", \"d\"),\n        GprDest(\"R\", \"e\"),\n        GprSource(\"R\", \"s\"),\n        GprSource(\"R\", \"t\"),\n        GprSource(\"R\", \"u\"),\n        GprSource(\"R\", \"v\"),\n        GprReadWrite(\"R\", \"x\"),\n        GprReadWrite(\"R\", \"y\"),",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "get_register",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def get_register(tag, regtype, regid):\n    if f\"{regtype}{regid}V\" in semdict[tag]:\n        return registers[f\"{regtype}{regid}\"]\n    else:\n        return new_registers[f\"{regtype}{regid}\"]\ndef helper_ret_type(tag, regs):\n    ## If there is a scalar result, it is the return type\n    return_type = HelperArg( \"void\", \"void\", \"void\")\n    numscalarresults = 0\n    for regtype, regid in regs:",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "helper_ret_type",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def helper_ret_type(tag, regs):\n    ## If there is a scalar result, it is the return type\n    return_type = HelperArg( \"void\", \"void\", \"void\")\n    numscalarresults = 0\n    for regtype, regid in regs:\n        reg = get_register(tag, regtype, regid)\n        if reg.is_written() and reg.is_scalar_reg():\n            return_type = HelperArg(\n                reg.helper_proto_type(),\n                reg.reg_tcg(),",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "helper_args",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def helper_args(tag, regs, imms):\n    args = []\n    ## First argument is the CPU state\n    if need_env(tag):\n        args.append(HelperArg(\n            \"env\",\n            \"tcg_env\",\n            \"CPUHexagonState *env\"\n        ))\n    ## For predicated instructions, we pass in the destination register",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "parse_common_args",
        "kind": 2,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "def parse_common_args(desc):\n    parser = argparse.ArgumentParser(desc)\n    parser.add_argument(\"semantics\", help=\"semantics file\")\n    parser.add_argument(\"overrides\", help=\"overrides file\")\n    parser.add_argument(\"overrides_vec\", help=\"vector overrides file\")\n    parser.add_argument(\"out\", help=\"output file\")\n    parser.add_argument(\"--idef-parser\",\n                        help=\"file of instructions translated by idef-parser\")\n    args = parser.parse_args()\n    read_semantics_file(args.semantics)",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "behdict",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "behdict = {}  # tag ->behavior\nsemdict = {}  # tag -> semantics\nattribdict = {}  # tag -> attributes\nmacros = {}  # macro -> macro information...\nregisters = {}  # register -> register functions\nnew_registers = {}\ntags = []  # list of all tags\noverrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "semdict",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "semdict = {}  # tag -> semantics\nattribdict = {}  # tag -> attributes\nmacros = {}  # macro -> macro information...\nregisters = {}  # register -> register functions\nnew_registers = {}\ntags = []  # list of all tags\noverrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "attribdict",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "attribdict = {}  # tag -> attributes\nmacros = {}  # macro -> macro information...\nregisters = {}  # register -> register functions\nnew_registers = {}\ntags = []  # list of all tags\noverrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.\ndef uniquify(seq):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "macros",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "macros = {}  # macro -> macro information...\nregisters = {}  # register -> register functions\nnew_registers = {}\ntags = []  # list of all tags\noverrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.\ndef uniquify(seq):\n    seen = set()",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "registers",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "registers = {}  # register -> register functions\nnew_registers = {}\ntags = []  # list of all tags\noverrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.\ndef uniquify(seq):\n    seen = set()\n    seen_add = seen.add",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "new_registers",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "new_registers = {}\ntags = []  # list of all tags\noverrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.\ndef uniquify(seq):\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if x not in seen and not seen_add(x)]",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "tags",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "tags = []  # list of all tags\noverrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.\ndef uniquify(seq):\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if x not in seen and not seen_add(x)]\nregre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "overrides",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "overrides = {}  # tags with helper overrides\nidef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.\ndef uniquify(seq):\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if x not in seen and not seen_add(x)]\nregre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "idef_parser_enabled",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "idef_parser_enabled = {}  # tags enabled for idef-parser\n# We should do this as a hash for performance,\n# but to keep order let's keep it as a list.\ndef uniquify(seq):\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if x not in seen and not seen_add(x)]\nregre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\nreg_or_immre = re.compile(",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "regre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "regre = re.compile(r\"((?<!DUP)[MNORCPQXSGVZA])([stuvwxyzdefg]+)([.]?[LlHh]?)(\\d+S?)\")\nimmre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\nreg_or_immre = re.compile(\n    r\"(((?<!DUP)[MNRCOPQXSGVZA])([stuvwxyzdefg]+)\"\n    r\"([.]?[LlHh]?)(\\d+S?))|([#]([rRsSuUm])(\\d+)[:]?(\\d+)?)\"\n)\nrelimmre = re.compile(r\"[#]([rR])(\\d+)(?:[:](\\d+))?\")\nabsimmre = re.compile(r\"[#]([sSuUm])(\\d+)(?:[:](\\d+))?\")\nfinished_macros = set()\ndef expand_macro_attribs(macro, allmac_re):",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "immre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "immre = re.compile(r\"[#]([rRsSuUm])(\\d+)(?:[:](\\d+))?\")\nreg_or_immre = re.compile(\n    r\"(((?<!DUP)[MNRCOPQXSGVZA])([stuvwxyzdefg]+)\"\n    r\"([.]?[LlHh]?)(\\d+S?))|([#]([rRsSuUm])(\\d+)[:]?(\\d+)?)\"\n)\nrelimmre = re.compile(r\"[#]([rR])(\\d+)(?:[:](\\d+))?\")\nabsimmre = re.compile(r\"[#]([sSuUm])(\\d+)(?:[:](\\d+))?\")\nfinished_macros = set()\ndef expand_macro_attribs(macro, allmac_re):\n    if macro.key not in finished_macros:",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "reg_or_immre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "reg_or_immre = re.compile(\n    r\"(((?<!DUP)[MNRCOPQXSGVZA])([stuvwxyzdefg]+)\"\n    r\"([.]?[LlHh]?)(\\d+S?))|([#]([rRsSuUm])(\\d+)[:]?(\\d+)?)\"\n)\nrelimmre = re.compile(r\"[#]([rR])(\\d+)(?:[:](\\d+))?\")\nabsimmre = re.compile(r\"[#]([sSuUm])(\\d+)(?:[:](\\d+))?\")\nfinished_macros = set()\ndef expand_macro_attribs(macro, allmac_re):\n    if macro.key not in finished_macros:\n        # Get a list of all things that might be macros",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "relimmre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "relimmre = re.compile(r\"[#]([rR])(\\d+)(?:[:](\\d+))?\")\nabsimmre = re.compile(r\"[#]([sSuUm])(\\d+)(?:[:](\\d+))?\")\nfinished_macros = set()\ndef expand_macro_attribs(macro, allmac_re):\n    if macro.key not in finished_macros:\n        # Get a list of all things that might be macros\n        l = allmac_re.findall(macro.beh)\n        for submacro in l:\n            if not submacro:\n                continue",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "absimmre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "absimmre = re.compile(r\"[#]([sSuUm])(\\d+)(?:[:](\\d+))?\")\nfinished_macros = set()\ndef expand_macro_attribs(macro, allmac_re):\n    if macro.key not in finished_macros:\n        # Get a list of all things that might be macros\n        l = allmac_re.findall(macro.beh)\n        for submacro in l:\n            if not submacro:\n                continue\n            if not macros[submacro]:",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "finished_macros",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "finished_macros = set()\ndef expand_macro_attribs(macro, allmac_re):\n    if macro.key not in finished_macros:\n        # Get a list of all things that might be macros\n        l = allmac_re.findall(macro.beh)\n        for submacro in l:\n            if not submacro:\n                continue\n            if not macros[submacro]:\n                raise Exception(f\"Couldn't find macro: <{l}>\")",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "immextre",
        "kind": 5,
        "importPath": "qemu.target.hexagon.hex_common",
        "description": "qemu.target.hexagon.hex_common",
        "peekOfCode": "immextre = re.compile(r\"f(MUST_)?IMMEXT[(]([UuSsRr])\")\ndef is_cond_jump(tag):\n    if tag == \"J2_rte\":\n        return False\n    if \"A_HWLOOP0_END\" in attribdict[tag] or \"A_HWLOOP1_END\" in attribdict[tag]:\n        return False\n    return re.compile(r\"(if.*fBRANCH)|(if.*fJUMPR)\").search(semdict[tag]) != None\ndef is_cond_call(tag):\n    return re.compile(r\"(if.*fCALL)\").search(semdict[tag]) != None\ndef calculate_attribs():",
        "detail": "qemu.target.hexagon.hex_common",
        "documentation": {}
    },
    {
        "label": "EngineEnum",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class EngineEnum(enum.IntEnum):\n    AUTO = 1\n    DOCKER = 2\n    PODMAN = 3\n    def __str__(self):\n        return self.name.lower()\n    def __repr__(self):\n        return str(self)\n    @staticmethod\n    def argparse(s):",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "Docker",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class Docker(object):\n    \"\"\" Running Docker commands \"\"\"\n    def __init__(self):\n        self._command = _guess_engine_command()\n        if (\"docker\" in self._command and\n            \"TRAVIS\" not in os.environ and\n            \"GITLAB_CI\" not in os.environ):\n            os.environ[\"DOCKER_BUILDKIT\"] = \"1\"\n            self._buildkit = True\n        else:",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "SubCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class SubCommand(object):\n    \"\"\"A SubCommand template base class\"\"\"\n    name = None  # Subcommand name\n    def shared_args(self, parser):\n        parser.add_argument(\"--quiet\", action=\"store_true\",\n                            help=\"Run quietly unless an error occurred\")\n    def args(self, parser):\n        \"\"\"Setup argument parser\"\"\"\n        pass\n    def run(self, args, argv):",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "RunCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class RunCommand(SubCommand):\n    \"\"\"Invoke docker run and take care of cleaning up\"\"\"\n    name = \"run\"\n    def args(self, parser):\n        parser.add_argument(\"--keep\", action=\"store_true\",\n                            help=\"Don't remove image when command completes\")\n        parser.add_argument(\"--run-as-current-user\", action=\"store_true\",\n                            help=\"Run container using the current user's uid\")\n    def run(self, args, argv):\n        return Docker().run(argv, args.keep, quiet=args.quiet,",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "BuildCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class BuildCommand(SubCommand):\n    \"\"\" Build docker image out of a dockerfile. Arg: <tag> <dockerfile>\"\"\"\n    name = \"build\"\n    def args(self, parser):\n        parser.add_argument(\"--include-executable\", \"-e\",\n                            help=\"\"\"Specify a binary that will be copied to the\n                            container together with all its dependent\n                            libraries\"\"\")\n        parser.add_argument(\"--skip-binfmt\",\n                            action=\"store_true\",",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "FetchCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class FetchCommand(SubCommand):\n    \"\"\" Fetch a docker image from the registry. Args: <tag> <registry>\"\"\"\n    name = \"fetch\"\n    def args(self, parser):\n        parser.add_argument(\"tag\",\n                            help=\"Local tag for image\")\n        parser.add_argument(\"registry\",\n                            help=\"Docker registry\")\n    def run(self, args, argv):\n        dkr = Docker()",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "UpdateCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class UpdateCommand(SubCommand):\n    \"\"\" Update a docker image. Args: <tag> <actions>\"\"\"\n    name = \"update\"\n    def args(self, parser):\n        parser.add_argument(\"tag\",\n                            help=\"Image Tag\")\n        parser.add_argument(\"--executable\",\n                            help=\"Executable to copy\")\n        parser.add_argument(\"--add-current-user\", \"-u\", dest=\"user\",\n                            action=\"store_true\",",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "CleanCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class CleanCommand(SubCommand):\n    \"\"\"Clean up docker instances\"\"\"\n    name = \"clean\"\n    def run(self, args, argv):\n        Docker().clean()\n        return 0\nclass ImagesCommand(SubCommand):\n    \"\"\"Run \"docker images\" command\"\"\"\n    name = \"images\"\n    def run(self, args, argv):",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "ImagesCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class ImagesCommand(SubCommand):\n    \"\"\"Run \"docker images\" command\"\"\"\n    name = \"images\"\n    def run(self, args, argv):\n        return Docker().command(\"images\", argv, args.quiet)\nclass ProbeCommand(SubCommand):\n    \"\"\"Probe if we can run docker automatically\"\"\"\n    name = \"probe\"\n    def run(self, args, argv):\n        try:",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "ProbeCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class ProbeCommand(SubCommand):\n    \"\"\"Probe if we can run docker automatically\"\"\"\n    name = \"probe\"\n    def run(self, args, argv):\n        try:\n            docker = Docker()\n            if docker._command[0] == \"docker\":\n                print(\"docker\")\n            elif docker._command[0] == \"sudo\":\n                print(\"sudo docker\")",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "CcCommand",
        "kind": 6,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "class CcCommand(SubCommand):\n    \"\"\"Compile sources with cc in images\"\"\"\n    name = \"cc\"\n    def args(self, parser):\n        parser.add_argument(\"--image\", \"-i\", required=True,\n                            help=\"The docker image in which to run cc\")\n        parser.add_argument(\"--cc\", default=\"cc\",\n                            help=\"The compiler executable to call\")\n        parser.add_argument(\"--source-path\", \"-s\", nargs=\"*\", dest=\"paths\",\n                            help=\"\"\"Extra paths to (ro) mount into container for",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "def main():\n    global USE_ENGINE\n    parser = argparse.ArgumentParser(description=\"A Docker helper\",\n                                     usage=\"%s <subcommand> ...\" %\n                                     os.path.basename(sys.argv[0]))\n    parser.add_argument(\"--engine\", type=EngineEnum.argparse, choices=list(EngineEnum),\n                        help=\"specify which container engine to use\")\n    subparsers = parser.add_subparsers(title=\"subcommands\", help=None)\n    for cls in SubCommand.__subclasses__():\n        cmd = cls()",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "FILTERED_ENV_NAMES",
        "kind": 5,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "FILTERED_ENV_NAMES = ['ftp_proxy', 'http_proxy', 'https_proxy']\nDEVNULL = open(os.devnull, 'wb')\nclass EngineEnum(enum.IntEnum):\n    AUTO = 1\n    DOCKER = 2\n    PODMAN = 3\n    def __str__(self):\n        return self.name.lower()\n    def __repr__(self):\n        return str(self)",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "kind": 5,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "DEVNULL = open(os.devnull, 'wb')\nclass EngineEnum(enum.IntEnum):\n    AUTO = 1\n    DOCKER = 2\n    PODMAN = 3\n    def __str__(self):\n        return self.name.lower()\n    def __repr__(self):\n        return str(self)\n    @staticmethod",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "USE_ENGINE",
        "kind": 5,
        "importPath": "qemu.tests.docker.docker",
        "description": "qemu.tests.docker.docker",
        "peekOfCode": "USE_ENGINE = EngineEnum.AUTO\ndef _bytes_checksum(bytes):\n    \"\"\"Calculate a digest string unique to the text content\"\"\"\n    return hashlib.sha1(bytes).hexdigest()\ndef _text_checksum(text):\n    \"\"\"Calculate a digest string unique to the text content\"\"\"\n    return _bytes_checksum(text.encode('utf-8'))\ndef _read_dockerfile(path):\n    return open(path, 'rt', encoding='utf-8').read()\ndef _file_checksum(filename):",
        "detail": "qemu.tests.docker.docker",
        "documentation": {}
    },
    {
        "label": "tar_extract",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.archive",
        "description": "qemu.tests.functional.qemu_test.archive",
        "peekOfCode": "def tar_extract(archive, dest_dir, member=None):\n    with tarfile.open(archive) as tf:\n        if hasattr(tarfile, 'data_filter'):\n            tf.extraction_filter = getattr(tarfile, 'data_filter',\n                                           (lambda member, path: member))\n        if member:\n            tf.extract(member=member, path=dest_dir)\n        else:\n            tf.extractall(path=dest_dir)\ndef cpio_extract(archive, output_path):",
        "detail": "qemu.tests.functional.qemu_test.archive",
        "documentation": {}
    },
    {
        "label": "cpio_extract",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.archive",
        "description": "qemu.tests.functional.qemu_test.archive",
        "peekOfCode": "def cpio_extract(archive, output_path):\n    cwd = os.getcwd()\n    os.chdir(output_path)\n    # Not passing 'check=True' as cpio exits with non-zero\n    # status if the archive contains any device nodes :-(\n    if type(archive) == str:\n        run(['cpio', '-i', '-F', archive],\n            stdout=DEVNULL, stderr=DEVNULL)\n    else:\n        run(['cpio', '-i'],",
        "detail": "qemu.tests.functional.qemu_test.archive",
        "documentation": {}
    },
    {
        "label": "zip_extract",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.archive",
        "description": "qemu.tests.functional.qemu_test.archive",
        "peekOfCode": "def zip_extract(archive, dest_dir, member=None):\n    with zipfile.ZipFile(archive, 'r') as zf:\n        if member:\n            zf.extract(member=member, path=dest_dir)\n        else:\n            zf.extractall(path=dest_dir)\ndef deb_extract(archive, dest_dir, member=None):\n    cwd = os.getcwd()\n    os.chdir(dest_dir)\n    try:",
        "detail": "qemu.tests.functional.qemu_test.archive",
        "documentation": {}
    },
    {
        "label": "deb_extract",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.archive",
        "description": "qemu.tests.functional.qemu_test.archive",
        "peekOfCode": "def deb_extract(archive, dest_dir, member=None):\n    cwd = os.getcwd()\n    os.chdir(dest_dir)\n    try:\n        proc = run(['ar', 't', archive],\n                   check=True, capture_output=True, encoding='utf8')\n        file_path = proc.stdout.split()[2]\n        check_call(['ar', 'x', archive, file_path],\n                   stdout=DEVNULL, stderr=DEVNULL)\n        tar_extract(file_path, dest_dir, member)",
        "detail": "qemu.tests.functional.qemu_test.archive",
        "documentation": {}
    },
    {
        "label": "archive_extract",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.archive",
        "description": "qemu.tests.functional.qemu_test.archive",
        "peekOfCode": "def archive_extract(archive, dest_dir, format=None, member=None):\n    if format is None:\n        format = guess_archive_format(archive)\n    if type(archive) == Asset:\n        archive = str(archive)\n    if format == \"tar\":\n        tar_extract(archive, dest_dir, member)\n    elif format == \"zip\":\n        zip_extract(archive, dest_dir, member)\n    elif format == \"cpio\":",
        "detail": "qemu.tests.functional.qemu_test.archive",
        "documentation": {}
    },
    {
        "label": "guess_archive_format",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.archive",
        "description": "qemu.tests.functional.qemu_test.archive",
        "peekOfCode": "def guess_archive_format(archive):\n    if type(archive) == Asset:\n        archive = urlparse(archive.url).path\n    elif type(archive) != str:\n        raise Exception(f\"Unable to guess archive format for {archive}\")\n    if \".tar.\" in archive or archive.endswith(\"tgz\"):\n        return \"tar\"\n    elif archive.endswith(\".zip\"):\n        return \"zip\"\n    elif archive.endswith(\".cpio\"):",
        "detail": "qemu.tests.functional.qemu_test.archive",
        "documentation": {}
    },
    {
        "label": "AssetError",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.asset",
        "description": "qemu.tests.functional.qemu_test.asset",
        "peekOfCode": "class AssetError(Exception):\n    def __init__(self, asset, msg, transient=False):\n        self.url = asset.url\n        self.msg = msg\n        self.transient = transient\n    def __str__(self):\n        return \"%s: %s\" % (self.url, self.msg)\n# Instances of this class must be declared as class level variables\n# starting with a name \"ASSET_\". This enables the pre-caching logic\n# to easily find all referenced assets and download them prior to",
        "detail": "qemu.tests.functional.qemu_test.asset",
        "documentation": {}
    },
    {
        "label": "Asset",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.asset",
        "description": "qemu.tests.functional.qemu_test.asset",
        "peekOfCode": "class Asset:\n    def __init__(self, url, hashsum):\n        self.url = url\n        self.hash = hashsum\n        cache_dir_env = os.getenv('QEMU_TEST_CACHE_DIR')\n        if cache_dir_env:\n            self.cache_dir = Path(cache_dir_env, \"download\")\n        else:\n            self.cache_dir = Path(Path(\"~\").expanduser(),\n                                  \".cache\", \"qemu\", \"download\")",
        "detail": "qemu.tests.functional.qemu_test.asset",
        "documentation": {}
    },
    {
        "label": "which",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.cmd",
        "description": "qemu.tests.functional.qemu_test.cmd",
        "peekOfCode": "def which(tool):\n    \"\"\" looks up the full path for @tool, returns None if not found\n        or if @tool does not have executable permissions.\n    \"\"\"\n    paths=os.getenv('PATH')\n    for p in paths.split(os.path.pathsep):\n        p = os.path.join(p, tool)\n        if os.access(p, os.X_OK):\n            return p\n    return None",
        "detail": "qemu.tests.functional.qemu_test.cmd",
        "documentation": {}
    },
    {
        "label": "is_readable_executable_file",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.cmd",
        "description": "qemu.tests.functional.qemu_test.cmd",
        "peekOfCode": "def is_readable_executable_file(path):\n    return os.path.isfile(path) and os.access(path, os.R_OK | os.X_OK)\n# @test: functional test to fail if @failure is seen\n# @vm: the VM whose console to process\n# @success: a non-None string to look for\n# @failure: a string to look for that triggers test failure, or None\n#\n# Read up to 1 line of text from @vm, looking for @success\n# and optionally @failure.\n#",
        "detail": "qemu.tests.functional.qemu_test.cmd",
        "documentation": {}
    },
    {
        "label": "interrupt_interactive_console_until_pattern",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.cmd",
        "description": "qemu.tests.functional.qemu_test.cmd",
        "peekOfCode": "def interrupt_interactive_console_until_pattern(test, success_message,\n                                                failure_message=None,\n                                                interrupt_string='\\r'):\n    \"\"\"\n    Keep sending a string to interrupt a console prompt, while logging the\n    console output. Typical use case is to break a boot loader prompt, such:\n        Press a key within 5 seconds to interrupt boot process.\n        5\n        4\n        3",
        "detail": "qemu.tests.functional.qemu_test.cmd",
        "documentation": {}
    },
    {
        "label": "wait_for_console_pattern",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.cmd",
        "description": "qemu.tests.functional.qemu_test.cmd",
        "peekOfCode": "def wait_for_console_pattern(test, success_message, failure_message=None,\n                             vm=None):\n    \"\"\"\n    Waits for messages to appear on the console, while logging the content\n    :param test: a test containing a VM that will have its console\n                 read and probed for a success or failure message\n    :type test: :class:`qemu_test.QemuSystemTest`\n    :param success_message: if this message appears, test succeeds\n    :param failure_message: if this message appears, test fails\n    \"\"\"",
        "detail": "qemu.tests.functional.qemu_test.cmd",
        "documentation": {}
    },
    {
        "label": "exec_command",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.cmd",
        "description": "qemu.tests.functional.qemu_test.cmd",
        "peekOfCode": "def exec_command(test, command):\n    \"\"\"\n    Send a command to a console (appending CRLF characters), while logging\n    the content.\n    :param test: a test containing a VM.\n    :type test: :class:`qemu_test.QemuSystemTest`\n    :param command: the command to send\n    :type command: str\n    \"\"\"\n    _console_interaction(test, None, None, command + '\\r')",
        "detail": "qemu.tests.functional.qemu_test.cmd",
        "documentation": {}
    },
    {
        "label": "exec_command_and_wait_for_pattern",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.cmd",
        "description": "qemu.tests.functional.qemu_test.cmd",
        "peekOfCode": "def exec_command_and_wait_for_pattern(test, command,\n                                      success_message, failure_message=None):\n    \"\"\"\n    Send a command to a console (appending CRLF characters), then wait\n    for success_message to appear on the console, while logging the.\n    content. Mark the test as failed if failure_message is found instead.\n    :param test: a test containing a VM that will have its console\n                 read and probed for a success or failure message\n    :type test: :class:`qemu_test.QemuSystemTest`\n    :param command: the command to send",
        "detail": "qemu.tests.functional.qemu_test.cmd",
        "documentation": {}
    },
    {
        "label": "get_qemu_img",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.cmd",
        "description": "qemu.tests.functional.qemu_test.cmd",
        "peekOfCode": "def get_qemu_img(test):\n    test.log.debug('Looking for and selecting a qemu-img binary')\n    # If qemu-img has been built, use it, otherwise the system wide one\n    # will be used.\n    qemu_img = test.build_file('qemu-img')\n    if os.path.exists(qemu_img):\n        return qemu_img\n    qemu_img = which('qemu-img')\n    if qemu_img is not None:\n        return qemu_img",
        "detail": "qemu.tests.functional.qemu_test.cmd",
        "documentation": {}
    },
    {
        "label": "dso_suffix",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.config",
        "description": "qemu.tests.functional.qemu_test.config",
        "peekOfCode": "def dso_suffix():\n    '''Return the dynamic libraries suffix for the current platform'''\n    if platform.system() == \"Darwin\":\n        return \"dylib\"\n    if platform.system() == \"Windows\":\n        return \"dll\"\n    return \"so\"",
        "detail": "qemu.tests.functional.qemu_test.config",
        "documentation": {}
    },
    {
        "label": "BUILD_DIR",
        "kind": 5,
        "importPath": "qemu.tests.functional.qemu_test.config",
        "description": "qemu.tests.functional.qemu_test.config",
        "peekOfCode": "BUILD_DIR = _build_dir()\ndef dso_suffix():\n    '''Return the dynamic libraries suffix for the current platform'''\n    if platform.system() == \"Darwin\":\n        return \"dylib\"\n    if platform.system() == \"Windows\":\n        return \"dll\"\n    return \"so\"",
        "detail": "qemu.tests.functional.qemu_test.config",
        "documentation": {}
    },
    {
        "label": "skipIfMissingCommands",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipIfMissingCommands(*args):\n    has_cmds = True\n    for cmd in args:\n         if not which(cmd):\n             has_cmds = False\n             break\n    return skipUnless(has_cmds, 'required command(s) \"%s\" not installed' %\n                                \", \".join(args))\n'''\nDecorator to skip execution of a test if the current",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "skipIfOperatingSystem",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipIfOperatingSystem(*args):\n    return skipIf(platform.system() in args,\n                  'running on an OS (%s) that is not able to run this test' %\n                  \", \".join(args))\n'''\nDecorator to skip execution of a test if the current\nhost machine does not match one of the permitted\nmachines.\nExample\n  @skipIfNotMachine(\"x86_64\", \"aarch64\")",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "skipIfNotMachine",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipIfNotMachine(*args):\n    return skipUnless(platform.machine() in args,\n                      'not running on one of the required machine(s) \"%s\"' %\n                      \", \".join(args))\n'''\nDecorator to skip execution of flaky tests, unless\nthe $QEMU_TEST_FLAKY_TESTS environment variable is set.\nA bug URL must be provided that documents the observed\nfailure behaviour, so it can be tracked & re-evaluated\nin future.",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "skipFlakyTest",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipFlakyTest(bug_url):\n    if bug_url is None:\n        bug_url = \"FIXME: reproduce flaky test and file bug report or remove\"\n    return skipUnless(os.getenv('QEMU_TEST_FLAKY_TESTS'),\n                      f'Test is unstable: {bug_url}')\n'''\nDecorator to skip execution of tests which are likely\nto execute untrusted commands on the host, or commands\nwhich process untrusted code, unless the\n$QEMU_TEST_ALLOW_UNTRUSTED_CODE env var is set.",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "skipUntrustedTest",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipUntrustedTest():\n    return skipUnless(os.getenv('QEMU_TEST_ALLOW_UNTRUSTED_CODE'),\n                      'Test runs untrusted code / processes untrusted data')\n'''\nDecorator to skip execution of tests which need large\ndata storage (over around 500MB-1GB mark) on the host,\nunless the $QEMU_TEST_ALLOW_LARGE_STORAGE environment\nvariable is set\nExample:\n  @skipBigDataTest()",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "skipBigDataTest",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipBigDataTest():\n    return skipUnless(os.getenv('QEMU_TEST_ALLOW_LARGE_STORAGE'),\n                      'Test requires large host storage space')\n'''\nDecorator to skip execution of tests which have a really long\nruntime (and might e.g. time out if QEMU has been compiled with\ndebugging enabled) unless the $QEMU_TEST_ALLOW_SLOW\nenvironment variable is set\nExample:\n  @skipSlowTest()",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "skipSlowTest",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipSlowTest():\n    return skipUnless(os.getenv('QEMU_TEST_ALLOW_SLOW'),\n                      'Test has a very long runtime and might time out')\n'''\nDecorator to skip execution of a test if the list\nof python imports is not available.\nExample:\n  @skipIfMissingImports(\"numpy\", \"cv2\")\n'''\ndef skipIfMissingImports(*args):",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "skipIfMissingImports",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.decorators",
        "description": "qemu.tests.functional.qemu_test.decorators",
        "peekOfCode": "def skipIfMissingImports(*args):\n    has_imports = True\n    for impname in args:\n        try:\n            importlib.import_module(impname)\n        except ImportError:\n            has_imports = False\n            break\n    return skipUnless(has_imports, 'required import(s) \"%s\" not installed' %\n                                   \", \".join(args))",
        "detail": "qemu.tests.functional.qemu_test.decorators",
        "documentation": {}
    },
    {
        "label": "LinuxKernelTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.linuxkernel",
        "description": "qemu.tests.functional.qemu_test.linuxkernel",
        "peekOfCode": "class LinuxKernelTest(QemuSystemTest):\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    def wait_for_console_pattern(self, success_message, vm=None):\n        wait_for_console_pattern(self, success_message,\n                                 failure_message='Kernel panic - not syncing',\n                                 vm=vm)\n    def launch_kernel(self, kernel, initrd=None, dtb=None, console_index=0,\n                      wait_for=None):\n        self.vm.set_console(console_index=console_index)\n        self.vm.add_args('-kernel', kernel)",
        "detail": "qemu.tests.functional.qemu_test.linuxkernel",
        "documentation": {}
    },
    {
        "label": "Ports",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.ports",
        "description": "qemu.tests.functional.qemu_test.ports",
        "peekOfCode": "class Ports():\n    PORTS_ADDR = '127.0.0.1'\n    PORTS_RANGE_SIZE = 1024\n    PORTS_START = 49152 + ((os.getpid() * PORTS_RANGE_SIZE) % 16384)\n    PORTS_END = PORTS_START + PORTS_RANGE_SIZE\n    def __enter__(self):\n        lock_file = os.path.join(BUILD_DIR, \"tests\", \"functional\", \"port_lock\")\n        self.lock_fh = os.open(lock_file, os.O_CREAT)\n        fcntl.flock(self.lock_fh, fcntl.LOCK_EX)\n        return self",
        "detail": "qemu.tests.functional.qemu_test.ports",
        "documentation": {}
    },
    {
        "label": "tesseract_ocr",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.tesseract",
        "description": "qemu.tests.functional.qemu_test.tesseract",
        "peekOfCode": "def tesseract_ocr(image_path, tesseract_args=''):\n    console_logger = logging.getLogger('console')\n    console_logger.debug(image_path)\n    proc = run(['tesseract', image_path, 'stdout'],\n               capture_output=True, encoding='utf8')\n    if proc.returncode:\n        return None\n    lines = []\n    for line in proc.stdout.split('\\n'):\n        sline = line.strip()",
        "detail": "qemu.tests.functional.qemu_test.tesseract",
        "documentation": {}
    },
    {
        "label": "QemuBaseTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.testcase",
        "description": "qemu.tests.functional.qemu_test.testcase",
        "peekOfCode": "class QemuBaseTest(unittest.TestCase):\n    '''\n    @params compressed: filename, Asset, or file-like object to uncompress\n    @params format: optional compression format (gzip, lzma)\n    Uncompresses @compressed into the scratch directory.\n    If @format is None, heuristics will be applied to guess the format\n    from the filename or Asset URL. @format must be non-None if @uncompressed\n    is a file-like object.\n    Returns the fully qualified path to the uncompressed file\n    '''",
        "detail": "qemu.tests.functional.qemu_test.testcase",
        "documentation": {}
    },
    {
        "label": "QemuUserTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.testcase",
        "description": "qemu.tests.functional.qemu_test.testcase",
        "peekOfCode": "class QemuUserTest(QemuBaseTest):\n    def setUp(self):\n        super().setUp()\n        self._ldpath = []\n    def add_ldpath(self, ldpath):\n        self._ldpath.append(os.path.abspath(ldpath))\n    def run_cmd(self, bin_path, args=[]):\n        return run([self.qemu_bin]\n                   + [\"-L %s\" % ldpath for ldpath in self._ldpath]\n                   + [bin_path]",
        "detail": "qemu.tests.functional.qemu_test.testcase",
        "documentation": {}
    },
    {
        "label": "QemuSystemTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.testcase",
        "description": "qemu.tests.functional.qemu_test.testcase",
        "peekOfCode": "class QemuSystemTest(QemuBaseTest):\n    \"\"\"Facilitates system emulation tests.\"\"\"\n    cpu = None\n    machine = None\n    _machinehelp = None\n    def setUp(self):\n        self._vms = {}\n        super().setUp()\n        console_log = logging.getLogger('console')\n        console_log.setLevel(logging.DEBUG)",
        "detail": "qemu.tests.functional.qemu_test.testcase",
        "documentation": {}
    },
    {
        "label": "TuxRunBaselineTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.qemu_test.tuxruntest",
        "description": "qemu.tests.functional.qemu_test.tuxruntest",
        "peekOfCode": "class TuxRunBaselineTest(QemuSystemTest):\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0'\n    # Tests are ~10-40s, allow for --debug/--enable-gcov overhead\n    timeout = 100\n    def setUp(self):\n        super().setUp()\n        # We need zstd for all the tuxrun tests\n        if which('zstd') is None:\n            self.skipTest(\"zstd not found in $PATH\")\n        # Pre-init TuxRun specific settings: Most machines work with",
        "detail": "qemu.tests.functional.qemu_test.tuxruntest",
        "documentation": {}
    },
    {
        "label": "gzip_uncompress",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.uncompress",
        "description": "qemu.tests.functional.qemu_test.uncompress",
        "peekOfCode": "def gzip_uncompress(gz_path, output_path):\n    if os.path.exists(output_path):\n        return\n    with gzip.open(gz_path, 'rb') as gz_in:\n        try:\n            with open(output_path, 'wb') as raw_out:\n                shutil.copyfileobj(gz_in, raw_out)\n        except:\n            os.remove(output_path)\n            raise",
        "detail": "qemu.tests.functional.qemu_test.uncompress",
        "documentation": {}
    },
    {
        "label": "lzma_uncompress",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.uncompress",
        "description": "qemu.tests.functional.qemu_test.uncompress",
        "peekOfCode": "def lzma_uncompress(xz_path, output_path):\n    if os.path.exists(output_path):\n        return\n    with lzma.open(xz_path, 'rb') as lzma_in:\n        try:\n            with open(output_path, 'wb') as raw_out:\n                shutil.copyfileobj(lzma_in, raw_out)\n        except:\n            os.remove(output_path)\n            raise",
        "detail": "qemu.tests.functional.qemu_test.uncompress",
        "documentation": {}
    },
    {
        "label": "zstd_uncompress",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.uncompress",
        "description": "qemu.tests.functional.qemu_test.uncompress",
        "peekOfCode": "def zstd_uncompress(zstd_path, output_path):\n    if os.path.exists(output_path):\n        return\n    try:\n        run(['zstd', \"-f\", \"-d\", zstd_path,\n             \"-o\", output_path], capture_output=True, check=True)\n    except CalledProcessError as e:\n        os.remove(output_path)\n        raise Exception(\n            f\"Unable to decompress zstd file {zstd_path} with {e}\") from e",
        "detail": "qemu.tests.functional.qemu_test.uncompress",
        "documentation": {}
    },
    {
        "label": "uncompress",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.uncompress",
        "description": "qemu.tests.functional.qemu_test.uncompress",
        "peekOfCode": "def uncompress(compressed, uncompressed, format=None):\n    if format is None:\n        format = guess_uncompress_format(compressed)\n    if format == \"xz\":\n        lzma_uncompress(str(compressed), uncompressed)\n    elif format == \"gz\":\n        gzip_uncompress(str(compressed), uncompressed)\n    elif format == \"zstd\":\n        zstd_uncompress(str(compressed), uncompressed)\n    else:",
        "detail": "qemu.tests.functional.qemu_test.uncompress",
        "documentation": {}
    },
    {
        "label": "guess_uncompress_format",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.uncompress",
        "description": "qemu.tests.functional.qemu_test.uncompress",
        "peekOfCode": "def guess_uncompress_format(compressed):\n    if type(compressed) == Asset:\n        compressed = urlparse(compressed.url).path\n    elif type(compressed) != str:\n        raise Exception(f\"Unable to guess compression cformat for {compressed}\")\n    (name, ext) = os.path.splitext(compressed)\n    if ext == \".xz\":\n        return \"xz\"\n    elif ext == \".gz\":\n        return \"gz\"",
        "detail": "qemu.tests.functional.qemu_test.uncompress",
        "documentation": {}
    },
    {
        "label": "get_usernet_hostfwd_port",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.utils",
        "description": "qemu.tests.functional.qemu_test.utils",
        "peekOfCode": "def get_usernet_hostfwd_port(vm):\n    res = vm.cmd('human-monitor-command', command_line='info usernet')\n    return get_info_usernet_hostfwd_port(res)\n\"\"\"\nRound up to next power of 2\n\"\"\"\ndef pow2ceil(x):\n    return 1 if x == 0 else 2**(x - 1).bit_length()\ndef file_truncate(path, size):\n    if size != os.path.getsize(path):",
        "detail": "qemu.tests.functional.qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "pow2ceil",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.utils",
        "description": "qemu.tests.functional.qemu_test.utils",
        "peekOfCode": "def pow2ceil(x):\n    return 1 if x == 0 else 2**(x - 1).bit_length()\ndef file_truncate(path, size):\n    if size != os.path.getsize(path):\n        with open(path, 'ab+') as fd:\n            fd.truncate(size)\n\"\"\"\nExpand file size to next power of 2\n\"\"\"\ndef image_pow2ceil_expand(path):",
        "detail": "qemu.tests.functional.qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "file_truncate",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.utils",
        "description": "qemu.tests.functional.qemu_test.utils",
        "peekOfCode": "def file_truncate(path, size):\n    if size != os.path.getsize(path):\n        with open(path, 'ab+') as fd:\n            fd.truncate(size)\n\"\"\"\nExpand file size to next power of 2\n\"\"\"\ndef image_pow2ceil_expand(path):\n        size = os.path.getsize(path)\n        size_aligned = pow2ceil(size)",
        "detail": "qemu.tests.functional.qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "image_pow2ceil_expand",
        "kind": 2,
        "importPath": "qemu.tests.functional.qemu_test.utils",
        "description": "qemu.tests.functional.qemu_test.utils",
        "peekOfCode": "def image_pow2ceil_expand(path):\n        size = os.path.getsize(path)\n        size_aligned = pow2ceil(size)\n        if size != size_aligned:\n            with open(path, 'ab+') as fd:\n                fd.truncate(size_aligned)",
        "detail": "qemu.tests.functional.qemu_test.utils",
        "documentation": {}
    },
    {
        "label": "AspeedTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.aspeed",
        "description": "qemu.tests.functional.aspeed",
        "peekOfCode": "class AspeedTest(LinuxKernelTest):\n    def do_test_arm_aspeed_openbmc(self, machine, image, uboot='2019.04',\n                                   cpu_id='0x0', soc='AST2500 rev A1'):\n        hostname = machine.removesuffix('-bmc')\n        self.set_machine(machine)\n        self.vm.set_console()\n        self.vm.add_args('-drive', f'file={image},if=mtd,format=raw',\n                         '-snapshot')\n        self.vm.launch()\n        self.wait_for_console_pattern(f'U-Boot {uboot}')",
        "detail": "qemu.tests.functional.aspeed",
        "documentation": {}
    },
    {
        "label": "ReplayKernelBase",
        "kind": 6,
        "importPath": "qemu.tests.functional.replay_kernel",
        "description": "qemu.tests.functional.replay_kernel",
        "peekOfCode": "class ReplayKernelBase(LinuxKernelTest):\n    \"\"\"\n    Boots a Linux kernel in record mode and checks that the console\n    is operational and the kernel command line is properly passed\n    from QEMU to the kernel.\n    Then replays the same scenario and verifies, that QEMU correctly\n    terminates.\n    \"\"\"\n    timeout = 180\n    REPLAY_KERNEL_COMMAND_LINE = 'printk.time=1 panic=-1 '",
        "detail": "qemu.tests.functional.replay_kernel",
        "documentation": {}
    },
    {
        "label": "ReverseDebugging",
        "kind": 6,
        "importPath": "qemu.tests.functional.reverse_debugging",
        "description": "qemu.tests.functional.reverse_debugging",
        "peekOfCode": "class ReverseDebugging(LinuxKernelTest):\n    \"\"\"\n    Test GDB reverse debugging commands: reverse step and reverse continue.\n    Recording saves the execution of some instructions and makes an initial\n    VM snapshot to allow reverse execution.\n    Replay saves the order of the first instructions and then checks that they\n    are executed backwards in the correct order.\n    After that the execution is replayed to the end, and reverse continue\n    command is checked by setting several breakpoints, and asserting\n    that the execution is stopped at the last of them.",
        "detail": "qemu.tests.functional.reverse_debugging",
        "documentation": {}
    },
    {
        "label": "AST2x00MachineSDK",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_aspeed",
        "description": "qemu.tests.functional.test_aarch64_aspeed",
        "peekOfCode": "class AST2x00MachineSDK(QemuSystemTest):\n    def do_test_aarch64_aspeed_sdk_start(self, image):\n        self.require_netdev('user')\n        self.vm.set_console()\n        self.vm.add_args('-drive', 'file=' + image + ',if=mtd,format=raw',\n                         '-net', 'nic', '-net', 'user', '-snapshot')\n        self.vm.launch()\n        wait_for_console_pattern(self, 'U-Boot 2023.10')\n        wait_for_console_pattern(self, '## Loading kernel from FIT Image')\n        wait_for_console_pattern(self, 'Starting kernel ...')",
        "detail": "qemu.tests.functional.test_aarch64_aspeed",
        "documentation": {}
    },
    {
        "label": "Aarch64Raspi3Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_raspi3",
        "description": "qemu.tests.functional.test_aarch64_raspi3",
        "peekOfCode": "class Aarch64Raspi3Machine(LinuxKernelTest):\n    ASSET_RPI3_UEFI = Asset(\n        ('https://github.com/pbatard/RPi3/releases/download/'\n         'v1.15/RPi3_UEFI_Firmware_v1.15.zip'),\n        '8cff2e979560048b4c84921f41a91893240b9fb71a88f0b5c5d6c8edd994bd5b')\n    def test_aarch64_raspi3_atf(self):\n        efi_name = 'RPI_EFI.fd'\n        efi_fd = self.archive_extract(self.ASSET_RPI3_UEFI, member=efi_name)\n        self.set_machine('raspi3b')\n        self.vm.set_console(console_index=1)",
        "detail": "qemu.tests.functional.test_aarch64_raspi3",
        "documentation": {}
    },
    {
        "label": "Aarch64Raspi4Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_raspi4",
        "description": "qemu.tests.functional.test_aarch64_raspi4",
        "peekOfCode": "class Aarch64Raspi4Machine(LinuxKernelTest):\n    \"\"\"\n    The kernel can be rebuilt using the kernel source referenced\n    and following the instructions on the on:\n    https://www.raspberrypi.org/documentation/linux/kernel/building.md\n    \"\"\"\n    ASSET_KERNEL_20190215 = Asset(\n        ('http://archive.raspberrypi.org/debian/'\n         'pool/main/r/raspberrypi-firmware/'\n         'raspberrypi-kernel_1.20230106-1_arm64.deb'),",
        "detail": "qemu.tests.functional.test_aarch64_raspi4",
        "documentation": {}
    },
    {
        "label": "Aarch64Replay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_replay",
        "description": "qemu.tests.functional.test_aarch64_replay",
        "peekOfCode": "class Aarch64Replay(ReplayKernelBase):\n    ASSET_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/arm64/Image',\n        'b74743c5e89e1cea0f73368d24ae0ae85c5204ff84be3b5e9610417417d2f235')\n    ASSET_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/arm64/rootfs.ext4.zst',\n        'a1acaaae2068df4648d04ff75f532aaa8c5edcd6b936122b6f0db4848a07b465')\n    def test_aarch64_virt(self):\n        self.require_netdev('user')\n        self.set_machine('virt')",
        "detail": "qemu.tests.functional.test_aarch64_replay",
        "documentation": {}
    },
    {
        "label": "ReverseDebugging_AArch64",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_reverse_debug",
        "description": "qemu.tests.functional.test_aarch64_reverse_debug",
        "peekOfCode": "class ReverseDebugging_AArch64(ReverseDebugging):\n    REG_PC = 32\n    KERNEL_ASSET = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/'\n         'releases/29/Everything/aarch64/os/images/pxeboot/vmlinuz'),\n        '7e1430b81c26bdd0da025eeb8fbd77b5dc961da4364af26e771bd39f379cbbf7')\n    @skipFlakyTest(\"https://gitlab.com/qemu-project/qemu/-/issues/2921\")\n    def test_aarch64_virt(self):\n        self.set_machine('virt')\n        self.cpu = 'cortex-a53'",
        "detail": "qemu.tests.functional.test_aarch64_reverse_debug",
        "documentation": {}
    },
    {
        "label": "Aarch64RMESbsaRefMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_rme_sbsaref",
        "description": "qemu.tests.functional.test_aarch64_rme_sbsaref",
        "peekOfCode": "class Aarch64RMESbsaRefMachine(QemuSystemTest):\n    # Stack is built with OP-TEE build environment from those instructions:\n    # https://linaro.atlassian.net/wiki/spaces/QEMU/pages/29051027459/\n    # https://github.com/pbo-linaro/qemu-rme-stack\n    ASSET_RME_STACK_SBSA = Asset(\n        ('https://fileserver.linaro.org/s/KJyeBxL82mz2r7F/'\n         'download/rme-stack-op-tee-4.2.0-cca-v4-sbsa.tar.gz'),\n         'dd9ab28ec869bdf3b5376116cb3689103b43433fd5c4bca0f4a8d8b3c104999e')\n    # This tests the FEAT_RME cpu implementation, by booting a VM supporting it,\n    # and launching a nested VM using it.",
        "detail": "qemu.tests.functional.test_aarch64_rme_sbsaref",
        "documentation": {}
    },
    {
        "label": "Aarch64RMEVirtMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_rme_virt",
        "description": "qemu.tests.functional.test_aarch64_rme_virt",
        "peekOfCode": "class Aarch64RMEVirtMachine(QemuSystemTest):\n    # Stack is built with OP-TEE build environment from those instructions:\n    # https://linaro.atlassian.net/wiki/spaces/QEMU/pages/29051027459/\n    # https://github.com/pbo-linaro/qemu-rme-stack\n    ASSET_RME_STACK_VIRT = Asset(\n        ('https://fileserver.linaro.org/s/iaRsNDJp2CXHMSJ/'\n         'download/rme-stack-op-tee-4.2.0-cca-v4-qemu_v8.tar.gz'),\n         '1851adc232b094384d8b879b9a2cfff07ef3d6205032b85e9b3a4a9ae6b0b7ad')\n    # This tests the FEAT_RME cpu implementation, by booting a VM supporting it,\n    # and launching a nested VM using it.",
        "detail": "qemu.tests.functional.test_aarch64_rme_virt",
        "documentation": {}
    },
    {
        "label": "test_realms_guest",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_aarch64_rme_virt",
        "description": "qemu.tests.functional.test_aarch64_rme_virt",
        "peekOfCode": "def test_realms_guest(test_rme_instance):\n    # Boot the (nested) guest VM\n    exec_command(test_rme_instance,\n                 'qemu-system-aarch64 -M virt,gic-version=3 '\n                 '-cpu host -enable-kvm -m 512M '\n                 '-M confidential-guest-support=rme0 '\n                 '-object rme-guest,id=rme0 '\n                 '-device virtio-net-pci,netdev=net0,romfile= '\n                 '-netdev user,id=net0 '\n                 '-kernel /mnt/out/bin/Image '",
        "detail": "qemu.tests.functional.test_aarch64_rme_virt",
        "documentation": {}
    },
    {
        "label": "Aarch64SbsarefMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_sbsaref",
        "description": "qemu.tests.functional.test_aarch64_sbsaref",
        "peekOfCode": "class Aarch64SbsarefMachine(QemuSystemTest):\n    \"\"\"\n    As firmware runs at a higher privilege level than the hypervisor we\n    can only run these tests under TCG emulation.\n    \"\"\"\n    timeout = 180\n    ASSET_FLASH0 = Asset(\n        ('https://artifacts.codelinaro.org/artifactory/linaro-419-sbsa-ref/'\n         '20241122-189881/edk2/SBSA_FLASH0.fd.xz'),\n        '76eb89d42eebe324e4395329f47447cda9ac920aabcf99aca85424609c3384a5')",
        "detail": "qemu.tests.functional.test_aarch64_sbsaref",
        "documentation": {}
    },
    {
        "label": "fetch_firmware",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_aarch64_sbsaref",
        "description": "qemu.tests.functional.test_aarch64_sbsaref",
        "peekOfCode": "def fetch_firmware(test):\n    \"\"\"\n    Flash volumes generated using:\n    Toolchain from Debian:\n    aarch64-linux-gnu-gcc (Debian 12.2.0-14) 12.2.0\n    Used components:\n    - Trusted Firmware         v2.12.0\n    - Tianocore EDK2           edk2-stable202411\n    - Tianocore EDK2-platforms 4b3530d\n    \"\"\"",
        "detail": "qemu.tests.functional.test_aarch64_sbsaref",
        "documentation": {}
    },
    {
        "label": "Aarch64SbsarefAlpine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_sbsaref_alpine",
        "description": "qemu.tests.functional.test_aarch64_sbsaref_alpine",
        "peekOfCode": "class Aarch64SbsarefAlpine(QemuSystemTest):\n    ASSET_ALPINE_ISO = Asset(\n        ('https://dl-cdn.alpinelinux.org/'\n         'alpine/v3.17/releases/aarch64/alpine-standard-3.17.2-aarch64.iso'),\n        '5a36304ecf039292082d92b48152a9ec21009d3a62f459de623e19c4bd9dc027')\n    # This tests the whole boot chain from EFI to Userspace\n    # We only boot a whole OS for the current top level CPU and GIC\n    # Other test profiles should use more minimal boots\n    def boot_alpine_linux(self, cpu=None):\n        fetch_firmware(self)",
        "detail": "qemu.tests.functional.test_aarch64_sbsaref_alpine",
        "documentation": {}
    },
    {
        "label": "Aarch64SbsarefFreeBSD",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_sbsaref_freebsd",
        "description": "qemu.tests.functional.test_aarch64_sbsaref_freebsd",
        "peekOfCode": "class Aarch64SbsarefFreeBSD(QemuSystemTest):\n    ASSET_FREEBSD_ISO = Asset(\n        ('https://download.freebsd.org/releases/arm64/aarch64/ISO-IMAGES/'\n         '14.1/FreeBSD-14.1-RELEASE-arm64-aarch64-bootonly.iso'),\n        '44cdbae275ef1bb6dab1d5fbb59473d4f741e1c8ea8a80fd9e906b531d6ad461')\n    # This tests the whole boot chain from EFI to Userspace\n    # We only boot a whole OS for the current top level CPU and GIC\n    # Other test profiles should use more minimal boots\n    def boot_freebsd14(self, cpu=None):\n        fetch_firmware(self)",
        "detail": "qemu.tests.functional.test_aarch64_sbsaref_freebsd",
        "documentation": {}
    },
    {
        "label": "SMMU",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_smmu",
        "description": "qemu.tests.functional.test_aarch64_smmu",
        "peekOfCode": "class SMMU(LinuxKernelTest):\n    default_kernel_params = ('earlyprintk=pl011,0x9000000 no_timer_check '\n                             'printk.time=1 rd_NO_PLYMOUTH net.ifnames=0 '\n                             'console=ttyAMA0 rd.rescue')\n    IOMMU_ADDON = ',iommu_platform=on,disable-modern=off,disable-legacy=on'\n    kernel_path = None\n    initrd_path = None\n    kernel_params = None\n    GUEST_PORT = 8080\n    def set_up_boot(self, path):",
        "detail": "qemu.tests.functional.test_aarch64_smmu",
        "documentation": {}
    },
    {
        "label": "PluginKernelBase",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_tcg_plugins",
        "description": "qemu.tests.functional.test_aarch64_tcg_plugins",
        "peekOfCode": "class PluginKernelBase(LinuxKernelTest):\n    \"\"\"\n    Boots a Linux kernel with a TCG plugin enabled.\n    \"\"\"\n    timeout = 120\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=1 panic=-1 '\n    def run_vm(self, kernel_path, kernel_command_line,\n               plugin, plugin_log, console_pattern, args=None):\n        vm = self.get_vm()\n        vm.set_console()",
        "detail": "qemu.tests.functional.test_aarch64_tcg_plugins",
        "documentation": {}
    },
    {
        "label": "PluginKernelNormal",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_tcg_plugins",
        "description": "qemu.tests.functional.test_aarch64_tcg_plugins",
        "peekOfCode": "class PluginKernelNormal(PluginKernelBase):\n    ASSET_KERNEL = Asset(\n        ('https://storage.tuxboot.com/20230331/arm64/Image'),\n        'ce95a7101a5fecebe0fe630deee6bd97b32ba41bc8754090e9ad8961ea8674c7')\n    def test_aarch64_virt_insn(self):\n        self.set_machine('virt')\n        self.cpu='cortex-a53'\n        kernel_path = self.ASSET_KERNEL.fetch()\n        kernel_command_line = (self.KERNEL_COMMON_COMMAND_LINE +\n                               'console=ttyAMA0')",
        "detail": "qemu.tests.functional.test_aarch64_tcg_plugins",
        "documentation": {}
    },
    {
        "label": "TuxRunAarch64Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_tuxrun",
        "description": "qemu.tests.functional.test_aarch64_tuxrun",
        "peekOfCode": "class TuxRunAarch64Test(TuxRunBaselineTest):\n    ASSET_ARM64_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/arm64/Image',\n        'b74743c5e89e1cea0f73368d24ae0ae85c5204ff84be3b5e9610417417d2f235')\n    ASSET_ARM64_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/arm64/rootfs.ext4.zst',\n        'a1acaaae2068df4648d04ff75f532aaa8c5edcd6b936122b6f0db4848a07b465')\n    def test_arm64(self):\n        self.set_machine('virt')\n        self.cpu='cortex-a57'",
        "detail": "qemu.tests.functional.test_aarch64_tuxrun",
        "documentation": {}
    },
    {
        "label": "Aarch64VirtMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_virt",
        "description": "qemu.tests.functional.test_aarch64_virt",
        "peekOfCode": "class Aarch64VirtMachine(QemuSystemTest):\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    timeout = 360\n    def wait_for_console_pattern(self, success_message, vm=None):\n        wait_for_console_pattern(self, success_message,\n                                 failure_message='Kernel panic - not syncing',\n                                 vm=vm)\n    ASSET_ALPINE_ISO = Asset(\n        ('https://dl-cdn.alpinelinux.org/'\n         'alpine/v3.17/releases/aarch64/alpine-standard-3.17.2-aarch64.iso'),",
        "detail": "qemu.tests.functional.test_aarch64_virt",
        "documentation": {}
    },
    {
        "label": "Aarch64VirtGPUMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_virt_gpu",
        "description": "qemu.tests.functional.test_aarch64_virt_gpu",
        "peekOfCode": "class Aarch64VirtGPUMachine(LinuxKernelTest):\n    ASSET_VIRT_GPU_KERNEL = Asset(\n        'https://fileserver.linaro.org/s/ce5jXBFinPxtEdx/'\n        'download?path=%2F&files='\n        'Image.6.12.16.aarch64',\n        '7888c51c55d37e86bbbdeb5acea9f08c34e6b0f03c1f5b2463285f6a6f6eec8b')\n    ASSET_VIRT_GPU_ROOTFS = Asset(\n        'https://fileserver.linaro.org/s/ce5jXBFinPxtEdx/'\n        'download?path=%2F&files='\n        'rootfs.aarch64.ext2.zstd',",
        "detail": "qemu.tests.functional.test_aarch64_virt_gpu",
        "documentation": {}
    },
    {
        "label": "BootXen",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_xen",
        "description": "qemu.tests.functional.test_aarch64_xen",
        "peekOfCode": "class BootXen(LinuxKernelTest):\n    \"\"\"\n    Boots a Xen hypervisor with a Linux DomU kernel.\n    \"\"\"\n    timeout = 90\n    XEN_COMMON_COMMAND_LINE = 'dom0_mem=128M loglvl=all guest_loglvl=all'\n    ASSET_KERNEL = Asset(\n        ('https://fileserver.linaro.org/s/JSsewXGZ6mqxPr5/'\n         'download?path=%2F&files=linux-5.9.9-arm64-ajb'),\n        '00366fa51ea957c19462d2e2aefd480bef80ce727120e714ae48e0c88f261edb')",
        "detail": "qemu.tests.functional.test_aarch64_xen",
        "documentation": {}
    },
    {
        "label": "XlnxVersalVirtMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_aarch64_xlnx_versal",
        "description": "qemu.tests.functional.test_aarch64_xlnx_versal",
        "peekOfCode": "class XlnxVersalVirtMachine(LinuxKernelTest):\n    ASSET_KERNEL = Asset(\n        ('http://ports.ubuntu.com/ubuntu-ports/dists/bionic-updates/main/'\n         'installer-arm64/20101020ubuntu543.19/images/netboot/'\n         'ubuntu-installer/arm64/linux'),\n        'ce54f74ab0b15cfd13d1a293f2d27ffd79d8a85b7bb9bf21093ae9513864ac79')\n    ASSET_INITRD = Asset(\n        ('http://ports.ubuntu.com/ubuntu-ports/dists/bionic-updates/main/'\n         'installer-arm64/20101020ubuntu543.19/images/netboot/'\n         '/ubuntu-installer/arm64/initrd.gz'),",
        "detail": "qemu.tests.functional.test_aarch64_xlnx_versal",
        "documentation": {}
    },
    {
        "label": "QEMUBitsMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_acpi_bits",
        "description": "qemu.tests.functional.test_acpi_bits",
        "peekOfCode": "class QEMUBitsMachine(QEMUMachine): # pylint: disable=too-few-public-methods\n    \"\"\"\n    A QEMU VM, with isa-debugcon enabled and bits iso passed\n    using -cdrom to QEMU commandline.\n    \"\"\"\n    def __init__(self,\n                 binary: str,\n                 args: Sequence[str] = (),\n                 wrapper: Sequence[str] = (),\n                 name: Optional[str] = None,",
        "detail": "qemu.tests.functional.test_acpi_bits",
        "documentation": {}
    },
    {
        "label": "AcpiBitsTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_acpi_bits",
        "description": "qemu.tests.functional.test_acpi_bits",
        "peekOfCode": "class AcpiBitsTest(QemuSystemTest): #pylint: disable=too-many-instance-attributes\n    \"\"\"\n    ACPI and SMBIOS tests using biosbits.\n    \"\"\"\n    # in slower systems the test can take as long as 3 minutes to complete.\n    timeout = BITS_TIMEOUT\n    # following are some standard configuration constants\n    # gitlab CI does shallow clones of depth 20\n    BITS_INTERNAL_VER = 2020\n    # commit hash must match the artifact tag below",
        "detail": "qemu.tests.functional.test_acpi_bits",
        "documentation": {}
    },
    {
        "label": "BITS_TIMEOUT",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_acpi_bits",
        "description": "qemu.tests.functional.test_acpi_bits",
        "peekOfCode": "BITS_TIMEOUT = 200\nclass QEMUBitsMachine(QEMUMachine): # pylint: disable=too-few-public-methods\n    \"\"\"\n    A QEMU VM, with isa-debugcon enabled and bits iso passed\n    using -cdrom to QEMU commandline.\n    \"\"\"\n    def __init__(self,\n                 binary: str,\n                 args: Sequence[str] = (),\n                 wrapper: Sequence[str] = (),",
        "detail": "qemu.tests.functional.test_acpi_bits",
        "documentation": {}
    },
    {
        "label": "AlphaClipperTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_alpha_clipper",
        "description": "qemu.tests.functional.test_alpha_clipper",
        "peekOfCode": "class AlphaClipperTest(LinuxKernelTest):\n    ASSET_KERNEL = Asset(\n        ('http://archive.debian.org/debian/dists/lenny/main/'\n         'installer-alpha/20090123lenny10/images/cdrom/vmlinuz'),\n        '34f53da3fa32212e4f00b03cb944b2ad81c06bc8faaf9b7193b2e544ceeca576')\n    def test_alpha_clipper(self):\n        self.set_machine('clipper')\n        kernel_path = self.ASSET_KERNEL.fetch()\n        uncompressed_kernel = self.uncompress(self.ASSET_KERNEL, format=\"gz\")\n        self.vm.set_console()",
        "detail": "qemu.tests.functional.test_alpha_clipper",
        "documentation": {}
    },
    {
        "label": "AlphaReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_alpha_replay",
        "description": "qemu.tests.functional.test_alpha_replay",
        "peekOfCode": "class AlphaReplay(ReplayKernelBase):\n    ASSET_KERNEL = Asset(\n        ('http://archive.debian.org/debian/dists/lenny/main/installer-alpha/'\n         '20090123lenny10/images/cdrom/vmlinuz'),\n        '34f53da3fa32212e4f00b03cb944b2ad81c06bc8faaf9b7193b2e544ceeca576')\n    def test_clipper(self):\n        self.set_machine('clipper')\n        kernel_path = self.uncompress(self.ASSET_KERNEL, format='gz')\n        kernel_command_line = self.KERNEL_COMMON_COMMAND_LINE + 'console=ttyS0'\n        console_pattern = 'Kernel command line: %s' % kernel_command_line",
        "detail": "qemu.tests.functional.test_alpha_replay",
        "documentation": {}
    },
    {
        "label": "AST1030Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_ast1030",
        "description": "qemu.tests.functional.test_arm_aspeed_ast1030",
        "peekOfCode": "class AST1030Machine(LinuxKernelTest):\n    ASSET_ZEPHYR_1_04 = Asset(\n        ('https://github.com/AspeedTech-BMC'\n         '/zephyr/releases/download/v00.01.04/ast1030-evb-demo.zip'),\n        '4ac6210adcbc61294927918707c6762483fd844dde5e07f3ba834ad1f91434d3')\n    def test_ast1030_zephyros_1_04(self):\n        self.set_machine('ast1030-evb')\n        kernel_name = \"ast1030-evb-demo/zephyr.elf\"\n        kernel_file = self.archive_extract(\n            self.ASSET_ZEPHYR_1_04, member=kernel_name)",
        "detail": "qemu.tests.functional.test_arm_aspeed_ast1030",
        "documentation": {}
    },
    {
        "label": "AST2500Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_ast2500",
        "description": "qemu.tests.functional.test_arm_aspeed_ast2500",
        "peekOfCode": "class AST2500Machine(AspeedTest):\n    ASSET_BR2_202411_AST2500_FLASH = Asset(\n        ('https://github.com/legoater/qemu-aspeed-boot/raw/master/'\n         'images/ast2500-evb/buildroot-2024.11/flash.img'),\n        '641e6906c18c0f19a2aeb48099d66d4771929c361001d554d0d45c667413e13a')\n    def test_arm_ast2500_evb_buildroot(self):\n        self.set_machine('ast2500-evb')\n        image_path = self.ASSET_BR2_202411_AST2500_FLASH.fetch()\n        self.vm.add_args('-device',\n                         'tmp105,bus=aspeed.i2c.bus.3,address=0x4d,id=tmp-test')",
        "detail": "qemu.tests.functional.test_arm_aspeed_ast2500",
        "documentation": {}
    },
    {
        "label": "AST2600Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_ast2600",
        "description": "qemu.tests.functional.test_arm_aspeed_ast2600",
        "peekOfCode": "class AST2600Machine(AspeedTest):\n    ASSET_BR2_202411_AST2600_FLASH = Asset(\n        ('https://github.com/legoater/qemu-aspeed-boot/raw/master/'\n         'images/ast2600-evb/buildroot-2024.11/flash.img'),\n        '4bb2f3dfdea31199b51d66b42f686dc5374c144a7346fdc650194a5578b73609')\n    def test_arm_ast2600_evb_buildroot(self):\n        self.set_machine('ast2600-evb')\n        image_path = self.ASSET_BR2_202411_AST2600_FLASH.fetch()\n        self.vm.add_args('-device',\n                         'tmp105,bus=aspeed.i2c.bus.3,address=0x4d,id=tmp-test')",
        "detail": "qemu.tests.functional.test_arm_aspeed_ast2600",
        "documentation": {}
    },
    {
        "label": "BletchleyMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_bletchley",
        "description": "qemu.tests.functional.test_arm_aspeed_bletchley",
        "peekOfCode": "class BletchleyMachine(AspeedTest):\n    ASSET_BLETCHLEY_FLASH = Asset(\n        'https://github.com/legoater/qemu-aspeed-boot/raw/master/images/bletchley-bmc/openbmc-20250128071329/obmc-phosphor-image-bletchley-20250128071329.static.mtd.xz',\n        'db21d04d47d7bb2a276f59d308614b4dfb70b9c7c81facbbca40a3977a2d8844')\n    def test_arm_ast2600_bletchley_openbmc(self):\n        image_path = self.uncompress(self.ASSET_BLETCHLEY_FLASH)\n        self.do_test_arm_aspeed_openbmc('bletchley-bmc', image=image_path,\n                                        uboot='2019.04', cpu_id='0xf00',\n                                        soc='AST2600 rev A3')\nif __name__ == '__main__':",
        "detail": "qemu.tests.functional.test_arm_aspeed_bletchley",
        "documentation": {}
    },
    {
        "label": "PalmettoMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_palmetto",
        "description": "qemu.tests.functional.test_arm_aspeed_palmetto",
        "peekOfCode": "class PalmettoMachine(AspeedTest):\n    ASSET_PALMETTO_FLASH = Asset(\n        'https://github.com/legoater/qemu-aspeed-boot/raw/master/images/palmetto-bmc/openbmc-20250128071432/obmc-phosphor-image-palmetto-20250128071432.static.mtd',\n        'bce7c392eec75c707a91cfc8fad7ca9a69d7e4f10df936930d65c1cb9897ac81')\n    def test_arm_ast2400_palmetto_openbmc(self):\n        image_path = self.ASSET_PALMETTO_FLASH.fetch()\n        self.do_test_arm_aspeed_openbmc('palmetto-bmc', image=image_path,\n                                        uboot='2019.04', cpu_id='0x0',\n                                        soc='AST2400 rev A1')\nif __name__ == '__main__':",
        "detail": "qemu.tests.functional.test_arm_aspeed_palmetto",
        "documentation": {}
    },
    {
        "label": "RainierMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_rainier",
        "description": "qemu.tests.functional.test_arm_aspeed_rainier",
        "peekOfCode": "class RainierMachine(AspeedTest):\n    ASSET_RAINIER_EMMC = Asset(\n        ('https://fileserver.linaro.org/s/B6pJTwWEkzSDi36/download/'\n         'mmc-p10bmc-20240617.qcow2'),\n        'd523fb478d2b84d5adc5658d08502bc64b1486955683814f89c6137518acd90b')\n    def test_arm_aspeed_emmc_boot(self):\n        self.set_machine('rainier-bmc')\n        self.require_netdev('user')\n        image_path = self.ASSET_RAINIER_EMMC.fetch()\n        self.vm.set_console()",
        "detail": "qemu.tests.functional.test_arm_aspeed_rainier",
        "documentation": {}
    },
    {
        "label": "RomulusMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_romulus",
        "description": "qemu.tests.functional.test_arm_aspeed_romulus",
        "peekOfCode": "class RomulusMachine(AspeedTest):\n    ASSET_ROMULUS_FLASH = Asset(\n        'https://github.com/legoater/qemu-aspeed-boot/raw/master/images/romulus-bmc/openbmc-20250128071340/obmc-phosphor-image-romulus-20250128071340.static.mtd',\n        '6d031376440c82ed9d087d25e9fa76aea75b42f80daa252ec402c0bc3cf6cf5b')\n    def test_arm_ast2500_romulus_openbmc(self):\n        image_path = self.ASSET_ROMULUS_FLASH.fetch()\n        self.do_test_arm_aspeed_openbmc('romulus-bmc', image=image_path,\n                                        uboot='2019.04', cpu_id='0x0',\n                                        soc='AST2500 rev A1')\nif __name__ == '__main__':",
        "detail": "qemu.tests.functional.test_arm_aspeed_romulus",
        "documentation": {}
    },
    {
        "label": "WitherspoonMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_aspeed_witherspoon",
        "description": "qemu.tests.functional.test_arm_aspeed_witherspoon",
        "peekOfCode": "class WitherspoonMachine(AspeedTest):\n    ASSET_WITHERSPOON_FLASH = Asset(\n        'https://github.com/legoater/qemu-aspeed-boot/raw/master/images/witherspoon-bmc/openbmc-20240618035022/obmc-phosphor-image-witherspoon-20240618035022.ubi.mtd',\n        '937d9ed449ea6c6cbed983519088a42d0cafe276bcfe4fce07772ca6673f9213')\n    def test_arm_ast2500_witherspoon_openbmc(self):\n        image_path = self.ASSET_WITHERSPOON_FLASH.fetch()\n        self.do_test_arm_aspeed_openbmc('witherspoon-bmc', image=image_path,\n                                        uboot='2016.07', cpu_id='0x0',\n                                        soc='AST2500 rev A1')\nif __name__ == '__main__':",
        "detail": "qemu.tests.functional.test_arm_aspeed_witherspoon",
        "documentation": {}
    },
    {
        "label": "LoadBFLT",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_bflt",
        "description": "qemu.tests.functional.test_arm_bflt",
        "peekOfCode": "class LoadBFLT(QemuUserTest):\n    ASSET_ROOTFS = Asset(\n        ('https://elinux.org/images/5/51/Stm32_mini_rootfs.cpio.bz2'),\n         'eefb788e4980c9e8d6c9d60ce7d15d4da6bf4fbc6a80f487673824600d5ba9cc')\n    @skipIfMissingCommands('cpio')\n    @skipUntrustedTest()\n    def test_stm32(self):\n        # See https://elinux.org/STM32#User_Space\n        rootfs_path_bz2 = self.ASSET_ROOTFS.fetch()\n        busybox_path = self.scratch_file(\"bin\", \"busybox\")",
        "detail": "qemu.tests.functional.test_arm_bflt",
        "documentation": {}
    },
    {
        "label": "BananaPiMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_bpim2u",
        "description": "qemu.tests.functional.test_arm_bpim2u",
        "peekOfCode": "class BananaPiMachine(LinuxKernelTest):\n    ASSET_DEB = Asset(\n        ('https://apt.armbian.com/pool/main/l/linux-6.6.16/'\n         'linux-image-current-sunxi_24.2.1_armhf__6.6.16-Seb3e-D6b4a-P2359-Ce96bHfe66-HK01ba-V014b-B067e-R448a.deb'),\n        '3d968c15b121ede871dce49d13ee7644d6f74b6b121b84c9a40f51b0c80d6d22')\n    ASSET_INITRD = Asset(\n        ('https://github.com/groeck/linux-build-test/raw/'\n         '2eb0a73b5d5a28df3170c546ddaaa9757e1e0848/rootfs/'\n         'arm/rootfs-armv7a.cpio.gz'),\n        '2c8dbdb16ea7af2dfbcbea96044dde639fb07d09fd3c4fb31f2027ef71e55ddd')",
        "detail": "qemu.tests.functional.test_arm_bpim2u",
        "documentation": {}
    },
    {
        "label": "CanonA1100Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_canona1100",
        "description": "qemu.tests.functional.test_arm_canona1100",
        "peekOfCode": "class CanonA1100Machine(QemuSystemTest):\n    \"\"\"Boots the barebox firmware and checks that the console is operational\"\"\"\n    timeout = 90\n    ASSET_BIOS = Asset(('https://qemu-advcal.gitlab.io'\n                        '/qac-best-of-multiarch/download/day18.tar.xz'),\n                       '28e71874ce985be66b7fd1345ed88cb2523b982f899c8d2900d6353054a1be49')\n    def test_arm_canona1100(self):\n        self.set_machine('canon-a1100')\n        bios = self.archive_extract(self.ASSET_BIOS,\n                                    member=\"day18/barebox.canon-a1100.bin\")",
        "detail": "qemu.tests.functional.test_arm_canona1100",
        "documentation": {}
    },
    {
        "label": "CollieTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_collie",
        "description": "qemu.tests.functional.test_arm_collie",
        "peekOfCode": "class CollieTest(LinuxKernelTest):\n    ASSET_ZIMAGE = Asset(\n        'https://github.com/groeck/linux-test-downloads/raw/225223f2ad7d637b34426810bf6c3b727b76a718/collie/zImage',\n        '10ace8abf9e0875ef8a83b8829cc3b5b50bc6d7bc3ca29f19f49f5673a43c13b')\n    ASSET_ROOTFS = Asset(\n        'https://github.com/groeck/linux-test-downloads/raw/225223f2ad7d637b34426810bf6c3b727b76a718/collie/rootfs-sa110.cpio',\n        '89ccaaa5c6b33331887047e1618ffe81b0f55909173944347d5d2426f3bcc1f2')\n    def test_arm_collie(self):\n        self.set_machine('collie')\n        zimage_path = self.ASSET_ZIMAGE.fetch()",
        "detail": "qemu.tests.functional.test_arm_collie",
        "documentation": {}
    },
    {
        "label": "CubieboardMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_cubieboard",
        "description": "qemu.tests.functional.test_arm_cubieboard",
        "peekOfCode": "class CubieboardMachine(LinuxKernelTest):\n    ASSET_DEB = Asset(\n        ('https://apt.armbian.com/pool/main/l/linux-6.6.16/'\n         'linux-image-current-sunxi_24.2.1_armhf__6.6.16-Seb3e-D6b4a-P2359-Ce96bHfe66-HK01ba-V014b-B067e-R448a.deb'),\n        '3d968c15b121ede871dce49d13ee7644d6f74b6b121b84c9a40f51b0c80d6d22')\n    ASSET_INITRD = Asset(\n        ('https://github.com/groeck/linux-build-test/raw/'\n         '2eb0a73b5d5a28df3170c546ddaaa9757e1e0848/rootfs/'\n         'arm/rootfs-armv5.cpio.gz'),\n        '334b8d256db67a3f2b3ad070aa08b5ade39624e0e7e35b02f4359a577bc8f39b')",
        "detail": "qemu.tests.functional.test_arm_cubieboard",
        "documentation": {}
    },
    {
        "label": "EmcraftSf2Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_emcraft_sf2",
        "description": "qemu.tests.functional.test_arm_emcraft_sf2",
        "peekOfCode": "class EmcraftSf2Machine(LinuxKernelTest):\n    ASSET_UBOOT = Asset(\n        ('https://raw.githubusercontent.com/Subbaraya-Sundeep/qemu-test-binaries/'\n         'fe371d32e50ca682391e1e70ab98c2942aeffb01/u-boot'),\n        '5c6a15103375db11b21f2236473679a9dbbed6d89652bfcdd501c263d68ab725')\n    ASSET_SPI = Asset(\n        ('https://raw.githubusercontent.com/Subbaraya-Sundeep/qemu-test-binaries/'\n         'fe371d32e50ca682391e1e70ab98c2942aeffb01/spi.bin'),\n        'cd9bdd2c4cb55a59c3adb6bcf74881667c4500dde0570a43aa3be2b17eecfdb6')\n    def test_arm_emcraft_sf2(self):",
        "detail": "qemu.tests.functional.test_arm_emcraft_sf2",
        "documentation": {}
    },
    {
        "label": "IntegratorMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_integratorcp",
        "description": "qemu.tests.functional.test_arm_integratorcp",
        "peekOfCode": "class IntegratorMachine(QemuSystemTest):\n    timeout = 90\n    ASSET_KERNEL = Asset(\n        ('https://github.com/zayac/qemu-arm/raw/master/'\n         'arm-test/kernel/zImage.integrator'),\n        '26e7c7e8f943de785d95bd3c74d66451604a9b6a7a3d25dceb279e7548fd8e78')\n    ASSET_INITRD = Asset(\n        ('https://github.com/zayac/qemu-arm/raw/master/'\n         'arm-test/kernel/arm_root.img'),\n        'e187c27fb342ad148c7f33475fbed124933e0b3f4be8c74bc4f3426a4793373a')",
        "detail": "qemu.tests.functional.test_arm_integratorcp",
        "documentation": {}
    },
    {
        "label": "MicrobitMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_microbit",
        "description": "qemu.tests.functional.test_arm_microbit",
        "peekOfCode": "class MicrobitMachine(QemuSystemTest):\n    ASSET_MICRO = Asset('https://ozlabs.org/~joel/microbit-micropython.hex',\n        '021641f93dfb11767d4978dbb3ca7f475d1b13c69e7f4aec3382f212636bffd6')\n    def test_arm_microbit(self):\n        self.set_machine('microbit')\n        micropython = self.ASSET_MICRO.fetch()\n        self.vm.set_console()\n        self.vm.add_args('-device', f'loader,file={micropython}')\n        self.vm.launch()\n        wait_for_console_pattern(self, 'Type \"help()\" for more information.')",
        "detail": "qemu.tests.functional.test_arm_microbit",
        "documentation": {}
    },
    {
        "label": "OrangePiMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_orangepi",
        "description": "qemu.tests.functional.test_arm_orangepi",
        "peekOfCode": "class OrangePiMachine(LinuxKernelTest):\n    ASSET_DEB = Asset(\n        ('https://apt.armbian.com/pool/main/l/linux-6.6.16/'\n         'linux-image-current-sunxi_24.2.1_armhf__6.6.16-Seb3e-D6b4a-P2359-Ce96bHfe66-HK01ba-V014b-B067e-R448a.deb'),\n        '3d968c15b121ede871dce49d13ee7644d6f74b6b121b84c9a40f51b0c80d6d22')\n    ASSET_INITRD = Asset(\n        ('https://github.com/groeck/linux-build-test/raw/'\n         '2eb0a73b5d5a28df3170c546ddaaa9757e1e0848/rootfs/'\n         'arm/rootfs-armv7a.cpio.gz'),\n        '2c8dbdb16ea7af2dfbcbea96044dde639fb07d09fd3c4fb31f2027ef71e55ddd')",
        "detail": "qemu.tests.functional.test_arm_orangepi",
        "documentation": {}
    },
    {
        "label": "EmcraftSf2Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_quanta_gsj",
        "description": "qemu.tests.functional.test_arm_quanta_gsj",
        "peekOfCode": "class EmcraftSf2Machine(LinuxKernelTest):\n    ASSET_IMAGE = Asset(\n        ('https://github.com/hskinnemoen/openbmc/releases/download/'\n         '20200711-gsj-qemu-0/obmc-phosphor-image-gsj.static.mtd.gz'),\n        'eccd4e375cde53034c84aece5c511932cacf838d9fd3f63da368a511757da72b')\n    ASSET_INITRD = Asset(\n        ('https://github.com/hskinnemoen/openbmc/releases/download/'\n         '20200711-gsj-qemu-0/obmc-phosphor-initramfs-gsj.cpio.xz'),\n        '37b05009fc54db1434beac12bd7ff99a2e751a2f032ee18d9042f991dd0cdeaa')\n    ASSET_KERNEL = Asset(",
        "detail": "qemu.tests.functional.test_arm_quanta_gsj",
        "documentation": {}
    },
    {
        "label": "ArmRaspi2Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_raspi2",
        "description": "qemu.tests.functional.test_arm_raspi2",
        "peekOfCode": "class ArmRaspi2Machine(LinuxKernelTest):\n    ASSET_KERNEL_20190215 = Asset(\n        ('http://archive.raspberrypi.org/debian/'\n         'pool/main/r/raspberrypi-firmware/'\n         'raspberrypi-kernel_1.20190215-1_armhf.deb'),\n        '9f1759f7228113da24f5ee2aa6312946ec09a83e076aba9406c46ff776dfb291')\n    ASSET_INITRD = Asset(\n        ('https://github.com/groeck/linux-build-test/raw/'\n         '2eb0a73b5d5a28df3170c546ddaaa9757e1e0848/rootfs/'\n         'arm/rootfs-armv7a.cpio.gz'),",
        "detail": "qemu.tests.functional.test_arm_raspi2",
        "documentation": {}
    },
    {
        "label": "ArmReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_replay",
        "description": "qemu.tests.functional.test_arm_replay",
        "peekOfCode": "class ArmReplay(ReplayKernelBase):\n    ASSET_VIRT = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/'\n         'releases/29/Everything/armhfp/os/images/pxeboot/vmlinuz'),\n        '18dd5f1a9a28bd539f9d047f7c0677211bae528e8712b40ca5a229a4ad8e2591')\n    def test_virt(self):\n        self.set_machine('virt')\n        kernel_path = self.ASSET_VIRT.fetch()\n        kernel_command_line = (self.KERNEL_COMMON_COMMAND_LINE +\n                               'console=ttyAMA0')",
        "detail": "qemu.tests.functional.test_arm_replay",
        "documentation": {}
    },
    {
        "label": "Smdkc210Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_smdkc210",
        "description": "qemu.tests.functional.test_arm_smdkc210",
        "peekOfCode": "class Smdkc210Machine(LinuxKernelTest):\n    ASSET_DEB = Asset(\n        ('https://snapshot.debian.org/archive/debian/20190928T224601Z/pool/'\n         'main/l/linux/linux-image-4.19.0-6-armmp_4.19.67-2+deb10u1_armhf.deb'),\n        '421804e7579ef40d554c962850dbdf1bfc79f7fa7faec9d391397170dc806c3e')\n    ASSET_ROOTFS = Asset(\n        ('https://github.com/groeck/linux-build-test/raw/'\n         '2eb0a73b5d5a28df3170c546ddaaa9757e1e0848/rootfs/arm/'\n         'rootfs-armv5.cpio.gz'),\n        '334b8d256db67a3f2b3ad070aa08b5ade39624e0e7e35b02f4359a577bc8f39b')",
        "detail": "qemu.tests.functional.test_arm_smdkc210",
        "documentation": {}
    },
    {
        "label": "SX1Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_sx1",
        "description": "qemu.tests.functional.test_arm_sx1",
        "peekOfCode": "class SX1Test(LinuxKernelTest):\n    ASSET_ZIMAGE = Asset(\n        'https://github.com/groeck/linux-test-downloads/raw/225223f2ad7d637b34426810bf6c3b727b76a718/sx1/zImage',\n        'a0271899a8dc2165f9e0adb2d0a57fc839ae3a469722ffc56c77e108a8887615')\n    ASSET_INITRD = Asset(\n        'https://github.com/groeck/linux-test-downloads/raw/225223f2ad7d637b34426810bf6c3b727b76a718/sx1/rootfs-armv4.cpio',\n        '35b0721249821aa544cd85b85d3cb8901db4c6d128eed86ab261e5d9e37d58f8')\n    ASSET_SD_FS = Asset(\n        'https://github.com/groeck/linux-test-downloads/raw/225223f2ad7d637b34426810bf6c3b727b76a718/sx1/rootfs-armv4.ext2',\n        'c1db7f43ef92469ebc8605013728c8950e7608439f01d13678994f0ce101c3a8')",
        "detail": "qemu.tests.functional.test_arm_sx1",
        "documentation": {}
    },
    {
        "label": "TuxRunArmTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_tuxrun",
        "description": "qemu.tests.functional.test_arm_tuxrun",
        "peekOfCode": "class TuxRunArmTest(TuxRunBaselineTest):\n    ASSET_ARMV5_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/armv5/zImage',\n        '3931a3908dbcf0ec0fe292d035ffc4dfed95f797dedd4a59ccfcf7a46e6f92d4')\n    ASSET_ARMV5_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/armv5/rootfs.ext4.zst',\n        '60ff78b68c7021df378e4fc2d66d3b016484d1acc7e07fb8920c1d8e30f4571f')\n    ASSET_ARMV5_DTB = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/armv5/versatile-pb.dtb',\n        '50988e69ef3f3b08bfb9146e8fe414129990029e8dfbed444953b7e14809530a')",
        "detail": "qemu.tests.functional.test_arm_tuxrun",
        "documentation": {}
    },
    {
        "label": "VExpressTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_vexpress",
        "description": "qemu.tests.functional.test_arm_vexpress",
        "peekOfCode": "class VExpressTest(LinuxKernelTest):\n    ASSET_DAY16 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day16.tar.xz',\n        '63311adb2d4c4e7a73214a86d29988add87266a909719c56acfadd026b4110a7')\n    def test_arm_vexpressa9(self):\n        self.set_machine('vexpress-a9')\n        self.archive_extract(self.ASSET_DAY16)\n        self.launch_kernel(self.scratch_file('day16', 'winter.zImage'),\n                           dtb=self.scratch_file('day16',\n                                                 'vexpress-v2p-ca9.dtb'),",
        "detail": "qemu.tests.functional.test_arm_vexpress",
        "documentation": {}
    },
    {
        "label": "ArmVirtMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_arm_virt",
        "description": "qemu.tests.functional.test_arm_virt",
        "peekOfCode": "class ArmVirtMachine(LinuxKernelTest):\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/'\n         'releases/29/Everything/armhfp/os/images/pxeboot/vmlinuz'),\n        '18dd5f1a9a28bd539f9d047f7c0677211bae528e8712b40ca5a229a4ad8e2591')\n    def test_arm_virt(self):\n        self.set_machine('virt')\n        kernel_path = self.ASSET_KERNEL.fetch()\n        self.vm.set_console()\n        kernel_command_line = (self.KERNEL_COMMON_COMMAND_LINE +",
        "detail": "qemu.tests.functional.test_arm_virt",
        "documentation": {}
    },
    {
        "label": "AVR6Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_avr_mega2560",
        "description": "qemu.tests.functional.test_avr_mega2560",
        "peekOfCode": "class AVR6Machine(QemuSystemTest):\n    timeout = 5\n    ASSET_ROM = Asset(('https://github.com/seharris/qemu-avr-tests'\n                       '/raw/36c3e67b8755dcf/free-rtos/Demo'\n                       '/AVR_ATMega2560_GCC/demo.elf'),\n                      'ee4833bd65fc69e84a79ed1c608affddbd499a60e63acf87d9113618401904e4')\n    def test_freertos(self):\n        \"\"\"\n        https://github.com/seharris/qemu-avr-tests/raw/master/free-rtos/Demo/AVR_ATMega2560_GCC/demo.elf\n        constantly prints out 'ABCDEFGHIJKLMNOPQRSTUVWXABCDEFGHIJKLMNOPQRSTUVWX'",
        "detail": "qemu.tests.functional.test_avr_mega2560",
        "documentation": {}
    },
    {
        "label": "QueryCPUModelExpansion",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_cpu_queries",
        "description": "qemu.tests.functional.test_cpu_queries",
        "peekOfCode": "class QueryCPUModelExpansion(QemuSystemTest):\n    \"\"\"\n    Run query-cpu-model-expansion for each CPU model, and validate results\n    \"\"\"\n    def test(self):\n        self.set_machine('none')\n        self.vm.add_args('-S')\n        self.vm.launch()\n        cpus = self.vm.cmd('query-cpu-definitions')\n        for c in cpus:",
        "detail": "qemu.tests.functional.test_cpu_queries",
        "documentation": {}
    },
    {
        "label": "EmptyCPUModel",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_empty_cpu_model",
        "description": "qemu.tests.functional.test_empty_cpu_model",
        "peekOfCode": "class EmptyCPUModel(QemuSystemTest):\n    def test(self):\n        self.vm.add_args('-S', '-display', 'none', '-machine', 'none', '-cpu', '')\n        self.vm.set_qmp_monitor(enabled=False)\n        self.vm.launch()\n        self.vm.wait()\n        self.assertEqual(self.vm.exitcode(), 1, \"QEMU exit code should be 1\")\n        self.assertRegex(self.vm.get_log(), r'-cpu option cannot be empty')\nif __name__ == '__main__':\n    QemuSystemTest.main()",
        "detail": "qemu.tests.functional.test_empty_cpu_model",
        "documentation": {}
    },
    {
        "label": "HppaSeabios",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_hppa_seabios",
        "description": "qemu.tests.functional.test_hppa_seabios",
        "peekOfCode": "class HppaSeabios(QemuSystemTest):\n    timeout = 5\n    MACH_BITS = {'B160L': 32, 'C3700': 64}\n    def boot_seabios(self):\n        mach = self.machine\n        bits = self.MACH_BITS[mach]\n        self.vm.set_console()\n        self.vm.launch()\n        self.machine\n        wait_for_console_pattern(self, f'SeaBIOS PA-RISC {bits}-bit Firmware')",
        "detail": "qemu.tests.functional.test_hppa_seabios",
        "documentation": {}
    },
    {
        "label": "I386Replay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_i386_replay",
        "description": "qemu.tests.functional.test_i386_replay",
        "peekOfCode": "class I386Replay(ReplayKernelBase):\n    ASSET_KERNEL = Asset(\n         'https://storage.tuxboot.com/20230331/i386/bzImage',\n        'a3e5b32a354729e65910f5a1ffcda7c14a6c12a55e8213fb86e277f1b76ed956')\n    def test_pc(self):\n        self.set_machine('pc')\n        kernel_url = ()\n        kernel_path = self.ASSET_KERNEL.fetch()\n        kernel_command_line = self.KERNEL_COMMON_COMMAND_LINE + 'console=ttyS0'\n        console_pattern = 'VFS: Cannot open root device'",
        "detail": "qemu.tests.functional.test_i386_replay",
        "documentation": {}
    },
    {
        "label": "TuxRunI386Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_i386_tuxrun",
        "description": "qemu.tests.functional.test_i386_tuxrun",
        "peekOfCode": "class TuxRunI386Test(TuxRunBaselineTest):\n    ASSET_I386_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/i386/bzImage',\n        '47fb44e38e34101eb0f71a2a01742b959d40ed5fd67cefb5608a39be11d3b74e')\n    ASSET_I386_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/i386/rootfs.ext4.zst',\n        'a1a3b3b4c9dccd6475b58db95c107b468b736b700f6620985a8ed050a73d51c8')\n    def test_i386(self):\n        self.set_machine('q35')\n        self.cpu=\"coreduo\"",
        "detail": "qemu.tests.functional.test_i386_tuxrun",
        "documentation": {}
    },
    {
        "label": "InfoUsernet",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_info_usernet",
        "description": "qemu.tests.functional.test_info_usernet",
        "peekOfCode": "class InfoUsernet(QemuSystemTest):\n    def test_hostfwd(self):\n        self.require_netdev('user')\n        self.set_machine('none')\n        self.vm.add_args('-netdev', 'user,id=vnet,hostfwd=:127.0.0.1:0-:22')\n        self.vm.launch()\n        port = get_usernet_hostfwd_port(self.vm)\n        self.assertIsNotNone(port,\n                             ('\"info usernet\" output content does not seem to '\n                              'contain the redirected port'))",
        "detail": "qemu.tests.functional.test_info_usernet",
        "documentation": {}
    },
    {
        "label": "IntelIOMMU",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_intel_iommu",
        "description": "qemu.tests.functional.test_intel_iommu",
        "peekOfCode": "class IntelIOMMU(LinuxKernelTest):\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/vmlinuz'),\n        'd4738d03dbbe083ca610d0821d0a8f1488bebbdccef54ce33e3adb35fda00129')\n    ASSET_INITRD = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/initrd.img'),\n        '277cd6c7adf77c7e63d73bbb2cded8ef9e2d3a2f100000e92ff1f8396513cd8b')\n    ASSET_DISKIMAGE = Asset(",
        "detail": "qemu.tests.functional.test_intel_iommu",
        "documentation": {}
    },
    {
        "label": "LinuxInitrd",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_linux_initrd",
        "description": "qemu.tests.functional.test_linux_initrd",
        "peekOfCode": "class LinuxInitrd(QemuSystemTest):\n    \"\"\"\n    Checks QEMU evaluates correctly the initrd file passed as -initrd option.\n    \"\"\"\n    timeout = 300\n    ASSET_F18_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/'\n         'releases/18/Fedora/x86_64/os/images/pxeboot/vmlinuz'),\n        '1a27cb42559ce29237ac186699d063556ad69c8349d732bb1bd8d614e5a8cc2e')\n    ASSET_F28_KERNEL = Asset(",
        "detail": "qemu.tests.functional.test_linux_initrd",
        "documentation": {}
    },
    {
        "label": "LoongArchMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_loongarch64_virt",
        "description": "qemu.tests.functional.test_loongarch64_virt",
        "peekOfCode": "class LoongArchMachine(QemuSystemTest):\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    timeout = 120\n    ASSET_KERNEL = Asset(\n        ('https://github.com/yangxiaojuan-loongson/qemu-binary/'\n         'releases/download/2024-11-26/vmlinuz.efi'),\n        '08b88a45f48a5fd92260bae895be4e5175be2397481a6f7821b9f39b2965b79e')\n    ASSET_INITRD = Asset(\n        ('https://github.com/yangxiaojuan-loongson/qemu-binary/'\n         'releases/download/2024-11-26/ramdisk'),",
        "detail": "qemu.tests.functional.test_loongarch64_virt",
        "documentation": {}
    },
    {
        "label": "Mcf5208EvbTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_m68k_mcf5208evb",
        "description": "qemu.tests.functional.test_m68k_mcf5208evb",
        "peekOfCode": "class Mcf5208EvbTest(LinuxKernelTest):\n    ASSET_DAY07 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day07.tar.xz',\n        '753c2f3837126b7c6ba92d0b1e0b156e8a2c5131d2d576bb0b9a763fae73c08a')\n    def test_m68k_mcf5208evb(self):\n        self.set_machine('mcf5208evb')\n        self.archive_extract(self.ASSET_DAY07)\n        self.vm.set_console()\n        self.vm.add_args('-kernel',\n                         self.scratch_file('day07', 'sanity-clause.elf'))",
        "detail": "qemu.tests.functional.test_m68k_mcf5208evb",
        "documentation": {}
    },
    {
        "label": "NextCubeMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_m68k_nextcube",
        "description": "qemu.tests.functional.test_m68k_nextcube",
        "peekOfCode": "class NextCubeMachine(QemuSystemTest):\n    timeout = 15\n    ASSET_ROM = Asset(('https://sourceforge.net/p/previous/code/1350/tree/'\n                       'trunk/src/Rev_2.5_v66.BIN?format=raw'),\n                      '1b753890b67095b73e104c939ddf62eca9e7d0aedde5108e3893b0ed9d8000a4')\n    def check_bootrom_framebuffer(self, screenshot_path):\n        rom_path = self.ASSET_ROM.fetch()\n        self.vm.add_args('-bios', rom_path)\n        self.vm.launch()\n        self.log.info('VM launched, waiting for display')",
        "detail": "qemu.tests.functional.test_m68k_nextcube",
        "documentation": {}
    },
    {
        "label": "Q800MachineTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_m68k_q800",
        "description": "qemu.tests.functional.test_m68k_q800",
        "peekOfCode": "class Q800MachineTest(LinuxKernelTest):\n    ASSET_KERNEL = Asset(\n        ('https://snapshot.debian.org/'\n         'archive/debian-ports/20191021T083923Z/pool-m68k/main/l/linux/'\n         'kernel-image-5.3.0-1-m68k-di_5.3.7-1_m68k.udeb'),\n        '949e50d74d4b9bc15d26c06d402717b7a4c0e32ff8100014f5930d8024de7b73')\n    def test_m68k_q800(self):\n        self.set_machine('q800')\n        kernel_path = self.archive_extract(self.ASSET_KERNEL,\n                                           member='boot/vmlinux-5.3.0-1-m68k')",
        "detail": "qemu.tests.functional.test_m68k_q800",
        "documentation": {}
    },
    {
        "label": "M68kReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_m68k_replay",
        "description": "qemu.tests.functional.test_m68k_replay",
        "peekOfCode": "class M68kReplay(ReplayKernelBase):\n    ASSET_Q800 = Asset(\n        ('https://snapshot.debian.org/'\n         'archive/debian-ports/20191021T083923Z/pool-m68k/main/l/linux/'\n         'kernel-image-5.3.0-1-m68k-di_5.3.7-1_m68k.udeb'),\n        '949e50d74d4b9bc15d26c06d402717b7a4c0e32ff8100014f5930d8024de7b73')\n    def test_q800(self):\n        self.set_machine('q800')\n        kernel_path = self.archive_extract(self.ASSET_Q800,\n                                           member='boot/vmlinux-5.3.0-1-m68k')",
        "detail": "qemu.tests.functional.test_m68k_replay",
        "documentation": {}
    },
    {
        "label": "TuxRunM68KTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_m68k_tuxrun",
        "description": "qemu.tests.functional.test_m68k_tuxrun",
        "peekOfCode": "class TuxRunM68KTest(TuxRunBaselineTest):\n    ASSET_M68K_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/m68k/vmlinux',\n        '7754e1d5cec753ccf1dc6894729a7f54c1a4965631ebf56df8e4ce1163ad19d8')\n    ASSET_M68K_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/m68k/rootfs.ext4.zst',\n        '557962ffff265607912e82232cf21adbe0e4e5a88e1e1d411ce848c37f0213e9')\n    def test_m68k(self):\n        self.set_machine('virt')\n        self.cpu=\"m68040\"",
        "detail": "qemu.tests.functional.test_m68k_tuxrun",
        "documentation": {}
    },
    {
        "label": "MemAddrCheck",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mem_addr_space",
        "description": "qemu.tests.functional.test_mem_addr_space",
        "peekOfCode": "class MemAddrCheck(QemuSystemTest):\n    # after launch, in order to generate the logs from QEMU we need to\n    # wait for some time. Launching and then immediately shutting down\n    # the VM generates empty logs. A delay of 1 second is added for\n    # this reason.\n    DELAY_Q35_BOOT_SEQUENCE = 1\n    # This helper can go away when the 32-bit host deprecation\n    # turns into full & final removal of support.\n    def ensure_64bit_binary(self):\n        with open(self.qemu_bin, \"rb\") as fh:",
        "detail": "qemu.tests.functional.test_mem_addr_space",
        "documentation": {}
    },
    {
        "label": "MicroblazeReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_microblaze_replay",
        "description": "qemu.tests.functional.test_microblaze_replay",
        "peekOfCode": "class MicroblazeReplay(ReplayKernelBase):\n    ASSET_DAY17 = Asset(\n        ('https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/'\n         'day17.tar.xz'),\n        '3ba7439dfbea7af4876662c97f8e1f0cdad9231fc166e4861d17042489270057')\n    def test_microblaze_s3adsp1800(self):\n        self.set_machine('petalogix-s3adsp1800')\n        kernel_path = self.archive_extract(self.ASSET_DAY17,\n                                           member='day17/ballerina.bin')\n        self.run_rr(kernel_path, self.REPLAY_KERNEL_COMMAND_LINE,",
        "detail": "qemu.tests.functional.test_microblaze_replay",
        "documentation": {}
    },
    {
        "label": "MicroblazeMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_microblaze_s3adsp1800",
        "description": "qemu.tests.functional.test_microblaze_s3adsp1800",
        "peekOfCode": "class MicroblazeMachine(QemuSystemTest):\n    timeout = 90\n    ASSET_IMAGE_BE = Asset(\n        ('https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/'\n         'day17.tar.xz'),\n        '3ba7439dfbea7af4876662c97f8e1f0cdad9231fc166e4861d17042489270057')\n    ASSET_IMAGE_LE = Asset(\n        ('http://www.qemu-advent-calendar.org/2023/download/day13.tar.gz'),\n        'b9b3d43c5dd79db88ada495cc6e0d1f591153fe41355e925d791fbf44de50c22')\n    def do_ballerina_be_test(self, machine):",
        "detail": "qemu.tests.functional.test_microblaze_s3adsp1800",
        "documentation": {}
    },
    {
        "label": "MicroblazeBigEndianMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_microblaze_s3adsp1800",
        "description": "qemu.tests.functional.test_microblaze_s3adsp1800",
        "peekOfCode": "class MicroblazeBigEndianMachine(MicroblazeMachine):\n    ASSET_IMAGE_BE = MicroblazeMachine.ASSET_IMAGE_BE\n    def test_microblaze_s3adsp1800_legacy_be(self):\n        self.do_ballerina_be_test('petalogix-s3adsp1800')\nif __name__ == '__main__':\n    QemuSystemTest.main()",
        "detail": "qemu.tests.functional.test_microblaze_s3adsp1800",
        "documentation": {}
    },
    {
        "label": "MicroblazeLittleEndianMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_microblazeel_s3adsp1800",
        "description": "qemu.tests.functional.test_microblazeel_s3adsp1800",
        "peekOfCode": "class MicroblazeLittleEndianMachine(MicroblazeMachine):\n    ASSET_IMAGE_LE = MicroblazeMachine.ASSET_IMAGE_LE\n    def test_microblaze_s3adsp1800_legacy_le(self):\n        self.do_xmaton_le_test('petalogix-s3adsp1800')\nif __name__ == '__main__':\n    MicroblazeMachine.main()",
        "detail": "qemu.tests.functional.test_microblazeel_s3adsp1800",
        "documentation": {}
    },
    {
        "label": "MigrationTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_migration",
        "description": "qemu.tests.functional.test_migration",
        "peekOfCode": "class MigrationTest(QemuSystemTest):\n    timeout = 10\n    @staticmethod\n    def migration_finished(vm):\n        return vm.cmd('query-migrate')['status'] in ('completed', 'failed')\n    def assert_migration(self, src_vm, dst_vm):\n        end = time.monotonic() + self.timeout\n        while time.monotonic() < end and not self.migration_finished(src_vm):\n           time.sleep(0.1)\n        end = time.monotonic() + self.timeout",
        "detail": "qemu.tests.functional.test_migration",
        "documentation": {}
    },
    {
        "label": "MaltaMachineConsole",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64_malta",
        "description": "qemu.tests.functional.test_mips64_malta",
        "peekOfCode": "class MaltaMachineConsole(LinuxKernelTest):\n    ASSET_WHEEZY_KERNEL = Asset(\n        ('https://people.debian.org/~aurel32/qemu/mips/'\n         'vmlinux-3.2.0-4-5kc-malta'),\n        '3e4ec154db080b3f1839f04dde83120654a33e5e1716863de576c47cb94f68f6')\n    ASSET_WHEEZY_DISK = Asset(\n        ('https://people.debian.org/~aurel32/qemu/mips/'\n         'debian_wheezy_mips_standard.qcow2'),\n        'de03599285b8382ad309309a6c4869f6c6c42a5cfc983342bab9ec0dfa7849a2')\n    def test_wheezy(self):",
        "detail": "qemu.tests.functional.test_mips64_malta",
        "documentation": {}
    },
    {
        "label": "TuxRunMips64Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64_tuxrun",
        "description": "qemu.tests.functional.test_mips64_tuxrun",
        "peekOfCode": "class TuxRunMips64Test(TuxRunBaselineTest):\n    ASSET_MIPS64_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips64/vmlinux',\n        'fe2882d216898ba2c56b49ba59f46ad392f36871f7fe325373cd926848b9dbdc')\n    ASSET_MIPS64_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips64/rootfs.ext4.zst',\n        'b8c98400216b6d4fb3b3ff05e9929aa015948b596cf0b82234813c84a4f7f4d5')\n    def test_mips64(self):\n        self.set_machine('malta')\n        self.root=\"sda\"",
        "detail": "qemu.tests.functional.test_mips64_tuxrun",
        "documentation": {}
    },
    {
        "label": "MipsFuloong2e",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64el_fuloong2e",
        "description": "qemu.tests.functional.test_mips64el_fuloong2e",
        "peekOfCode": "class MipsFuloong2e(LinuxKernelTest):\n    timeout = 60\n    ASSET_KERNEL = Asset(\n        ('http://archive.debian.org/debian/pool/main/l/linux/'\n         'linux-image-3.16.0-6-loongson-2e_3.16.56-1+deb8u1_mipsel.deb'),\n        '2a70f15b397f4ced632b0c15cb22660394190644146d804d60a4796eefbe1f50')\n    def test_linux_kernel_3_16(self):\n        kernel_path = self.archive_extract(\n            self.ASSET_KERNEL,\n            member='boot/vmlinux-3.16.0-6-loongson-2e')",
        "detail": "qemu.tests.functional.test_mips64el_fuloong2e",
        "documentation": {}
    },
    {
        "label": "MipsLoongson3v",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64el_loongson3v",
        "description": "qemu.tests.functional.test_mips64el_loongson3v",
        "peekOfCode": "class MipsLoongson3v(QemuSystemTest):\n    timeout = 60\n    ASSET_PMON = Asset(\n        ('https://github.com/loongson-community/pmon/'\n         'releases/download/20210112/pmon-3avirt.bin'),\n        'fcdf6bb2cb7885a4a62f31fcb0d5e368bac7b6cea28f40c6dfa678af22fea20a')\n    @skipUntrustedTest()\n    def test_pmon_serial_console(self):\n        self.set_machine('loongson3-virt')\n        pmon_path = self.ASSET_PMON.fetch()",
        "detail": "qemu.tests.functional.test_mips64el_loongson3v",
        "documentation": {}
    },
    {
        "label": "MaltaMachineConsole",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64el_malta",
        "description": "qemu.tests.functional.test_mips64el_malta",
        "peekOfCode": "class MaltaMachineConsole(LinuxKernelTest):\n    ASSET_KERNEL_2_63_2 = Asset(\n        ('http://snapshot.debian.org/archive/debian/'\n         '20130217T032700Z/pool/main/l/linux-2.6/'\n         'linux-image-2.6.32-5-5kc-malta_2.6.32-48_mipsel.deb'),\n        '35eb476f03be589824b0310358f1c447d85e645b88cbcd2ac02b97ef560f9f8d')\n    def test_mips64el_malta(self):\n        \"\"\"\n        This test requires the ar tool to extract \"data.tar.gz\" from\n        the Debian package.",
        "detail": "qemu.tests.functional.test_mips64el_malta",
        "documentation": {}
    },
    {
        "label": "MaltaMachineFramebuffer",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64el_malta",
        "description": "qemu.tests.functional.test_mips64el_malta",
        "peekOfCode": "class MaltaMachineFramebuffer(LinuxKernelTest):\n    timeout = 30\n    ASSET_KERNEL_4_7_0 = Asset(\n        ('https://github.com/philmd/qemu-testing-blob/raw/a5966ca4b5/'\n         'mips/malta/mips64el/vmlinux-4.7.0-rc1.I6400.gz'),\n        '1f64efc59968a3c328672e6b10213fe574bb2308d9d2ed44e75e40be59e9fbc2')\n    ASSET_TUXLOGO = Asset(\n        ('https://github.com/torvalds/linux/raw/v2.6.12/'\n         'drivers/video/logo/logo_linux_vga16.ppm'),\n        'b762f0d91ec018887ad1b334543c2fdf9be9fdfc87672b409211efaa3ea0ef79')",
        "detail": "qemu.tests.functional.test_mips64el_malta",
        "documentation": {}
    },
    {
        "label": "Mips64elReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64el_replay",
        "description": "qemu.tests.functional.test_mips64el_replay",
        "peekOfCode": "class Mips64elReplay(ReplayKernelBase):\n    ASSET_KERNEL_2_63_2 = Asset(\n        ('http://snapshot.debian.org/archive/debian/'\n         '20130217T032700Z/pool/main/l/linux-2.6/'\n         'linux-image-2.6.32-5-5kc-malta_2.6.32-48_mipsel.deb'),\n        '35eb476f03be589824b0310358f1c447d85e645b88cbcd2ac02b97ef560f9f8d')\n    def test_replay_mips64el_malta(self):\n        self.set_machine('malta')\n        kernel_path = self.archive_extract(self.ASSET_KERNEL_2_63_2,\n                                    member='boot/vmlinux-2.6.32-5-5kc-malta')",
        "detail": "qemu.tests.functional.test_mips64el_replay",
        "documentation": {}
    },
    {
        "label": "TuxRunMips64ELTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips64el_tuxrun",
        "description": "qemu.tests.functional.test_mips64el_tuxrun",
        "peekOfCode": "class TuxRunMips64ELTest(TuxRunBaselineTest):\n    ASSET_MIPS64EL_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips64el/vmlinux',\n        '0d2829a96f005229839c4cd586d4d8a136ea4b488d29821611c8e97f2266bfa9')\n    ASSET_MIPS64EL_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips64el/rootfs.ext4.zst',\n        '69c8b69a4f1582ce4c6f01a994968f5d73bffb2fc99cbeeeb26c8b5a28eaeb84')\n    def test_mips64el(self):\n        self.set_machine('malta')\n        self.root=\"sda\"",
        "detail": "qemu.tests.functional.test_mips64el_tuxrun",
        "documentation": {}
    },
    {
        "label": "MaltaMachineConsole",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips_malta",
        "description": "qemu.tests.functional.test_mips_malta",
        "peekOfCode": "class MaltaMachineConsole(LinuxKernelTest):\n    ASSET_KERNEL_2_63_2 = Asset(\n        ('http://snapshot.debian.org/archive/debian/'\n         '20130217T032700Z/pool/main/l/linux-2.6/'\n         'linux-image-2.6.32-5-4kc-malta_2.6.32-48_mips.deb'),\n        '16ca524148afb0626f483163e5edf352bc1ab0e4fc7b9f9d473252762f2c7a43')\n    def test_mips_malta(self):\n        kernel_path = self.archive_extract(\n            self.ASSET_KERNEL_2_63_2,\n            member='boot/vmlinux-2.6.32-5-4kc-malta')",
        "detail": "qemu.tests.functional.test_mips_malta",
        "documentation": {}
    },
    {
        "label": "mips_run_common_commands",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_mips_malta",
        "description": "qemu.tests.functional.test_mips_malta",
        "peekOfCode": "def mips_run_common_commands(test, prompt='#'):\n    exec_command_and_wait_for_pattern(test,\n        'uname -m',\n        'mips')\n    exec_command_and_wait_for_pattern(test,\n        'grep XT-PIC /proc/interrupts',\n        'timer')\n    wait_for_console_pattern(test, prompt)\n    exec_command_and_wait_for_pattern(test,\n        'grep XT-PIC /proc/interrupts',",
        "detail": "qemu.tests.functional.test_mips_malta",
        "documentation": {}
    },
    {
        "label": "mips_check_wheezy",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_mips_malta",
        "description": "qemu.tests.functional.test_mips_malta",
        "peekOfCode": "def mips_check_wheezy(test, kernel_path, image_path, kernel_command_line,\n                      dl_file, hsum, nic='pcnet', cpuinfo='MIPS 24Kc'):\n    test.require_netdev('user')\n    test.require_device(nic)\n    test.set_machine('malta')\n    port=8080\n    test.vm.add_args('-kernel', kernel_path,\n                     '-append', kernel_command_line,\n                     '-drive', 'file=%s,snapshot=on' % image_path,\n                     '-netdev', 'user,id=n1' +",
        "detail": "qemu.tests.functional.test_mips_malta",
        "documentation": {}
    },
    {
        "label": "MipsReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips_replay",
        "description": "qemu.tests.functional.test_mips_replay",
        "peekOfCode": "class MipsReplay(ReplayKernelBase):\n    ASSET_KERNEL_2_63_2 = Asset(\n        ('http://snapshot.debian.org/archive/debian/'\n         '20130217T032700Z/pool/main/l/linux-2.6/'\n         'linux-image-2.6.32-5-4kc-malta_2.6.32-48_mips.deb'),\n        '16ca524148afb0626f483163e5edf352bc1ab0e4fc7b9f9d473252762f2c7a43')\n    def test_replay_mips_malta(self):\n        self.set_machine('malta')\n        kernel_path = self.archive_extract(self.ASSET_KERNEL_2_63_2,\n                                     member='boot/vmlinux-2.6.32-5-4kc-malta')",
        "detail": "qemu.tests.functional.test_mips_replay",
        "documentation": {}
    },
    {
        "label": "TuxRunMipsTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mips_tuxrun",
        "description": "qemu.tests.functional.test_mips_tuxrun",
        "peekOfCode": "class TuxRunMipsTest(TuxRunBaselineTest):\n    ASSET_MIPS_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips32/vmlinux',\n        'b6f97fc698ae8c96456ad8c996c7454228074df0d7520dedd0a15e2913700a19')\n    ASSET_MIPS_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips32/rootfs.ext4.zst',\n        '87055cf3cbde3fd134e5039e7b87feb03231d8c4b21ee712b8ba3308dfa72f50')\n    def test_mips32(self):\n        self.set_machine('malta')\n        self.cpu=\"mips32r6-generic\"",
        "detail": "qemu.tests.functional.test_mips_tuxrun",
        "documentation": {}
    },
    {
        "label": "MaltaMachineConsole",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mipsel_malta",
        "description": "qemu.tests.functional.test_mipsel_malta",
        "peekOfCode": "class MaltaMachineConsole(LinuxKernelTest):\n    ASSET_KERNEL_4K = Asset(\n        ('http://mipsdistros.mips.com/LinuxDistro/nanomips/'\n         'kernels/v4.15.18-432-gb2eb9a8b07a1-20180627102142/'\n         'generic_nano32r6el_page4k.xz'),\n        '019e034094ac6cf3aa77df5e130fb023ce4dbc804b04bfcc560c6403e1ae6bdb')\n    ASSET_KERNEL_16K = Asset(\n        ('http://mipsdistros.mips.com/LinuxDistro/nanomips/'\n         'kernels/v4.15.18-432-gb2eb9a8b07a1-20180627102142/'\n         'generic_nano32r6el_page16k_up.xz'),",
        "detail": "qemu.tests.functional.test_mipsel_malta",
        "documentation": {}
    },
    {
        "label": "MaltaMachineYAMON",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mipsel_malta",
        "description": "qemu.tests.functional.test_mipsel_malta",
        "peekOfCode": "class MaltaMachineYAMON(QemuSystemTest):\n    ASSET_YAMON_ROM = Asset(\n        ('https://s3-eu-west-1.amazonaws.com/downloads-mips/mips-downloads/'\n         'YAMON/yamon-bin-02.22.zip'),\n        'eef86f0eed0ef554f041dcd47b87eebea0e6f9f1184ed31f7e9e8b4a803860ab')\n    def test_mipsel_malta_yamon(self):\n        yamon_bin = 'yamon-02.22.bin'\n        self.archive_extract(self.ASSET_YAMON_ROM)\n        yamon_path = self.scratch_file(yamon_bin)\n        self.set_machine('malta')",
        "detail": "qemu.tests.functional.test_mipsel_malta",
        "documentation": {}
    },
    {
        "label": "MipselReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mipsel_replay",
        "description": "qemu.tests.functional.test_mipsel_replay",
        "peekOfCode": "class MipselReplay(ReplayKernelBase):\n    ASSET_KERNEL_4K = Asset(\n        ('http://mipsdistros.mips.com/LinuxDistro/nanomips/'\n         'kernels/v4.15.18-432-gb2eb9a8b07a1-20180627102142/'\n         'generic_nano32r6el_page4k.xz'),\n        '019e034094ac6cf3aa77df5e130fb023ce4dbc804b04bfcc560c6403e1ae6bdb')\n    ASSET_KERNEL_16K = Asset(\n        ('http://mipsdistros.mips.com/LinuxDistro/nanomips/'\n         'kernels/v4.15.18-432-gb2eb9a8b07a1-20180627102142/'\n         'generic_nano32r6el_page16k_up.xz'),",
        "detail": "qemu.tests.functional.test_mipsel_replay",
        "documentation": {}
    },
    {
        "label": "TuxRunMipsELTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_mipsel_tuxrun",
        "description": "qemu.tests.functional.test_mipsel_tuxrun",
        "peekOfCode": "class TuxRunMipsELTest(TuxRunBaselineTest):\n    ASSET_MIPSEL_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips32el/vmlinux',\n        '660dd8c7a6ca7a32d37b4e6348865532ab0edb66802e8cc07869338444cf4929')\n    ASSET_MIPSEL_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/mips32el/rootfs.ext4.zst',\n        'c5d69542bcaed54a4f34671671eb4be5c608ee02671d4d0436544367816a73b1')\n    def test_mips32el(self):\n        self.set_machine('malta')\n        self.cpu=\"mips32r6-generic\"",
        "detail": "qemu.tests.functional.test_mipsel_tuxrun",
        "documentation": {}
    },
    {
        "label": "Multiprocess",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_multiprocess",
        "description": "qemu.tests.functional.test_multiprocess",
        "peekOfCode": "class Multiprocess(QemuSystemTest):\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    ASSET_KERNEL_X86 = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux'\n         '/releases/31/Everything/x86_64/os/images/pxeboot/vmlinuz'),\n        'd4738d03dbbe083ca610d0821d0a8f1488bebbdccef54ce33e3adb35fda00129')\n    ASSET_INITRD_X86 = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux'\n         '/releases/31/Everything/x86_64/os/images/pxeboot/initrd.img'),\n        '3b6cb5c91a14c42e2f61520f1689264d865e772a1f0069e660a800d31dd61fb9')",
        "detail": "qemu.tests.functional.test_multiprocess",
        "documentation": {}
    },
    {
        "label": "NetDevEthtool",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_netdev_ethtool",
        "description": "qemu.tests.functional.test_netdev_ethtool",
        "peekOfCode": "class NetDevEthtool(QemuSystemTest):\n    # Runs in about 17s under KVM, 19s under TCG, 25s under GCOV\n    timeout = 45\n    # Fetch assets from the netdev-ethtool subdir of my shared test\n    # images directory on fileserver.linaro.org.\n    ASSET_BASEURL = ('https://fileserver.linaro.org/s/kE4nCFLdQcoBF9t/'\n                     'download?path=%2Fnetdev-ethtool&files=')\n    ASSET_BZIMAGE = Asset(\n        ASSET_BASEURL + \"bzImage\",\n        \"ed62ee06ea620b1035747f3f66a5e9fc5d3096b29f75562ada888b04cd1c4baf\")",
        "detail": "qemu.tests.functional.test_netdev_ethtool",
        "documentation": {}
    },
    {
        "label": "Or1kReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_or1k_replay",
        "description": "qemu.tests.functional.test_or1k_replay",
        "peekOfCode": "class Or1kReplay(ReplayKernelBase):\n    ASSET_DAY20 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day20.tar.xz',\n        'ff9d7dd7c6bdba325bd85ee85c02db61ff653e129558aeffe6aff55bffb6763a')\n    def test_sim(self):\n        self.set_machine('or1k-sim')\n        kernel_path = self.archive_extract(self.ASSET_DAY20,\n                                           member='day20/vmlinux')\n        self.run_rr(kernel_path, self.REPLAY_KERNEL_COMMAND_LINE,\n                    'QEMU advent calendar')",
        "detail": "qemu.tests.functional.test_or1k_replay",
        "documentation": {}
    },
    {
        "label": "OpenRISC1kSimTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_or1k_sim",
        "description": "qemu.tests.functional.test_or1k_sim",
        "peekOfCode": "class OpenRISC1kSimTest(LinuxKernelTest):\n    ASSET_DAY20 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day20.tar.xz',\n        'ff9d7dd7c6bdba325bd85ee85c02db61ff653e129558aeffe6aff55bffb6763a')\n    def test_or1k_sim(self):\n        self.set_machine('or1k-sim')\n        self.archive_extract(self.ASSET_DAY20)\n        self.vm.set_console()\n        self.vm.add_args('-kernel', self.scratch_file('day20', 'vmlinux'))\n        self.vm.launch()",
        "detail": "qemu.tests.functional.test_or1k_sim",
        "documentation": {}
    },
    {
        "label": "OmittedCPUProps",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_pc_cpu_hotplug_props",
        "description": "qemu.tests.functional.test_pc_cpu_hotplug_props",
        "peekOfCode": "class OmittedCPUProps(QemuSystemTest):\n    def test_no_die_id(self):\n        self.vm.add_args('-nodefaults', '-S')\n        self.vm.add_args('-smp', '1,sockets=2,cores=2,threads=2,maxcpus=8')\n        self.vm.add_args('-device', 'qemu64-x86_64-cpu,socket-id=1,core-id=0,thread-id=0')\n        self.vm.launch()\n        self.assertEqual(len(self.vm.cmd('query-cpus-fast')), 2)\nif __name__ == '__main__':\n    QemuSystemTest.main()",
        "detail": "qemu.tests.functional.test_pc_cpu_hotplug_props",
        "documentation": {}
    },
    {
        "label": "E500Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_e500",
        "description": "qemu.tests.functional.test_ppc64_e500",
        "peekOfCode": "class E500Test(LinuxKernelTest):\n    ASSET_BR2_E5500_UIMAGE = Asset(\n        'https://github.com/legoater/qemu-ppc-boot/raw/refs/heads/main/buildroot/qemu_ppc64_e5500-2023.11-8-gdcd9f0f6eb-20240104/uImage',\n        '2478187c455d6cca3984e9dfde9c635d824ea16236b85fd6b4809f744706deda')\n    ASSET_BR2_E5500_ROOTFS = Asset(\n        'https://github.com/legoater/qemu-ppc-boot/raw/refs/heads/main//buildroot/qemu_ppc64_e5500-2023.11-8-gdcd9f0f6eb-20240104/rootfs.ext2',\n        '9035ef97237c84c7522baaff17d25cdfca4bb7a053d5e296e902919473423d76')\n    def test_ppc64_e500_buildroot(self):\n        self.set_machine('ppce500')\n        self.require_netdev('user')",
        "detail": "qemu.tests.functional.test_ppc64_e500",
        "documentation": {}
    },
    {
        "label": "HypervisorTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_hv",
        "description": "qemu.tests.functional.test_ppc64_hv",
        "peekOfCode": "class HypervisorTest(QemuSystemTest):\n    timeout = 1000\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 console=hvc0 '\n    panic_message = 'Kernel panic - not syncing'\n    good_message = 'VFS: Cannot open root device'\n    ASSET_ISO = Asset(\n        ('https://dl-cdn.alpinelinux.org/alpine/v3.21/'\n         'releases/ppc64le/alpine-standard-3.21.0-ppc64le.iso'),\n        '7651ab4e3027604535c0b36e86c901b4695bf8fe97b908f5b48590f6baae8f30')\n    def extract_from_iso(self, iso, path):",
        "detail": "qemu.tests.functional.test_ppc64_hv",
        "documentation": {}
    },
    {
        "label": "mac99Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_mac99",
        "description": "qemu.tests.functional.test_ppc64_mac99",
        "peekOfCode": "class mac99Test(LinuxKernelTest):\n    ASSET_BR2_MAC99_LINUX = Asset(\n        'https://github.com/legoater/qemu-ppc-boot/raw/refs/heads/main/buildroot/qemu_ppc64_mac99-2023.11-8-gdcd9f0f6eb-20240105/vmlinux',\n        'd59307437e4365f2cced0bbd1b04949f7397b282ef349b7cafd894d74aadfbff')\n    ASSET_BR2_MAC99_ROOTFS = Asset(\n        'https://github.com/legoater/qemu-ppc-boot/raw/refs/heads/main//buildroot/qemu_ppc64_mac99-2023.11-8-gdcd9f0f6eb-20240105/rootfs.ext2',\n        'bbd5fd8af62f580bc4e585f326fe584e22856572633a8333178ea6d4ed4955a4')\n    def test_ppc64_mac99_buildroot(self):\n        self.set_machine('mac99')\n        linux_path = self.ASSET_BR2_MAC99_LINUX.fetch()",
        "detail": "qemu.tests.functional.test_ppc64_mac99",
        "documentation": {}
    },
    {
        "label": "powernvMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_powernv",
        "description": "qemu.tests.functional.test_ppc64_powernv",
        "peekOfCode": "class powernvMachine(LinuxKernelTest):\n    timeout = 90\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 console=hvc0 '\n    panic_message = 'Kernel panic - not syncing'\n    good_message = 'VFS: Cannot open root device'\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora-secondary/'\n         'releases/29/Everything/ppc64le/os/ppc/ppc64/vmlinuz'),\n        '383c2f5c23bc0d9d32680c3924d3fd7ee25cc5ef97091ac1aa5e1d853422fc5f')\n    def do_test_linux_boot(self, command_line = KERNEL_COMMON_COMMAND_LINE):",
        "detail": "qemu.tests.functional.test_ppc64_powernv",
        "documentation": {}
    },
    {
        "label": "pseriesMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_pseries",
        "description": "qemu.tests.functional.test_ppc64_pseries",
        "peekOfCode": "class pseriesMachine(QemuSystemTest):\n    timeout = 90\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 console=hvc0 '\n    panic_message = 'Kernel panic - not syncing'\n    good_message = 'VFS: Cannot open root device'\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora-secondary/'\n         'releases/29/Everything/ppc64le/os/ppc/ppc64/vmlinuz'),\n        '383c2f5c23bc0d9d32680c3924d3fd7ee25cc5ef97091ac1aa5e1d853422fc5f')\n    def do_test_ppc64_linux_boot(self, kernel_command_line = KERNEL_COMMON_COMMAND_LINE):",
        "detail": "qemu.tests.functional.test_ppc64_pseries",
        "documentation": {}
    },
    {
        "label": "Ppc64Replay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_replay",
        "description": "qemu.tests.functional.test_ppc64_replay",
        "peekOfCode": "class Ppc64Replay(ReplayKernelBase):\n    ASSET_DAY19 = Asset(\n        ('https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/'\n         'day19.tar.xz'),\n        '20b1bb5a8488c664defbb5d283addc91a05335a936c63b3f5ff7eee74b725755')\n    @skipFlakyTest('https://gitlab.com/qemu-project/qemu/-/issues/2523')\n    def test_ppc64_e500(self):\n        self.set_machine('ppce500')\n        self.cpu = 'e5500'\n        kernel_path = self.archive_extract(self.ASSET_DAY19,",
        "detail": "qemu.tests.functional.test_ppc64_replay",
        "documentation": {}
    },
    {
        "label": "ReverseDebugging_ppc64",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_reverse_debug",
        "description": "qemu.tests.functional.test_ppc64_reverse_debug",
        "peekOfCode": "class ReverseDebugging_ppc64(ReverseDebugging):\n    REG_PC = 0x40\n    @skipFlakyTest(\"https://gitlab.com/qemu-project/qemu/-/issues/1992\")\n    def test_ppc64_pseries(self):\n        self.set_machine('pseries')\n        # SLOF branches back to its entry point, which causes this test\n        # to take the 'hit a breakpoint again' path. That's not a problem,\n        # just slightly different than the other machines.\n        self.endian_is_le = False\n        self.reverse_debugging()",
        "detail": "qemu.tests.functional.test_ppc64_reverse_debug",
        "documentation": {}
    },
    {
        "label": "TuxRunPPC64Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc64_tuxrun",
        "description": "qemu.tests.functional.test_ppc64_tuxrun",
        "peekOfCode": "class TuxRunPPC64Test(TuxRunBaselineTest):\n    def ppc64_common_tuxrun(self, kernel_asset, rootfs_asset, prefix):\n        self.set_machine('pseries')\n        self.cpu='POWER10'\n        self.console='hvc0'\n        self.root='sda'\n        self.extradev='spapr-vscsi'\n        # add device args to command line.\n        self.require_netdev('user')\n        self.vm.add_args('-netdev', 'user,id=vnet,hostfwd=:127.0.0.1:0-:22',",
        "detail": "qemu.tests.functional.test_ppc64_tuxrun",
        "documentation": {}
    },
    {
        "label": "IbmPrep40pMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_40p",
        "description": "qemu.tests.functional.test_ppc_40p",
        "peekOfCode": "class IbmPrep40pMachine(QemuSystemTest):\n    timeout = 60\n    ASSET_BIOS = Asset(\n        ('http://ftpmirror.your.org/pub/misc/'\n         'ftp.software.ibm.com/rs6000/firmware/'\n         '7020-40p/P12H0456.IMG'),\n        'd957f79c73f760d1455d2286fcd901ed6d06167320eb73511b478a939be25b3f')\n    ASSET_NETBSD40 = Asset(\n        ('https://archive.netbsd.org/pub/NetBSD-archive/'\n         'NetBSD-4.0/prep/installation/floppy/generic_com0.fs'),",
        "detail": "qemu.tests.functional.test_ppc_40p",
        "documentation": {}
    },
    {
        "label": "ppc74xxCpu",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_74xx",
        "description": "qemu.tests.functional.test_ppc_74xx",
        "peekOfCode": "class ppc74xxCpu(QemuSystemTest):\n    timeout = 5\n    def test_ppc_7400(self):\n        self.require_accelerator(\"tcg\")\n        self.set_machine('g3beige')\n        self.vm.set_console()\n        self.vm.add_args('-cpu', '7400')\n        self.vm.launch()\n        wait_for_console_pattern(self, '>> OpenBIOS')\n        wait_for_console_pattern(self, '>> CPU type PowerPC,G4')",
        "detail": "qemu.tests.functional.test_ppc_74xx",
        "documentation": {}
    },
    {
        "label": "AmigaOneMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_amiga",
        "description": "qemu.tests.functional.test_ppc_amiga",
        "peekOfCode": "class AmigaOneMachine(QemuSystemTest):\n    timeout = 90\n    ASSET_IMAGE = Asset(\n        ('https://www.hyperion-entertainment.com/index.php/'\n         'downloads?view=download&format=raw&file=25'),\n        '8ff39330ba47d4f64de4ee8fd6809e9c010a9ef17fe51e95c3c1d53437cb481f')\n    def test_ppc_amigaone(self):\n        self.require_accelerator(\"tcg\")\n        self.set_machine('amigaone')\n        tar_name = 'A1Firmware_Floppy_05-Mar-2005.zip'",
        "detail": "qemu.tests.functional.test_ppc_amiga",
        "documentation": {}
    },
    {
        "label": "BambooMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_bamboo",
        "description": "qemu.tests.functional.test_ppc_bamboo",
        "peekOfCode": "class BambooMachine(QemuSystemTest):\n    timeout = 90\n    ASSET_IMAGE = Asset(\n        ('http://landley.net/aboriginal/downloads/binaries/'\n         'system-image-powerpc-440fp.tar.gz'),\n        'c12b58f841c775a0e6df4832a55afe6b74814d1565d08ddeafc1fb949a075c5e')\n    def test_ppc_bamboo(self):\n        self.set_machine('bamboo')\n        self.require_accelerator(\"tcg\")\n        self.require_netdev('user')",
        "detail": "qemu.tests.functional.test_ppc_bamboo",
        "documentation": {}
    },
    {
        "label": "MacTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_mac",
        "description": "qemu.tests.functional.test_ppc_mac",
        "peekOfCode": "class MacTest(LinuxKernelTest):\n    ASSET_DAY15 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day15.tar.xz',\n        '03e0757c131d2959decf293a3572d3b96c5a53587165bf05ce41b2818a2bccd5')\n    def do_day15_test(self):\n        # mac99 also works with kvm_pr but we don't have a reliable way at\n        # the moment (e.g. by looking at /proc/modules) to detect whether\n        # we're running kvm_hv or kvm_pr. For now let's disable this test\n        # if we don't have TCG support.\n        self.require_accelerator(\"tcg\")",
        "detail": "qemu.tests.functional.test_ppc_mac",
        "documentation": {}
    },
    {
        "label": "Mpc8544dsMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_mpc8544ds",
        "description": "qemu.tests.functional.test_ppc_mpc8544ds",
        "peekOfCode": "class Mpc8544dsMachine(QemuSystemTest):\n    timeout = 90\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    panic_message = 'Kernel panic - not syncing'\n    ASSET_IMAGE = Asset(\n        ('https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/'\n         'day04.tar.xz'),\n        '88bc83f3c9f3d633bcfc108a6342d677abca247066a2fb8d4636744a0d319f94')\n    def test_ppc_mpc8544ds(self):\n        self.require_accelerator(\"tcg\")",
        "detail": "qemu.tests.functional.test_ppc_mpc8544ds",
        "documentation": {}
    },
    {
        "label": "PpcReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_replay",
        "description": "qemu.tests.functional.test_ppc_replay",
        "peekOfCode": "class PpcReplay(ReplayKernelBase):\n    ASSET_DAY15 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day15.tar.xz',\n        '03e0757c131d2959decf293a3572d3b96c5a53587165bf05ce41b2818a2bccd5')\n    def do_day15_test(self):\n        self.require_accelerator(\"tcg\")\n        kernel_path = self.archive_extract(self.ASSET_DAY15,\n                                           member='day15/invaders.elf')\n        self.run_rr(kernel_path, self.REPLAY_KERNEL_COMMAND_LINE,\n                    'QEMU advent calendar', args=('-M', 'graphics=off'))",
        "detail": "qemu.tests.functional.test_ppc_replay",
        "documentation": {}
    },
    {
        "label": "sam460exTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_sam460ex",
        "description": "qemu.tests.functional.test_ppc_sam460ex",
        "peekOfCode": "class sam460exTest(LinuxKernelTest):\n    ASSET_BR2_SAM460EX_LINUX = Asset(\n        'https://github.com/legoater/qemu-ppc-boot/raw/refs/heads/main/buildroot/qemu_ppc_sam460ex-2023.11-8-gdcd9f0f6eb-20240105/vmlinux',\n        '6f46346f3e20e8b5fc050ff363f350f8b9d76a051b9e0bd7ea470cc680c14df2')\n    def test_ppc_sam460ex_buildroot(self):\n        self.set_machine('sam460ex')\n        self.require_netdev('user')\n        linux_path = self.ASSET_BR2_SAM460EX_LINUX.fetch()\n        self.vm.set_console()\n        self.vm.add_args('-kernel', linux_path,",
        "detail": "qemu.tests.functional.test_ppc_sam460ex",
        "documentation": {}
    },
    {
        "label": "TuxRunPPC32Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_tuxrun",
        "description": "qemu.tests.functional.test_ppc_tuxrun",
        "peekOfCode": "class TuxRunPPC32Test(TuxRunBaselineTest):\n    ASSET_PPC32_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/ppc32/uImage',\n        'aa5d81deabdb255a318c4bc5ffd6fdd2b5da1ef39f1955dcc35b671d258b68e9')\n    ASSET_PPC32_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/ppc32/rootfs.ext4.zst',\n        '67554f830269d6bf53b67c7dd206bcc821e463993d526b1644066fea8117019b')\n    def test_ppc32(self):\n        self.set_machine('ppce500')\n        self.cpu='e500mc'",
        "detail": "qemu.tests.functional.test_ppc_tuxrun",
        "documentation": {}
    },
    {
        "label": "VirtexMl507Machine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_ppc_virtex_ml507",
        "description": "qemu.tests.functional.test_ppc_virtex_ml507",
        "peekOfCode": "class VirtexMl507Machine(QemuSystemTest):\n    timeout = 90\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    panic_message = 'Kernel panic - not syncing'\n    ASSET_IMAGE = Asset(\n        ('https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/'\n         'day08.tar.xz'),\n        'cefe5b8aeb5e9d2d1d4fd22dcf48d917d68d5a765132bf2ddd6332dc393b824c')\n    def test_ppc_virtex_ml507(self):\n        self.require_accelerator(\"tcg\")",
        "detail": "qemu.tests.functional.test_ppc_virtex_ml507",
        "documentation": {}
    },
    {
        "label": "TuxRunRiscV32Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_riscv32_tuxrun",
        "description": "qemu.tests.functional.test_riscv32_tuxrun",
        "peekOfCode": "class TuxRunRiscV32Test(TuxRunBaselineTest):\n    ASSET_RISCV32_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/riscv32/Image',\n        '872bc8f8e0d4661825d5f47f7bec64988e9d0a8bd5db8917d57e16f66d83b329')\n    ASSET_RISCV32_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/riscv32/rootfs.ext4.zst',\n        '511ad34e63222db08d6c1da16fad224970de36517a784110956ba6a24a0ee5f6')\n    def test_riscv32(self):\n        self.set_machine('virt')\n        self.common_tuxrun(kernel_asset=self.ASSET_RISCV32_KERNEL,",
        "detail": "qemu.tests.functional.test_riscv32_tuxrun",
        "documentation": {}
    },
    {
        "label": "TuxRunRiscV64Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_riscv64_tuxrun",
        "description": "qemu.tests.functional.test_riscv64_tuxrun",
        "peekOfCode": "class TuxRunRiscV64Test(TuxRunBaselineTest):\n    ASSET_RISCV64_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/riscv64/Image',\n        '2bd8132a3bf21570290042324fff48c987f42f2a00c08de979f43f0662ebadba')\n    ASSET_RISCV64_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/riscv64/rootfs.ext4.zst',\n        'aa4736a9872651dfc0d95e709465eedf1134fd19d42b8cb305bfd776f9801004')\n    ASSET_RISCV32_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/riscv32/Image',\n        '872bc8f8e0d4661825d5f47f7bec64988e9d0a8bd5db8917d57e16f66d83b329')",
        "detail": "qemu.tests.functional.test_riscv64_tuxrun",
        "documentation": {}
    },
    {
        "label": "RiscvOpenSBI",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_riscv_opensbi",
        "description": "qemu.tests.functional.test_riscv_opensbi",
        "peekOfCode": "class RiscvOpenSBI(QemuSystemTest):\n    timeout = 5\n    def boot_opensbi(self):\n        self.vm.set_console()\n        self.vm.launch()\n        wait_for_console_pattern(self, 'Platform Name')\n        wait_for_console_pattern(self, 'Boot HART MEDELEG')\n    def test_riscv_spike(self):\n        self.set_machine('spike')\n        self.boot_opensbi()",
        "detail": "qemu.tests.functional.test_riscv_opensbi",
        "documentation": {}
    },
    {
        "label": "RxGdbSimMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_rx_gdbsim",
        "description": "qemu.tests.functional.test_rx_gdbsim",
        "peekOfCode": "class RxGdbSimMachine(QemuSystemTest):\n    timeout = 30\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    ASSET_UBOOT = Asset(\n        ('https://github.com/philmd/qemu-testing-blob/raw/rx-gdbsim/rx/gdbsim/'\n         'u-boot.bin'),\n        'dd7dd4220cccf7aeb32227b26233bf39600db05c3f8e26005bcc2bf6c927207d')\n    ASSET_DTB = Asset(\n        ('https://github.com/philmd/qemu-testing-blob/raw/rx-gdbsim/rx/gdbsim/'\n         'rx-gdbsim.dtb'),",
        "detail": "qemu.tests.functional.test_rx_gdbsim",
        "documentation": {}
    },
    {
        "label": "S390CCWVirtioMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_s390x_ccw_virtio",
        "description": "qemu.tests.functional.test_s390x_ccw_virtio",
        "peekOfCode": "class S390CCWVirtioMachine(QemuSystemTest):\n    KERNEL_COMMON_COMMAND_LINE = 'printk.time=0 '\n    timeout = 120\n    ASSET_BUSTER_KERNEL = Asset(\n        ('https://snapshot.debian.org/archive/debian/'\n         '20201126T092837Z/dists/buster/main/installer-s390x/'\n         '20190702+deb10u6/images/generic/kernel.debian'),\n        'd411d17c39ae7ad38d27534376cbe88b68b403c325739364122c2e6f1537e818')\n    ASSET_BUSTER_INITRD = Asset(\n        ('https://snapshot.debian.org/archive/debian/'",
        "detail": "qemu.tests.functional.test_s390x_ccw_virtio",
        "documentation": {}
    },
    {
        "label": "S390xReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_s390x_replay",
        "description": "qemu.tests.functional.test_s390x_replay",
        "peekOfCode": "class S390xReplay(ReplayKernelBase):\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora-secondary/'\n         'releases/29/Everything/s390x/os/images/kernel.img'),\n        'dace03b8ae0c9f670ebb9b8d6ce5eb24b62987f346de8f1300a439bb00bb99e7')\n    def test_s390_ccw_virtio(self):\n        self.set_machine('s390-ccw-virtio')\n        kernel_path = self.ASSET_KERNEL.fetch()\n        kernel_command_line = self.KERNEL_COMMON_COMMAND_LINE + 'console=sclp0'\n        console_pattern = 'Kernel command line: %s' % kernel_command_line",
        "detail": "qemu.tests.functional.test_s390x_replay",
        "documentation": {}
    },
    {
        "label": "S390CPUTopology",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_s390x_topology",
        "description": "qemu.tests.functional.test_s390x_topology",
        "peekOfCode": "class S390CPUTopology(QemuSystemTest):\n    \"\"\"\n    S390x CPU topology consists of 4 topology layers, from bottom to top,\n    the cores, sockets, books and drawers and 2 modifiers attributes,\n    the entitlement and the dedication.\n    See: docs/system/s390x/cpu-topology.rst.\n    S390x CPU topology is setup in different ways:\n    - implicitly from the '-smp' argument by completing each topology\n      level one after the other beginning with drawer 0, book 0 and\n      socket 0.",
        "detail": "qemu.tests.functional.test_s390x_topology",
        "documentation": {}
    },
    {
        "label": "TuxRunS390xTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_s390x_tuxrun",
        "description": "qemu.tests.functional.test_s390x_tuxrun",
        "peekOfCode": "class TuxRunS390xTest(TuxRunBaselineTest):\n    ASSET_S390X_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/s390/bzImage',\n        'ee67e91db52a2aed104a7c72b2a08987c678f8179c029626789c35d6dd0fedf1')\n    ASSET_S390X_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/s390/rootfs.ext4.zst',\n        'bff7971fc2fef56372d98afe4557b82fd0a785a241e44c29b058e577ad1bbb44')\n    def test_s390(self):\n        self.wait_for_shutdown=False\n        self.common_tuxrun(kernel_asset=self.ASSET_S390X_KERNEL,",
        "detail": "qemu.tests.functional.test_s390x_tuxrun",
        "documentation": {}
    },
    {
        "label": "R2dTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_sh4_r2d",
        "description": "qemu.tests.functional.test_sh4_r2d",
        "peekOfCode": "class R2dTest(LinuxKernelTest):\n    ASSET_DAY09 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day09.tar.xz',\n        'a61b44d2630a739d1380cc4ff4b80981d47ccfd5992f1484ccf48322c35f09ac')\n    # This test has a 6-10% failure rate on various hosts that look\n    # like issues with a buggy kernel.\n    # XXX file tracking bug\n    @skipFlakyTest(bug_url=None)\n    def test_r2d(self):\n        self.set_machine('r2d')",
        "detail": "qemu.tests.functional.test_sh4_r2d",
        "documentation": {}
    },
    {
        "label": "TuxRunSh4Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_sh4_tuxrun",
        "description": "qemu.tests.functional.test_sh4_tuxrun",
        "peekOfCode": "class TuxRunSh4Test(TuxRunBaselineTest):\n    ASSET_SH4_KERNEL = Asset(\n        'https://storage.tuxboot.com/20230331/sh4/zImage',\n        '29d9b2aba604a0f53a5dc3b5d0f2b8e35d497de1129f8ee5139eb6fdf0db692f')\n    ASSET_SH4_ROOTFS = Asset(\n        'https://storage.tuxboot.com/20230331/sh4/rootfs.ext4.zst',\n        '3592a7a3d5a641e8b9821449e77bc43c9904a56c30d45da0694349cfd86743fd')\n    def test_sh4(self):\n        self.set_machine('r2d')\n        self.cpu='sh7785'",
        "detail": "qemu.tests.functional.test_sh4_tuxrun",
        "documentation": {}
    },
    {
        "label": "R2dEBTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_sh4eb_r2d",
        "description": "qemu.tests.functional.test_sh4eb_r2d",
        "peekOfCode": "class R2dEBTest(LinuxKernelTest):\n    ASSET_TGZ = Asset(\n        'https://landley.net/bin/mkroot/0.8.11/sh4eb.tgz',\n        'be8c6cb5aef8406899dc5aa5e22b6aa45840eb886cdd3ced51555c10577ada2c')\n    def test_sh4eb_r2d(self):\n        self.set_machine('r2d')\n        self.archive_extract(self.ASSET_TGZ)\n        self.vm.add_args('-append', 'console=ttySC1 noiotrap')\n        self.launch_kernel(self.scratch_file('sh4eb', 'linux-kernel'),\n                           initrd=self.scratch_file('sh4eb',",
        "detail": "qemu.tests.functional.test_sh4eb_r2d",
        "documentation": {}
    },
    {
        "label": "Sun4uMachine",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_sparc64_sun4u",
        "description": "qemu.tests.functional.test_sparc64_sun4u",
        "peekOfCode": "class Sun4uMachine(QemuSystemTest):\n    \"\"\"Boots the Linux kernel and checks that the console is operational\"\"\"\n    timeout = 90\n    ASSET_IMAGE = Asset(\n        ('https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/'\n         'day23.tar.xz'),\n        'a3ed92450704af244178351afd0e769776e7decb298e95a63abfd9a6e3f6c854')\n    def test_sparc64_sun4u(self):\n        self.set_machine('sun4u')\n        kernel_file = self.archive_extract(self.ASSET_IMAGE,",
        "detail": "qemu.tests.functional.test_sparc64_sun4u",
        "documentation": {}
    },
    {
        "label": "TuxRunSparc64Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_sparc64_tuxrun",
        "description": "qemu.tests.functional.test_sparc64_tuxrun",
        "peekOfCode": "class TuxRunSparc64Test(TuxRunBaselineTest):\n    ASSET_SPARC64_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/sparc64/vmlinux',\n        'a04cfb2e70a264051d161fdd93aabf4b2a9472f2e435c14ed18c5848c5fed261')\n    ASSET_SPARC64_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/sparc64/rootfs.ext4.zst',\n        '479c3dc104c82b68be55e2c0c5c38cd473d0b37ad4badccde4775bb88ce34611')\n    def test_sparc64(self):\n        self.root='sda'\n        self.wait_for_shutdown=False",
        "detail": "qemu.tests.functional.test_sparc64_tuxrun",
        "documentation": {}
    },
    {
        "label": "SparcReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_sparc_replay",
        "description": "qemu.tests.functional.test_sparc_replay",
        "peekOfCode": "class SparcReplay(ReplayKernelBase):\n    ASSET_DAY11 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day11.tar.xz',\n        'c776533ba756bf4dd3f1fc4c024fb50ef0d853e05c5f5ddf0900a32d1eaa49e0')\n    def test_replay(self):\n        self.set_machine('SS-10')\n        kernel_path = self.archive_extract(self.ASSET_DAY11,\n                                           member=\"day11/zImage.elf\")\n        self.run_rr(kernel_path, self.REPLAY_KERNEL_COMMAND_LINE,\n                    'QEMU advent calendar')",
        "detail": "qemu.tests.functional.test_sparc_replay",
        "documentation": {}
    },
    {
        "label": "Sun4mTest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_sparc_sun4m",
        "description": "qemu.tests.functional.test_sparc_sun4m",
        "peekOfCode": "class Sun4mTest(LinuxKernelTest):\n    ASSET_DAY11 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day11.tar.xz',\n        'c776533ba756bf4dd3f1fc4c024fb50ef0d853e05c5f5ddf0900a32d1eaa49e0')\n    def test_sparc_ss20(self):\n        self.set_machine('SS-20')\n        self.archive_extract(self.ASSET_DAY11)\n        self.launch_kernel(self.scratch_file('day11', 'zImage.elf'),\n                           wait_for='QEMU advent calendar')\nif __name__ == '__main__':",
        "detail": "qemu.tests.functional.test_sparc_sun4m",
        "documentation": {}
    },
    {
        "label": "Version",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_version",
        "description": "qemu.tests.functional.test_version",
        "peekOfCode": "class Version(QemuSystemTest):\n    def test_qmp_human_info_version(self):\n        self.set_machine('none')\n        self.vm.add_args('-nodefaults')\n        self.vm.launch()\n        res = self.vm.cmd('human-monitor-command',\n                          command_line='info version')\n        self.assertRegex(res, r'^(\\d+\\.\\d+\\.\\d)')\nif __name__ == '__main__':\n    QemuSystemTest.main()",
        "detail": "qemu.tests.functional.test_version",
        "documentation": {}
    },
    {
        "label": "VirtioBalloonx86",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_virtio_balloon",
        "description": "qemu.tests.functional.test_virtio_balloon",
        "peekOfCode": "class VirtioBalloonx86(QemuSystemTest):\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/vmlinuz'),\n        'd4738d03dbbe083ca610d0821d0a8f1488bebbdccef54ce33e3adb35fda00129')\n    ASSET_INITRD = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/initrd.img'),\n        '277cd6c7adf77c7e63d73bbb2cded8ef9e2d3a2f100000e92ff1f8396513cd8b')\n    ASSET_DISKIMAGE = Asset(",
        "detail": "qemu.tests.functional.test_virtio_balloon",
        "documentation": {}
    },
    {
        "label": "UNSET_STATS_VALUE",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_balloon",
        "description": "qemu.tests.functional.test_virtio_balloon",
        "peekOfCode": "UNSET_STATS_VALUE = 18446744073709551615\nclass VirtioBalloonx86(QemuSystemTest):\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/vmlinuz'),\n        'd4738d03dbbe083ca610d0821d0a8f1488bebbdccef54ce33e3adb35fda00129')\n    ASSET_INITRD = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/initrd.img'),\n        '277cd6c7adf77c7e63d73bbb2cded8ef9e2d3a2f100000e92ff1f8396513cd8b')",
        "detail": "qemu.tests.functional.test_virtio_balloon",
        "documentation": {}
    },
    {
        "label": "VirtioGPUx86",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_virtio_gpu",
        "description": "qemu.tests.functional.test_virtio_gpu",
        "peekOfCode": "class VirtioGPUx86(QemuSystemTest):\n    KERNEL_COMMAND_LINE = \"printk.time=0 console=ttyS0 rdinit=/bin/bash\"\n    ASSET_KERNEL = Asset(\n        (\"https://archives.fedoraproject.org/pub/archive/fedora\"\n         \"/linux/releases/33/Everything/x86_64/os/images\"\n         \"/pxeboot/vmlinuz\"),\n        '2dc5fb5cfe9ac278fa45640f3602d9b7a08cc189ed63fd9b162b07073e4df397')\n    ASSET_INITRD = Asset(\n        (\"https://archives.fedoraproject.org/pub/archive/fedora\"\n         \"/linux/releases/33/Everything/x86_64/os/images\"",
        "detail": "qemu.tests.functional.test_virtio_gpu",
        "documentation": {}
    },
    {
        "label": "pick_default_vug_bin",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_virtio_gpu",
        "description": "qemu.tests.functional.test_virtio_gpu",
        "peekOfCode": "def pick_default_vug_bin(test):\n    bld_dir_path = test.build_file(\"contrib\", \"vhost-user-gpu\", \"vhost-user-gpu\")\n    if is_readable_executable_file(bld_dir_path):\n        return bld_dir_path\nclass VirtioGPUx86(QemuSystemTest):\n    KERNEL_COMMAND_LINE = \"printk.time=0 console=ttyS0 rdinit=/bin/bash\"\n    ASSET_KERNEL = Asset(\n        (\"https://archives.fedoraproject.org/pub/archive/fedora\"\n         \"/linux/releases/33/Everything/x86_64/os/images\"\n         \"/pxeboot/vmlinuz\"),",
        "detail": "qemu.tests.functional.test_virtio_gpu",
        "documentation": {}
    },
    {
        "label": "VirtioVersionCheck",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "class VirtioVersionCheck(QemuSystemTest):\n    \"\"\"\n    Check if virtio-version-specific device types result in the\n    same device tree created by `disable-modern` and\n    `disable-legacy`.\n    \"\"\"\n    # just in case there are failures, show larger diff:\n    maxDiff = 4096\n    def run_device(self, devtype, opts=None, machine='pc'):\n        \"\"\"",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "pci_modern_device_id",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "def pci_modern_device_id(virtio_devid):\n    return virtio_devid + 0x1040\ndef devtype_implements(vm, devtype, implements):\n    return devtype in [d['name'] for d in\n                       vm.cmd('qom-list-types', implements=implements)]\ndef get_pci_interfaces(vm, devtype):\n    interfaces = ('pci-express-device', 'conventional-pci-device')\n    return [i for i in interfaces if devtype_implements(vm, devtype, i)]\nclass VirtioVersionCheck(QemuSystemTest):\n    \"\"\"",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "devtype_implements",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "def devtype_implements(vm, devtype, implements):\n    return devtype in [d['name'] for d in\n                       vm.cmd('qom-list-types', implements=implements)]\ndef get_pci_interfaces(vm, devtype):\n    interfaces = ('pci-express-device', 'conventional-pci-device')\n    return [i for i in interfaces if devtype_implements(vm, devtype, i)]\nclass VirtioVersionCheck(QemuSystemTest):\n    \"\"\"\n    Check if virtio-version-specific device types result in the\n    same device tree created by `disable-modern` and",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "get_pci_interfaces",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "def get_pci_interfaces(vm, devtype):\n    interfaces = ('pci-express-device', 'conventional-pci-device')\n    return [i for i in interfaces if devtype_implements(vm, devtype, i)]\nclass VirtioVersionCheck(QemuSystemTest):\n    \"\"\"\n    Check if virtio-version-specific device types result in the\n    same device tree created by `disable-modern` and\n    `disable-legacy`.\n    \"\"\"\n    # just in case there are failures, show larger diff:",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_NET",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_NET = 1\nVIRTIO_BLOCK = 2\nVIRTIO_CONSOLE = 3\nVIRTIO_RNG = 4\nVIRTIO_BALLOON = 5\nVIRTIO_RPMSG = 7\nVIRTIO_SCSI = 8\nVIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_BLOCK",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_BLOCK = 2\nVIRTIO_CONSOLE = 3\nVIRTIO_RNG = 4\nVIRTIO_BALLOON = 5\nVIRTIO_RPMSG = 7\nVIRTIO_SCSI = 8\nVIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_CONSOLE",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_CONSOLE = 3\nVIRTIO_RNG = 4\nVIRTIO_BALLOON = 5\nVIRTIO_RPMSG = 7\nVIRTIO_SCSI = 8\nVIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_RNG",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_RNG = 4\nVIRTIO_BALLOON = 5\nVIRTIO_RPMSG = 7\nVIRTIO_SCSI = 8\nVIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_BALLOON",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_BALLOON = 5\nVIRTIO_RPMSG = 7\nVIRTIO_SCSI = 8\nVIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_RPMSG",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_RPMSG = 7\nVIRTIO_SCSI = 8\nVIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_SCSI",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_SCSI = 8\nVIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_9P",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_9P = 9\nVIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_RPROC_SERIAL",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_RPROC_SERIAL = 11\nVIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_CAIF",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_CAIF = 12\nVIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,\n    VIRTIO_BLOCK:   0x1001,",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_GPU",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_GPU = 16\nVIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,\n    VIRTIO_BLOCK:   0x1001,\n    VIRTIO_BALLOON: 0x1002,",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_INPUT",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_INPUT = 18\nVIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,\n    VIRTIO_BLOCK:   0x1001,\n    VIRTIO_BALLOON: 0x1002,\n    VIRTIO_CONSOLE: 0x1003,",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_VSOCK",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_VSOCK = 19\nVIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,\n    VIRTIO_BLOCK:   0x1001,\n    VIRTIO_BALLOON: 0x1002,\n    VIRTIO_CONSOLE: 0x1003,\n    VIRTIO_SCSI:    0x1004,",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "VIRTIO_CRYPTO",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "VIRTIO_CRYPTO = 20\nPCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,\n    VIRTIO_BLOCK:   0x1001,\n    VIRTIO_BALLOON: 0x1002,\n    VIRTIO_CONSOLE: 0x1003,\n    VIRTIO_SCSI:    0x1004,\n    VIRTIO_RNG:     0x1005,",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "PCI_VENDOR_ID_REDHAT_QUMRANET",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "PCI_VENDOR_ID_REDHAT_QUMRANET = 0x1af4\n# Device IDs for legacy/transitional devices:\nPCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,\n    VIRTIO_BLOCK:   0x1001,\n    VIRTIO_BALLOON: 0x1002,\n    VIRTIO_CONSOLE: 0x1003,\n    VIRTIO_SCSI:    0x1004,\n    VIRTIO_RNG:     0x1005,\n    VIRTIO_9P:      0x1009,",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "PCI_LEGACY_DEVICE_IDS",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_virtio_version",
        "description": "qemu.tests.functional.test_virtio_version",
        "peekOfCode": "PCI_LEGACY_DEVICE_IDS = {\n    VIRTIO_NET:     0x1000,\n    VIRTIO_BLOCK:   0x1001,\n    VIRTIO_BALLOON: 0x1002,\n    VIRTIO_CONSOLE: 0x1003,\n    VIRTIO_SCSI:    0x1004,\n    VIRTIO_RNG:     0x1005,\n    VIRTIO_9P:      0x1009,\n    VIRTIO_VSOCK:   0x1012,\n}",
        "detail": "qemu.tests.functional.test_virtio_version",
        "documentation": {}
    },
    {
        "label": "Vnc",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_vnc",
        "description": "qemu.tests.functional.test_vnc",
        "peekOfCode": "class Vnc(QemuSystemTest):\n    def test_no_vnc_change_password(self):\n        self.vm.add_args('-nodefaults', '-S')\n        self.vm.launch()\n        query_vnc_response = self.vm.qmp('query-vnc')\n        if 'error' in query_vnc_response:\n            self.assertEqual(query_vnc_response['error']['class'],\n                             'CommandNotFound')\n            self.skipTest('VNC support not available')\n        self.assertFalse(query_vnc_response['return']['enabled'])",
        "detail": "qemu.tests.functional.test_vnc",
        "documentation": {}
    },
    {
        "label": "check_connect",
        "kind": 2,
        "importPath": "qemu.tests.functional.test_vnc",
        "description": "qemu.tests.functional.test_vnc",
        "peekOfCode": "def check_connect(port: int) -> bool:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        try:\n            sock.connect((VNC_ADDR, port))\n        except ConnectionRefusedError:\n            return False\n    return True\nclass Vnc(QemuSystemTest):\n    def test_no_vnc_change_password(self):\n        self.vm.add_args('-nodefaults', '-S')",
        "detail": "qemu.tests.functional.test_vnc",
        "documentation": {}
    },
    {
        "label": "VNC_ADDR",
        "kind": 5,
        "importPath": "qemu.tests.functional.test_vnc",
        "description": "qemu.tests.functional.test_vnc",
        "peekOfCode": "VNC_ADDR = '127.0.0.1'\ndef check_connect(port: int) -> bool:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        try:\n            sock.connect((VNC_ADDR, port))\n        except ConnectionRefusedError:\n            return False\n    return True\nclass Vnc(QemuSystemTest):\n    def test_no_vnc_change_password(self):",
        "detail": "qemu.tests.functional.test_vnc",
        "documentation": {}
    },
    {
        "label": "HotPlugBlk",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_64_hotplug_blk",
        "description": "qemu.tests.functional.test_x86_64_hotplug_blk",
        "peekOfCode": "class HotPlugBlk(LinuxKernelTest):\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/vmlinuz'),\n        'd4738d03dbbe083ca610d0821d0a8f1488bebbdccef54ce33e3adb35fda00129')\n    ASSET_INITRD = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/initrd.img'),\n        '277cd6c7adf77c7e63d73bbb2cded8ef9e2d3a2f100000e92ff1f8396513cd8b')\n    def blockdev_add(self) -> None:",
        "detail": "qemu.tests.functional.test_x86_64_hotplug_blk",
        "documentation": {}
    },
    {
        "label": "HotPlugCPU",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_64_hotplug_cpu",
        "description": "qemu.tests.functional.test_x86_64_hotplug_cpu",
        "peekOfCode": "class HotPlugCPU(LinuxKernelTest):\n    ASSET_KERNEL = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/vmlinuz'),\n        'd4738d03dbbe083ca610d0821d0a8f1488bebbdccef54ce33e3adb35fda00129')\n    ASSET_INITRD = Asset(\n        ('https://archives.fedoraproject.org/pub/archive/fedora/linux/releases'\n         '/31/Server/x86_64/os/images/pxeboot/initrd.img'),\n        '277cd6c7adf77c7e63d73bbb2cded8ef9e2d3a2f100000e92ff1f8396513cd8b')\n    def test_hotplug(self):",
        "detail": "qemu.tests.functional.test_x86_64_hotplug_cpu",
        "documentation": {}
    },
    {
        "label": "KVMXenGuest",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_64_kvm_xen",
        "description": "qemu.tests.functional.test_x86_64_kvm_xen",
        "peekOfCode": "class KVMXenGuest(QemuSystemTest):\n    KERNEL_DEFAULT = 'printk.time=0 root=/dev/xvda console=ttyS0 quiet'\n    kernel_path = None\n    kernel_params = None\n    # Fetch assets from the kvm-xen-guest subdir of my shared test\n    # images directory on fileserver.linaro.org where you can find\n    # build instructions for how they where assembled.\n    ASSET_KERNEL = Asset(\n        ('https://fileserver.linaro.org/s/kE4nCFLdQcoBF9t/download?'\n         'path=%2Fkvm-xen-guest&files=bzImage'),",
        "detail": "qemu.tests.functional.test_x86_64_kvm_xen",
        "documentation": {}
    },
    {
        "label": "X86Replay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_64_replay",
        "description": "qemu.tests.functional.test_x86_64_replay",
        "peekOfCode": "class X86Replay(ReplayKernelBase):\n    ASSET_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/x86_64/bzImage',\n        'f57bfc6553bcd6e0a54aab86095bf642b33b5571d14e3af1731b18c87ed5aef8')\n    ASSET_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/x86_64/rootfs.ext4.zst',\n        '4b8b2a99117519c5290e1202cb36eb6c7aaba92b357b5160f5970cf5fb78a751')\n    def do_test_x86(self, machine, blkdevice, devroot):\n        self.require_netdev('user')\n        self.set_machine(machine)",
        "detail": "qemu.tests.functional.test_x86_64_replay",
        "documentation": {}
    },
    {
        "label": "ReverseDebugging_X86_64",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_64_reverse_debug",
        "description": "qemu.tests.functional.test_x86_64_reverse_debug",
        "peekOfCode": "class ReverseDebugging_X86_64(ReverseDebugging):\n    REG_PC = 0x10\n    REG_CS = 0x12\n    def get_pc(self, g):\n        return self.get_reg_le(g, self.REG_PC) \\\n            + self.get_reg_le(g, self.REG_CS) * 0x10\n    @skipFlakyTest(\"https://gitlab.com/qemu-project/qemu/-/issues/2922\")\n    def test_x86_64_pc(self):\n        self.set_machine('pc')\n        # start with BIOS only",
        "detail": "qemu.tests.functional.test_x86_64_reverse_debug",
        "documentation": {}
    },
    {
        "label": "TuxRunX86Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_64_tuxrun",
        "description": "qemu.tests.functional.test_x86_64_tuxrun",
        "peekOfCode": "class TuxRunX86Test(TuxRunBaselineTest):\n    ASSET_X86_64_KERNEL = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/x86_64/bzImage',\n        'f57bfc6553bcd6e0a54aab86095bf642b33b5571d14e3af1731b18c87ed5aef8')\n    ASSET_X86_64_ROOTFS = Asset(\n        'https://storage.tuxboot.com/buildroot/20241119/x86_64/rootfs.ext4.zst',\n        '4b8b2a99117519c5290e1202cb36eb6c7aaba92b357b5160f5970cf5fb78a751')\n    def test_x86_64(self):\n        self.set_machine('q35')\n        self.cpu=\"Nehalem\"",
        "detail": "qemu.tests.functional.test_x86_64_tuxrun",
        "documentation": {}
    },
    {
        "label": "X86CPUModelAliases",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_cpu_model_versions",
        "description": "qemu.tests.functional.test_x86_cpu_model_versions",
        "peekOfCode": "class X86CPUModelAliases(QemuSystemTest):\n    \"\"\"\n    Validation of PC CPU model versions and CPU model aliases\n    \"\"\"\n    def validate_aliases(self, cpus):\n        for c in cpus.values():\n            if 'alias-of' in c:\n                # all aliases must point to a valid CPU model name:\n                self.assertIn(c['alias-of'], cpus,\n                              '%s.alias-of (%s) is not a valid CPU model name' % (c['name'], c['alias-of']))",
        "detail": "qemu.tests.functional.test_x86_cpu_model_versions",
        "documentation": {}
    },
    {
        "label": "CascadelakeArchCapabilities",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_x86_cpu_model_versions",
        "description": "qemu.tests.functional.test_x86_cpu_model_versions",
        "peekOfCode": "class CascadelakeArchCapabilities(QemuSystemTest):\n    \"\"\"\n    Validation of Cascadelake arch-capabilities\n    \"\"\"\n    def get_cpu_prop(self, prop):\n        cpu_path = self.vm.cmd('query-cpus-fast')[0].get('qom-path')\n        return self.vm.cmd('qom-get', path=cpu_path, property=prop)\n    def test_4_1(self):\n        self.set_machine('pc-i440fx-4.1')\n        # machine-type only:",
        "detail": "qemu.tests.functional.test_x86_cpu_model_versions",
        "documentation": {}
    },
    {
        "label": "XTensaLX60Test",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_xtensa_lx60",
        "description": "qemu.tests.functional.test_xtensa_lx60",
        "peekOfCode": "class XTensaLX60Test(LinuxKernelTest):\n    ASSET_DAY02 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day02.tar.xz',\n        '68ff07f9b3fd3df36d015eb46299ba44748e94bfbb2d5295fddc1a8d4a9fd324')\n    def test_xtensa_lx60(self):\n        self.set_machine('lx60')\n        self.cpu = 'dc233c'\n        self.archive_extract(self.ASSET_DAY02)\n        self.launch_kernel(self.scratch_file('day02',\n                                             'santas-sleigh-ride.elf'),",
        "detail": "qemu.tests.functional.test_xtensa_lx60",
        "documentation": {}
    },
    {
        "label": "XTensaReplay",
        "kind": 6,
        "importPath": "qemu.tests.functional.test_xtensa_replay",
        "description": "qemu.tests.functional.test_xtensa_replay",
        "peekOfCode": "class XTensaReplay(ReplayKernelBase):\n    ASSET_DAY02 = Asset(\n        'https://qemu-advcal.gitlab.io/qac-best-of-multiarch/download/day02.tar.xz',\n        '68ff07f9b3fd3df36d015eb46299ba44748e94bfbb2d5295fddc1a8d4a9fd324')\n    def test_replay(self):\n        self.set_machine('lx60')\n        self.cpu = 'dc233c'\n        kernel_path = self.archive_extract(self.ASSET_DAY02,\n                                         member='day02/santas-sleigh-ride.elf')\n        self.run_rr(kernel_path, self.REPLAY_KERNEL_COMMAND_LINE,",
        "detail": "qemu.tests.functional.test_xtensa_replay",
        "documentation": {}
    },
    {
        "label": "get_args",
        "kind": 2,
        "importPath": "qemu.tests.guest-debug.run-test",
        "description": "qemu.tests.guest-debug.run-test",
        "peekOfCode": "def get_args():\n    parser = argparse.ArgumentParser(description=\"A gdbstub test runner\")\n    parser.add_argument(\"--qemu\", help=\"Qemu binary for test\",\n                        required=True)\n    parser.add_argument(\"--qargs\", help=\"Qemu arguments for test\")\n    parser.add_argument(\"--binary\", help=\"Binary to debug\",\n                        required=True)\n    parser.add_argument(\"--test\", help=\"GDB test script\")\n    parser.add_argument('test_args', nargs='*',\n                        help=\"Additional args for GDB test script. \"",
        "detail": "qemu.tests.guest-debug.run-test",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 2,
        "importPath": "qemu.tests.guest-debug.run-test",
        "description": "qemu.tests.guest-debug.run-test",
        "peekOfCode": "def log(output, msg):\n    if output:\n        output.write(msg + \"\\n\")\n        output.flush()\n    else:\n        print(msg)\nif __name__ == '__main__':\n    args = get_args()\n    # Search for a gdb we can use\n    if not args.gdb:",
        "detail": "qemu.tests.guest-debug.run-test",
        "documentation": {}
    },
    {
        "label": "arg_parser",
        "kind": 6,
        "importPath": "qemu.tests.guest-debug.test_gdbstub",
        "description": "qemu.tests.guest-debug.test_gdbstub",
        "peekOfCode": "class arg_parser(argparse.ArgumentParser):\n    def exit(self, status=None, message=\"\"):\n        print(\"Wrong GDB script test argument! \" + message)\n        gdb_exit(1)\ndef report(cond, msg):\n    \"\"\"Report success/fail of a test\"\"\"\n    if cond:\n        print(\"PASS: {}\".format(msg))\n    else:\n        print(\"FAIL: {}\".format(msg))",
        "detail": "qemu.tests.guest-debug.test_gdbstub",
        "documentation": {}
    },
    {
        "label": "gdb_exit",
        "kind": 2,
        "importPath": "qemu.tests.guest-debug.test_gdbstub",
        "description": "qemu.tests.guest-debug.test_gdbstub",
        "peekOfCode": "def gdb_exit(status):\n    gdb.execute(f\"exit {status}\")\nclass arg_parser(argparse.ArgumentParser):\n    def exit(self, status=None, message=\"\"):\n        print(\"Wrong GDB script test argument! \" + message)\n        gdb_exit(1)\ndef report(cond, msg):\n    \"\"\"Report success/fail of a test\"\"\"\n    if cond:\n        print(\"PASS: {}\".format(msg))",
        "detail": "qemu.tests.guest-debug.test_gdbstub",
        "documentation": {}
    },
    {
        "label": "report",
        "kind": 2,
        "importPath": "qemu.tests.guest-debug.test_gdbstub",
        "description": "qemu.tests.guest-debug.test_gdbstub",
        "peekOfCode": "def report(cond, msg):\n    \"\"\"Report success/fail of a test\"\"\"\n    if cond:\n        print(\"PASS: {}\".format(msg))\n    else:\n        print(\"FAIL: {}\".format(msg))\n        global fail_count\n        fail_count += 1\ndef main(test, expected_arch=None):\n    \"\"\"Run a test function",
        "detail": "qemu.tests.guest-debug.test_gdbstub",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.guest-debug.test_gdbstub",
        "description": "qemu.tests.guest-debug.test_gdbstub",
        "peekOfCode": "def main(test, expected_arch=None):\n    \"\"\"Run a test function\n    This runs as the script it sourced (via -x, via run-test.py).\"\"\"\n    try:\n        inferior = gdb.selected_inferior()\n        arch = inferior.architecture()\n        print(\"ATTACHED: {}\".format(arch.name()))\n        if expected_arch is not None:\n            report(arch.name() == expected_arch,\n                   \"connected to {}\".format(expected_arch))",
        "detail": "qemu.tests.guest-debug.test_gdbstub",
        "documentation": {}
    },
    {
        "label": "fail_count",
        "kind": 5,
        "importPath": "qemu.tests.guest-debug.test_gdbstub",
        "description": "qemu.tests.guest-debug.test_gdbstub",
        "peekOfCode": "fail_count = 0\ndef gdb_exit(status):\n    gdb.execute(f\"exit {status}\")\nclass arg_parser(argparse.ArgumentParser):\n    def exit(self, status=None, message=\"\"):\n        print(\"Wrong GDB script test argument! \" + message)\n        gdb_exit(1)\ndef report(cond, msg):\n    \"\"\"Report success/fail of a test\"\"\"\n    if cond:",
        "detail": "qemu.tests.guest-debug.test_gdbstub",
        "documentation": {}
    },
    {
        "label": "random_from_intervals",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def random_from_intervals(intervals):\n    \"\"\"Select a random integer number from the list of specified intervals.\n    Each interval is a tuple of lower and upper limits of the interval. The\n    limits are included. Intervals in a list should not overlap.\n    \"\"\"\n    total = reduce(lambda x, y: x + y[1] - y[0] + 1, intervals, 0)\n    r = random.randint(0, total - 1) + intervals[0][0]\n    for x in zip(intervals, intervals[1:]):\n        r = r + (r > x[0][1]) * (x[1][0] - x[0][1] - 1)\n    return r",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "random_bits",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def random_bits(bit_ranges):\n    \"\"\"Generate random binary mask with ones in the specified bit ranges.\n    Each bit_ranges is a list of tuples of lower and upper limits of bit\n    positions will be fuzzed. The limits are included. Random amount of bits\n    in range limits will be set to ones. The mask is returned in decimal\n    integer format.\n    \"\"\"\n    bit_numbers = []\n    # Select random amount of random positions in bit_ranges\n    for rng in bit_ranges:",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "truncate_bytes",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def truncate_bytes(sequences, length):\n    \"\"\"Return sequences truncated to specified length.\"\"\"\n    if type(sequences) == list:\n        return [s[:length] for s in sequences]\n    else:\n        return sequences[:length]\ndef validator(current, pick, choices):\n    \"\"\"Return a value not equal to the current selected by the pick\n    function from choices.\n    \"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "validator",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def validator(current, pick, choices):\n    \"\"\"Return a value not equal to the current selected by the pick\n    function from choices.\n    \"\"\"\n    while True:\n        val = pick(choices)\n        if not val == current:\n            return val\ndef int_validator(current, intervals):\n    \"\"\"Return a random value from intervals not equal to the current.",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "int_validator",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def int_validator(current, intervals):\n    \"\"\"Return a random value from intervals not equal to the current.\n    This function is useful for selection from valid values except current one.\n    \"\"\"\n    return validator(current, random_from_intervals, intervals)\ndef bit_validator(current, bit_ranges):\n    \"\"\"Return a random bit mask not equal to the current.\n    This function is useful for selection from valid values except current one.\n    \"\"\"\n    return validator(current, random_bits, bit_ranges)",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "bit_validator",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def bit_validator(current, bit_ranges):\n    \"\"\"Return a random bit mask not equal to the current.\n    This function is useful for selection from valid values except current one.\n    \"\"\"\n    return validator(current, random_bits, bit_ranges)\ndef bytes_validator(current, sequences):\n    \"\"\"Return a random bytes value from the list not equal to the current.\n    This function is useful for selection from valid values except current one.\n    \"\"\"\n    return validator(current, random.choice, sequences)",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "bytes_validator",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def bytes_validator(current, sequences):\n    \"\"\"Return a random bytes value from the list not equal to the current.\n    This function is useful for selection from valid values except current one.\n    \"\"\"\n    return validator(current, random.choice, sequences)\ndef selector(current, constraints, validate=int_validator):\n    \"\"\"Select one value from all defined by constraints.\n    Each constraint produces one random value satisfying to it. The function\n    randomly selects one value satisfying at least one constraint (depending on\n    constraints overlaps).",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "selector",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def selector(current, constraints, validate=int_validator):\n    \"\"\"Select one value from all defined by constraints.\n    Each constraint produces one random value satisfying to it. The function\n    randomly selects one value satisfying at least one constraint (depending on\n    constraints overlaps).\n    \"\"\"\n    def iter_validate(c):\n        \"\"\"Apply validate() only to constraints represented as lists.\n        This auxiliary function replaces short circuit conditions not supported\n        in Python 2.4",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "magic",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def magic(current):\n    \"\"\"Fuzz magic header field.\n    The function just returns the current magic value and provides uniformity\n    of calls for all fuzzing functions.\n    \"\"\"\n    return current\ndef version(current):\n    \"\"\"Fuzz version header field.\"\"\"\n    constraints = UINT32_V + [\n        [(2, 3)],  # correct values",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def version(current):\n    \"\"\"Fuzz version header field.\"\"\"\n    constraints = UINT32_V + [\n        [(2, 3)],  # correct values\n        [(0, 1), (4, UINT32)]\n    ]\n    return selector(current, constraints)\ndef backing_file_offset(current):\n    \"\"\"Fuzz backing file offset header field.\"\"\"\n    constraints = UINT64_V",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "backing_file_offset",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def backing_file_offset(current):\n    \"\"\"Fuzz backing file offset header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef backing_file_size(current):\n    \"\"\"Fuzz backing file size header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef cluster_bits(current):\n    \"\"\"Fuzz cluster bits header field.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "backing_file_size",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def backing_file_size(current):\n    \"\"\"Fuzz backing file size header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef cluster_bits(current):\n    \"\"\"Fuzz cluster bits header field.\"\"\"\n    constraints = UINT32_V + [\n        [(9, 20)],  # correct values\n        [(0, 9), (20, UINT32)]\n    ]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "cluster_bits",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def cluster_bits(current):\n    \"\"\"Fuzz cluster bits header field.\"\"\"\n    constraints = UINT32_V + [\n        [(9, 20)],  # correct values\n        [(0, 9), (20, UINT32)]\n    ]\n    return selector(current, constraints)\ndef size(current):\n    \"\"\"Fuzz image size header field.\"\"\"\n    constraints = UINT64_V",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def size(current):\n    \"\"\"Fuzz image size header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef crypt_method(current):\n    \"\"\"Fuzz crypt method header field.\"\"\"\n    constraints = UINT32_V + [\n        1,\n        [(2, UINT32)]\n    ]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "crypt_method",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def crypt_method(current):\n    \"\"\"Fuzz crypt method header field.\"\"\"\n    constraints = UINT32_V + [\n        1,\n        [(2, UINT32)]\n    ]\n    return selector(current, constraints)\ndef l1_size(current):\n    \"\"\"Fuzz L1 table size header field.\"\"\"\n    constraints = UINT32_V",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "l1_size",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def l1_size(current):\n    \"\"\"Fuzz L1 table size header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef l1_table_offset(current):\n    \"\"\"Fuzz L1 table offset header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef refcount_table_offset(current):\n    \"\"\"Fuzz refcount table offset header field.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "l1_table_offset",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def l1_table_offset(current):\n    \"\"\"Fuzz L1 table offset header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef refcount_table_offset(current):\n    \"\"\"Fuzz refcount table offset header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef refcount_table_clusters(current):\n    \"\"\"Fuzz refcount table clusters header field.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "refcount_table_offset",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def refcount_table_offset(current):\n    \"\"\"Fuzz refcount table offset header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef refcount_table_clusters(current):\n    \"\"\"Fuzz refcount table clusters header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef nb_snapshots(current):\n    \"\"\"Fuzz number of snapshots header field.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "refcount_table_clusters",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def refcount_table_clusters(current):\n    \"\"\"Fuzz refcount table clusters header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef nb_snapshots(current):\n    \"\"\"Fuzz number of snapshots header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef snapshots_offset(current):\n    \"\"\"Fuzz snapshots offset header field.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "nb_snapshots",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def nb_snapshots(current):\n    \"\"\"Fuzz number of snapshots header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef snapshots_offset(current):\n    \"\"\"Fuzz snapshots offset header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef incompatible_features(current):\n    \"\"\"Fuzz incompatible features header field.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "snapshots_offset",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def snapshots_offset(current):\n    \"\"\"Fuzz snapshots offset header field.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef incompatible_features(current):\n    \"\"\"Fuzz incompatible features header field.\"\"\"\n    constraints = [\n        [(0, 1)],  # allowable values\n        [(0, UINT64_M)]\n    ]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "incompatible_features",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def incompatible_features(current):\n    \"\"\"Fuzz incompatible features header field.\"\"\"\n    constraints = [\n        [(0, 1)],  # allowable values\n        [(0, UINT64_M)]\n    ]\n    return selector(current, constraints, bit_validator)\ndef compatible_features(current):\n    \"\"\"Fuzz compatible features header field.\"\"\"\n    constraints = [",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "compatible_features",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def compatible_features(current):\n    \"\"\"Fuzz compatible features header field.\"\"\"\n    constraints = [\n        [(0, UINT64_M)]\n    ]\n    return selector(current, constraints, bit_validator)\ndef autoclear_features(current):\n    \"\"\"Fuzz autoclear features header field.\"\"\"\n    constraints = [\n        [(0, UINT64_M)]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "autoclear_features",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def autoclear_features(current):\n    \"\"\"Fuzz autoclear features header field.\"\"\"\n    constraints = [\n        [(0, UINT64_M)]\n    ]\n    return selector(current, constraints, bit_validator)\ndef refcount_order(current):\n    \"\"\"Fuzz number of refcount order header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "refcount_order",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def refcount_order(current):\n    \"\"\"Fuzz number of refcount order header field.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef header_length(current):\n    \"\"\"Fuzz number of refcount order header field.\"\"\"\n    constraints = UINT32_V + [\n        72,\n        104,\n        [(0, UINT32)]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "header_length",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def header_length(current):\n    \"\"\"Fuzz number of refcount order header field.\"\"\"\n    constraints = UINT32_V + [\n        72,\n        104,\n        [(0, UINT32)]\n    ]\n    return selector(current, constraints)\ndef bf_name(current):\n    \"\"\"Fuzz the backing file name.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "bf_name",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def bf_name(current):\n    \"\"\"Fuzz the backing file name.\"\"\"\n    constraints = [\n        truncate_bytes(BYTES_V, len(current))\n    ]\n    return selector(current, constraints, bytes_validator)\ndef ext_magic(current):\n    \"\"\"Fuzz magic field of a header extension.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "ext_magic",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def ext_magic(current):\n    \"\"\"Fuzz magic field of a header extension.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef ext_length(current):\n    \"\"\"Fuzz length field of a header extension.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef bf_format(current):\n    \"\"\"Fuzz backing file format in the corresponding header extension.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "ext_length",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def ext_length(current):\n    \"\"\"Fuzz length field of a header extension.\"\"\"\n    constraints = UINT32_V\n    return selector(current, constraints)\ndef bf_format(current):\n    \"\"\"Fuzz backing file format in the corresponding header extension.\"\"\"\n    constraints = [\n        truncate_bytes(BYTES_V, len(current)),\n        truncate_bytes(BYTES_V, (len(current) + 7) & ~7)  # Fuzz padding\n    ]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "bf_format",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def bf_format(current):\n    \"\"\"Fuzz backing file format in the corresponding header extension.\"\"\"\n    constraints = [\n        truncate_bytes(BYTES_V, len(current)),\n        truncate_bytes(BYTES_V, (len(current) + 7) & ~7)  # Fuzz padding\n    ]\n    return selector(current, constraints, bytes_validator)\ndef feature_type(current):\n    \"\"\"Fuzz feature type field of a feature name table header extension.\"\"\"\n    constraints = UINT8_V",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "feature_type",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def feature_type(current):\n    \"\"\"Fuzz feature type field of a feature name table header extension.\"\"\"\n    constraints = UINT8_V\n    return selector(current, constraints)\ndef feature_bit_number(current):\n    \"\"\"Fuzz bit number field of a feature name table header extension.\"\"\"\n    constraints = UINT8_V\n    return selector(current, constraints)\ndef feature_name(current):\n    \"\"\"Fuzz feature name field of a feature name table header extension.\"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "feature_bit_number",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def feature_bit_number(current):\n    \"\"\"Fuzz bit number field of a feature name table header extension.\"\"\"\n    constraints = UINT8_V\n    return selector(current, constraints)\ndef feature_name(current):\n    \"\"\"Fuzz feature name field of a feature name table header extension.\"\"\"\n    constraints = [\n        truncate_bytes(BYTES_V, len(current)),\n        truncate_bytes(BYTES_V, 46)  # Fuzz padding (field length = 46)\n    ]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "feature_name",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def feature_name(current):\n    \"\"\"Fuzz feature name field of a feature name table header extension.\"\"\"\n    constraints = [\n        truncate_bytes(BYTES_V, len(current)),\n        truncate_bytes(BYTES_V, 46)  # Fuzz padding (field length = 46)\n    ]\n    return selector(current, constraints, bytes_validator)\ndef l1_entry(current):\n    \"\"\"Fuzz an entry of the L1 table.\"\"\"\n    constraints = UINT64_V",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "l1_entry",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def l1_entry(current):\n    \"\"\"Fuzz an entry of the L1 table.\"\"\"\n    constraints = UINT64_V\n    # Reserved bits are ignored\n    # Added a possibility when only flags are fuzzed\n    offset = 0x7fffffffffffffff & \\\n             random.choice([selector(current, constraints), current])\n    is_cow = random.randint(0, 1)\n    return offset + (is_cow << UINT64_M)\ndef l2_entry(current):",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "l2_entry",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def l2_entry(current):\n    \"\"\"Fuzz an entry of an L2 table.\"\"\"\n    constraints = UINT64_V\n    # Reserved bits are ignored\n    # Add a possibility when only flags are fuzzed\n    offset = 0x3ffffffffffffffe & \\\n             random.choice([selector(current, constraints), current])\n    is_compressed = random.randint(0, 1)\n    is_cow = random.randint(0, 1)\n    is_zero = random.randint(0, 1)",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "refcount_table_entry",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def refcount_table_entry(current):\n    \"\"\"Fuzz an entry of the refcount table.\"\"\"\n    constraints = UINT64_V\n    return selector(current, constraints)\ndef refcount_block_entry(current):\n    \"\"\"Fuzz an entry of a refcount block.\"\"\"\n    constraints = UINT16_V\n    return selector(current, constraints)",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "refcount_block_entry",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "def refcount_block_entry(current):\n    \"\"\"Fuzz an entry of a refcount block.\"\"\"\n    constraints = UINT16_V\n    return selector(current, constraints)",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT8",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT8 = 0xff\nUINT16 = 0xffff\nUINT32 = 0xffffffff\nUINT64 = 0xffffffffffffffff\n# Most significant bit orders\nUINT32_M = 31\nUINT64_M = 63\n# Fuzz vectors\nUINT8_V = [0, 0x10, UINT8//4, UINT8//2 - 1, UINT8//2, UINT8//2 + 1, UINT8 - 1,\n           UINT8]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT16",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT16 = 0xffff\nUINT32 = 0xffffffff\nUINT64 = 0xffffffffffffffff\n# Most significant bit orders\nUINT32_M = 31\nUINT64_M = 63\n# Fuzz vectors\nUINT8_V = [0, 0x10, UINT8//4, UINT8//2 - 1, UINT8//2, UINT8//2 + 1, UINT8 - 1,\n           UINT8]\nUINT16_V = [0, 0x100, 0x1000, UINT16//4, UINT16//2 - 1, UINT16//2, UINT16//2 + 1,",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT32",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT32 = 0xffffffff\nUINT64 = 0xffffffffffffffff\n# Most significant bit orders\nUINT32_M = 31\nUINT64_M = 63\n# Fuzz vectors\nUINT8_V = [0, 0x10, UINT8//4, UINT8//2 - 1, UINT8//2, UINT8//2 + 1, UINT8 - 1,\n           UINT8]\nUINT16_V = [0, 0x100, 0x1000, UINT16//4, UINT16//2 - 1, UINT16//2, UINT16//2 + 1,\n            UINT16 - 1, UINT16]",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT64",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT64 = 0xffffffffffffffff\n# Most significant bit orders\nUINT32_M = 31\nUINT64_M = 63\n# Fuzz vectors\nUINT8_V = [0, 0x10, UINT8//4, UINT8//2 - 1, UINT8//2, UINT8//2 + 1, UINT8 - 1,\n           UINT8]\nUINT16_V = [0, 0x100, 0x1000, UINT16//4, UINT16//2 - 1, UINT16//2, UINT16//2 + 1,\n            UINT16 - 1, UINT16]\nUINT32_V = [0, 0x100, 0x1000, 0x10000, 0x100000, UINT32//4, UINT32//2 - 1,",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT32_M",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT32_M = 31\nUINT64_M = 63\n# Fuzz vectors\nUINT8_V = [0, 0x10, UINT8//4, UINT8//2 - 1, UINT8//2, UINT8//2 + 1, UINT8 - 1,\n           UINT8]\nUINT16_V = [0, 0x100, 0x1000, UINT16//4, UINT16//2 - 1, UINT16//2, UINT16//2 + 1,\n            UINT16 - 1, UINT16]\nUINT32_V = [0, 0x100, 0x1000, 0x10000, 0x100000, UINT32//4, UINT32//2 - 1,\n            UINT32//2, UINT32//2 + 1, UINT32 - 1, UINT32]\nUINT64_V = UINT32_V + [0x1000000, 0x10000000, 0x100000000, UINT64//4,",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT64_M",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT64_M = 63\n# Fuzz vectors\nUINT8_V = [0, 0x10, UINT8//4, UINT8//2 - 1, UINT8//2, UINT8//2 + 1, UINT8 - 1,\n           UINT8]\nUINT16_V = [0, 0x100, 0x1000, UINT16//4, UINT16//2 - 1, UINT16//2, UINT16//2 + 1,\n            UINT16 - 1, UINT16]\nUINT32_V = [0, 0x100, 0x1000, 0x10000, 0x100000, UINT32//4, UINT32//2 - 1,\n            UINT32//2, UINT32//2 + 1, UINT32 - 1, UINT32]\nUINT64_V = UINT32_V + [0x1000000, 0x10000000, 0x100000000, UINT64//4,\n                       UINT64//2 - 1, UINT64//2, UINT64//2 + 1, UINT64 - 1,",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT8_V",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT8_V = [0, 0x10, UINT8//4, UINT8//2 - 1, UINT8//2, UINT8//2 + 1, UINT8 - 1,\n           UINT8]\nUINT16_V = [0, 0x100, 0x1000, UINT16//4, UINT16//2 - 1, UINT16//2, UINT16//2 + 1,\n            UINT16 - 1, UINT16]\nUINT32_V = [0, 0x100, 0x1000, 0x10000, 0x100000, UINT32//4, UINT32//2 - 1,\n            UINT32//2, UINT32//2 + 1, UINT32 - 1, UINT32]\nUINT64_V = UINT32_V + [0x1000000, 0x10000000, 0x100000000, UINT64//4,\n                       UINT64//2 - 1, UINT64//2, UINT64//2 + 1, UINT64 - 1,\n                       UINT64]\nBYTES_V = [b'%s%p%x%d', b'.1024d', b'%.2049d', b'%p%p%p%p', b'%x%x%x%x',",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT16_V",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT16_V = [0, 0x100, 0x1000, UINT16//4, UINT16//2 - 1, UINT16//2, UINT16//2 + 1,\n            UINT16 - 1, UINT16]\nUINT32_V = [0, 0x100, 0x1000, 0x10000, 0x100000, UINT32//4, UINT32//2 - 1,\n            UINT32//2, UINT32//2 + 1, UINT32 - 1, UINT32]\nUINT64_V = UINT32_V + [0x1000000, 0x10000000, 0x100000000, UINT64//4,\n                       UINT64//2 - 1, UINT64//2, UINT64//2 + 1, UINT64 - 1,\n                       UINT64]\nBYTES_V = [b'%s%p%x%d', b'.1024d', b'%.2049d', b'%p%p%p%p', b'%x%x%x%x',\n           b'%d%d%d%d', b'%s%s%s%s', b'%99999999999s', b'%08x', b'%%20d', b'%%20n',\n           b'%%20x', b'%%20s', b'%s%s%s%s%s%s%s%s%s%s', b'%p%p%p%p%p%p%p%p%p%p',",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT32_V",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT32_V = [0, 0x100, 0x1000, 0x10000, 0x100000, UINT32//4, UINT32//2 - 1,\n            UINT32//2, UINT32//2 + 1, UINT32 - 1, UINT32]\nUINT64_V = UINT32_V + [0x1000000, 0x10000000, 0x100000000, UINT64//4,\n                       UINT64//2 - 1, UINT64//2, UINT64//2 + 1, UINT64 - 1,\n                       UINT64]\nBYTES_V = [b'%s%p%x%d', b'.1024d', b'%.2049d', b'%p%p%p%p', b'%x%x%x%x',\n           b'%d%d%d%d', b'%s%s%s%s', b'%99999999999s', b'%08x', b'%%20d', b'%%20n',\n           b'%%20x', b'%%20s', b'%s%s%s%s%s%s%s%s%s%s', b'%p%p%p%p%p%p%p%p%p%p',\n           b'%#0123456x%08x%x%s%p%d%n%o%u%c%h%l%q%j%z%Z%t%i%e%g%f%a%C%S%08x%%',\n           b'%s x 129', b'%x x 257']",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "UINT64_V",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "UINT64_V = UINT32_V + [0x1000000, 0x10000000, 0x100000000, UINT64//4,\n                       UINT64//2 - 1, UINT64//2, UINT64//2 + 1, UINT64 - 1,\n                       UINT64]\nBYTES_V = [b'%s%p%x%d', b'.1024d', b'%.2049d', b'%p%p%p%p', b'%x%x%x%x',\n           b'%d%d%d%d', b'%s%s%s%s', b'%99999999999s', b'%08x', b'%%20d', b'%%20n',\n           b'%%20x', b'%%20s', b'%s%s%s%s%s%s%s%s%s%s', b'%p%p%p%p%p%p%p%p%p%p',\n           b'%#0123456x%08x%x%s%p%d%n%o%u%c%h%l%q%j%z%Z%t%i%e%g%f%a%C%S%08x%%',\n           b'%s x 129', b'%x x 257']\ndef random_from_intervals(intervals):\n    \"\"\"Select a random integer number from the list of specified intervals.",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "BYTES_V",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "description": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "peekOfCode": "BYTES_V = [b'%s%p%x%d', b'.1024d', b'%.2049d', b'%p%p%p%p', b'%x%x%x%x',\n           b'%d%d%d%d', b'%s%s%s%s', b'%99999999999s', b'%08x', b'%%20d', b'%%20n',\n           b'%%20x', b'%%20s', b'%s%s%s%s%s%s%s%s%s%s', b'%p%p%p%p%p%p%p%p%p%p',\n           b'%#0123456x%08x%x%s%p%d%n%o%u%c%h%l%q%j%z%Z%t%i%e%g%f%a%C%S%08x%%',\n           b'%s x 129', b'%x x 257']\ndef random_from_intervals(intervals):\n    \"\"\"Select a random integer number from the list of specified intervals.\n    Each interval is a tuple of lower and upper limits of the interval. The\n    limits are included. Intervals in a list should not overlap.\n    \"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.fuzz",
        "documentation": {}
    },
    {
        "label": "Field",
        "kind": 6,
        "importPath": "qemu.tests.image-fuzzer.qcow2.layout",
        "description": "qemu.tests.image-fuzzer.qcow2.layout",
        "peekOfCode": "class Field(object):\n    \"\"\"Atomic image element (field).\n    The class represents an image field as quadruple of a data format\n    of value necessary for its packing to binary form, an offset from\n    the beginning of the image, a value and a name.\n    The field can be iterated as a list [format, offset, value, name].\n    \"\"\"\n    __slots__ = ('fmt', 'offset', 'value', 'name')\n    def __init__(self, fmt, offset, val, name):\n        self.fmt = fmt",
        "detail": "qemu.tests.image-fuzzer.qcow2.layout",
        "documentation": {}
    },
    {
        "label": "FieldsList",
        "kind": 6,
        "importPath": "qemu.tests.image-fuzzer.qcow2.layout",
        "description": "qemu.tests.image-fuzzer.qcow2.layout",
        "peekOfCode": "class FieldsList(object):\n    \"\"\"List of fields.\n    The class allows access to a field in the list by its name.\n    \"\"\"\n    def __init__(self, meta_data=None):\n        if meta_data is None:\n            self.data = []\n        else:\n            self.data = [Field(*f)\n                         for f in meta_data]",
        "detail": "qemu.tests.image-fuzzer.qcow2.layout",
        "documentation": {}
    },
    {
        "label": "Image",
        "kind": 6,
        "importPath": "qemu.tests.image-fuzzer.qcow2.layout",
        "description": "qemu.tests.image-fuzzer.qcow2.layout",
        "peekOfCode": "class Image(object):\n    \"\"\" Qcow2 image object.\n    This class allows to create qcow2 images with random valid structures and\n    values, fuzz them via external qcow2.fuzz module and write the result to\n    a file.\n    \"\"\"\n    def __init__(self, backing_file_name=None):\n        \"\"\"Create a random valid qcow2 image with the correct header and stored\n        backing file name.\n        \"\"\"",
        "detail": "qemu.tests.image-fuzzer.qcow2.layout",
        "documentation": {}
    },
    {
        "label": "create_image",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.qcow2.layout",
        "description": "qemu.tests.image-fuzzer.qcow2.layout",
        "peekOfCode": "def create_image(test_img_path, backing_file_name=None, backing_file_fmt=None,\n                 fields_to_fuzz=None):\n    \"\"\"Create a fuzzed image and write it to the specified file.\"\"\"\n    image = Image(backing_file_name.encode())\n    image.set_backing_file_format(backing_file_fmt.encode())\n    image.create_feature_name_table()\n    image.set_end_of_extension_area()\n    image.create_l_structures()\n    image.create_refcount_structures()\n    image.fuzz(fields_to_fuzz)",
        "detail": "qemu.tests.image-fuzzer.qcow2.layout",
        "documentation": {}
    },
    {
        "label": "MAX_IMAGE_SIZE",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.layout",
        "description": "qemu.tests.image-fuzzer.qcow2.layout",
        "peekOfCode": "MAX_IMAGE_SIZE = 10 * (1 << 20)\n# Standard sizes\nUINT32_S = 4\nUINT64_S = 8\nclass Field(object):\n    \"\"\"Atomic image element (field).\n    The class represents an image field as quadruple of a data format\n    of value necessary for its packing to binary form, an offset from\n    the beginning of the image, a value and a name.\n    The field can be iterated as a list [format, offset, value, name].",
        "detail": "qemu.tests.image-fuzzer.qcow2.layout",
        "documentation": {}
    },
    {
        "label": "UINT32_S",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.layout",
        "description": "qemu.tests.image-fuzzer.qcow2.layout",
        "peekOfCode": "UINT32_S = 4\nUINT64_S = 8\nclass Field(object):\n    \"\"\"Atomic image element (field).\n    The class represents an image field as quadruple of a data format\n    of value necessary for its packing to binary form, an offset from\n    the beginning of the image, a value and a name.\n    The field can be iterated as a list [format, offset, value, name].\n    \"\"\"\n    __slots__ = ('fmt', 'offset', 'value', 'name')",
        "detail": "qemu.tests.image-fuzzer.qcow2.layout",
        "documentation": {}
    },
    {
        "label": "UINT64_S",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.qcow2.layout",
        "description": "qemu.tests.image-fuzzer.qcow2.layout",
        "peekOfCode": "UINT64_S = 8\nclass Field(object):\n    \"\"\"Atomic image element (field).\n    The class represents an image field as quadruple of a data format\n    of value necessary for its packing to binary form, an offset from\n    the beginning of the image, a value and a name.\n    The field can be iterated as a list [format, offset, value, name].\n    \"\"\"\n    __slots__ = ('fmt', 'offset', 'value', 'name')\n    def __init__(self, fmt, offset, val, name):",
        "detail": "qemu.tests.image-fuzzer.qcow2.layout",
        "documentation": {}
    },
    {
        "label": "TestException",
        "kind": 6,
        "importPath": "qemu.tests.image-fuzzer.runner",
        "description": "qemu.tests.image-fuzzer.runner",
        "peekOfCode": "class TestException(Exception):\n    \"\"\"Exception for errors risen by TestEnv objects.\"\"\"\n    pass\nclass TestEnv(object):\n    \"\"\"Test object.\n    The class sets up test environment, generates backing and test images\n    and executes application under tests with specified arguments and a test\n    image provided.\n    All logs are collected.\n    The summary log will contain short descriptions and statuses of tests in",
        "detail": "qemu.tests.image-fuzzer.runner",
        "documentation": {}
    },
    {
        "label": "TestEnv",
        "kind": 6,
        "importPath": "qemu.tests.image-fuzzer.runner",
        "description": "qemu.tests.image-fuzzer.runner",
        "peekOfCode": "class TestEnv(object):\n    \"\"\"Test object.\n    The class sets up test environment, generates backing and test images\n    and executes application under tests with specified arguments and a test\n    image provided.\n    All logs are collected.\n    The summary log will contain short descriptions and statuses of tests in\n    a run.\n    The test log will include application (e.g. 'qemu-img') logs besides info\n    sent to the summary log.",
        "detail": "qemu.tests.image-fuzzer.runner",
        "documentation": {}
    },
    {
        "label": "multilog",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.runner",
        "description": "qemu.tests.image-fuzzer.runner",
        "peekOfCode": "def multilog(msg, *output):\n    \"\"\" Write an object to all of specified file descriptors.\"\"\"\n    for fd in output:\n        fd.write(msg)\n        fd.flush()\ndef str_signal(sig):\n    \"\"\" Convert a numeric value of a system signal to the string one\n    defined by the current operational system.\n    \"\"\"\n    for k, v in signal.__dict__.items():",
        "detail": "qemu.tests.image-fuzzer.runner",
        "documentation": {}
    },
    {
        "label": "str_signal",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.runner",
        "description": "qemu.tests.image-fuzzer.runner",
        "peekOfCode": "def str_signal(sig):\n    \"\"\" Convert a numeric value of a system signal to the string one\n    defined by the current operational system.\n    \"\"\"\n    for k, v in signal.__dict__.items():\n        if v == sig:\n            return k\ndef run_app(fd, q_args):\n    \"\"\"Start an application with specified arguments and return its exit code\n    or kill signal depending on the result of execution.",
        "detail": "qemu.tests.image-fuzzer.runner",
        "documentation": {}
    },
    {
        "label": "run_app",
        "kind": 2,
        "importPath": "qemu.tests.image-fuzzer.runner",
        "description": "qemu.tests.image-fuzzer.runner",
        "peekOfCode": "def run_app(fd, q_args):\n    \"\"\"Start an application with specified arguments and return its exit code\n    or kill signal depending on the result of execution.\n    \"\"\"\n    class Alarm(Exception):\n        \"\"\"Exception for signal.alarm events.\"\"\"\n        pass\n    def handler(*args):\n        \"\"\"Notify that an alarm event occurred.\"\"\"\n        raise Alarm",
        "detail": "qemu.tests.image-fuzzer.runner",
        "documentation": {}
    },
    {
        "label": "MAX_BACKING_FILE_SIZE",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.runner",
        "description": "qemu.tests.image-fuzzer.runner",
        "peekOfCode": "MAX_BACKING_FILE_SIZE = 10\nMIN_BACKING_FILE_SIZE = 1\ndef multilog(msg, *output):\n    \"\"\" Write an object to all of specified file descriptors.\"\"\"\n    for fd in output:\n        fd.write(msg)\n        fd.flush()\ndef str_signal(sig):\n    \"\"\" Convert a numeric value of a system signal to the string one\n    defined by the current operational system.",
        "detail": "qemu.tests.image-fuzzer.runner",
        "documentation": {}
    },
    {
        "label": "MIN_BACKING_FILE_SIZE",
        "kind": 5,
        "importPath": "qemu.tests.image-fuzzer.runner",
        "description": "qemu.tests.image-fuzzer.runner",
        "peekOfCode": "MIN_BACKING_FILE_SIZE = 1\ndef multilog(msg, *output):\n    \"\"\" Write an object to all of specified file descriptors.\"\"\"\n    for fd in output:\n        fd.write(msg)\n        fd.flush()\ndef str_signal(sig):\n    \"\"\" Convert a numeric value of a system signal to the string one\n    defined by the current operational system.\n    \"\"\"",
        "detail": "qemu.tests.image-fuzzer.runner",
        "documentation": {}
    },
    {
        "label": "Comparison",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.comparison",
        "description": "qemu.tests.migration-stress.guestperf.comparison",
        "peekOfCode": "class Comparison(object):\n    def __init__(self, name, scenarios):\n        self._name = name\n        self._scenarios = scenarios\nCOMPARISONS = [\n    # Looking at effect of pausing guest during migration\n    # at various stages of iteration over RAM\n    Comparison(\"pause-iters\", scenarios = [\n        Scenario(\"pause-iters-0\",\n                 pause=True, pause_iters=0),",
        "detail": "qemu.tests.migration-stress.guestperf.comparison",
        "documentation": {}
    },
    {
        "label": "COMPARISONS",
        "kind": 5,
        "importPath": "qemu.tests.migration-stress.guestperf.comparison",
        "description": "qemu.tests.migration-stress.guestperf.comparison",
        "peekOfCode": "COMPARISONS = [\n    # Looking at effect of pausing guest during migration\n    # at various stages of iteration over RAM\n    Comparison(\"pause-iters\", scenarios = [\n        Scenario(\"pause-iters-0\",\n                 pause=True, pause_iters=0),\n        Scenario(\"pause-iters-1\",\n                 pause=True, pause_iters=1),\n        Scenario(\"pause-iters-5\",\n                 pause=True, pause_iters=5),",
        "detail": "qemu.tests.migration-stress.guestperf.comparison",
        "documentation": {}
    },
    {
        "label": "Engine",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.engine",
        "description": "qemu.tests.migration-stress.guestperf.engine",
        "peekOfCode": "class Engine(object):\n    def __init__(self, binary, dst_host, kernel, initrd, transport=\"tcp\",\n                 sleep=15, verbose=False, debug=False):\n        self._binary = binary # Path to QEMU binary\n        self._dst_host = dst_host # Hostname of target host\n        self._kernel = kernel # Path to kernel image\n        self._initrd = initrd # Path to stress initrd\n        self._transport = transport # 'unix' or 'tcp' or 'rdma'\n        self._sleep = sleep\n        self._verbose = verbose",
        "detail": "qemu.tests.migration-stress.guestperf.engine",
        "documentation": {}
    },
    {
        "label": "MULTIFD_CMP_ALGS",
        "kind": 5,
        "importPath": "qemu.tests.migration-stress.guestperf.engine",
        "description": "qemu.tests.migration-stress.guestperf.engine",
        "peekOfCode": "MULTIFD_CMP_ALGS = (\"zlib\", \"zstd\", \"qpl\", \"uadk\")\nclass Engine(object):\n    def __init__(self, binary, dst_host, kernel, initrd, transport=\"tcp\",\n                 sleep=15, verbose=False, debug=False):\n        self._binary = binary # Path to QEMU binary\n        self._dst_host = dst_host # Hostname of target host\n        self._kernel = kernel # Path to kernel image\n        self._initrd = initrd # Path to stress initrd\n        self._transport = transport # 'unix' or 'tcp' or 'rdma'\n        self._sleep = sleep",
        "detail": "qemu.tests.migration-stress.guestperf.engine",
        "documentation": {}
    },
    {
        "label": "Hardware",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.hardware",
        "description": "qemu.tests.migration-stress.guestperf.hardware",
        "peekOfCode": "class Hardware(object):\n    def __init__(self, cpus=1, mem=1,\n                 src_cpu_bind=None, src_mem_bind=None,\n                 dst_cpu_bind=None, dst_mem_bind=None,\n                 prealloc_pages = False,\n                 huge_pages=False, locked_pages=False,\n                 dirty_ring_size=0):\n        self._cpus = cpus\n        self._mem = mem # GiB\n        self._src_mem_bind = src_mem_bind # List of NUMA nodes",
        "detail": "qemu.tests.migration-stress.guestperf.hardware",
        "documentation": {}
    },
    {
        "label": "Plot",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.plot",
        "description": "qemu.tests.migration-stress.guestperf.plot",
        "peekOfCode": "class Plot(object):\n    # Generated using\n    # http://tools.medialab.sciences-po.fr/iwanthue/\n    COLORS = [\"#CD54D0\",\n              \"#79D94C\",\n              \"#7470CD\",\n              \"#D2D251\",\n              \"#863D79\",\n              \"#76DDA6\",\n              \"#D4467B\",",
        "detail": "qemu.tests.migration-stress.guestperf.plot",
        "documentation": {}
    },
    {
        "label": "ProgressStats",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.progress",
        "description": "qemu.tests.migration-stress.guestperf.progress",
        "peekOfCode": "class ProgressStats(object):\n    def __init__(self,\n                 transferred_bytes,\n                 remaining_bytes,\n                 total_bytes,\n                 duplicate_pages,\n                 skipped_pages,\n                 normal_pages,\n                 normal_bytes,\n                 dirty_rate_pps,",
        "detail": "qemu.tests.migration-stress.guestperf.progress",
        "documentation": {}
    },
    {
        "label": "Progress",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.progress",
        "description": "qemu.tests.migration-stress.guestperf.progress",
        "peekOfCode": "class Progress(object):\n    def __init__(self,\n                 status,\n                 ram,\n                 now,\n                 duration,\n                 downtime,\n                 downtime_expected,\n                 setup_time,\n                 throttle_pcent,",
        "detail": "qemu.tests.migration-stress.guestperf.progress",
        "documentation": {}
    },
    {
        "label": "ReportResult",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.report",
        "description": "qemu.tests.migration-stress.guestperf.report",
        "peekOfCode": "class ReportResult(object):\n    def __init__(self, success=False):\n        self._success = success\n    def serialize(self):\n        return {\n            \"success\": self._success,\n        }\n    @classmethod\n    def deserialize(cls, data):\n        return cls(",
        "detail": "qemu.tests.migration-stress.guestperf.report",
        "documentation": {}
    },
    {
        "label": "Report",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.report",
        "description": "qemu.tests.migration-stress.guestperf.report",
        "peekOfCode": "class Report(object):\n    def __init__(self,\n                 hardware,\n                 scenario,\n                 progress_history,\n                 guest_timings,\n                 qemu_timings,\n                 vcpu_timings,\n                 result,\n                 binary,",
        "detail": "qemu.tests.migration-stress.guestperf.report",
        "documentation": {}
    },
    {
        "label": "Scenario",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.scenario",
        "description": "qemu.tests.migration-stress.guestperf.scenario",
        "peekOfCode": "class Scenario(object):\n    def __init__(self, name,\n                 downtime=500,\n                 bandwidth=125000, # 1000 gig-e, effectively unlimited\n                 max_iters=30,\n                 max_time=300,\n                 pause=False, pause_iters=5,\n                 post_copy=False, post_copy_iters=5,\n                 auto_converge=False, auto_converge_step=10,\n                 compression_mt=False, compression_mt_threads=1,",
        "detail": "qemu.tests.migration-stress.guestperf.scenario",
        "documentation": {}
    },
    {
        "label": "BaseShell",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.shell",
        "description": "qemu.tests.migration-stress.guestperf.shell",
        "peekOfCode": "class BaseShell(object):\n    def __init__(self):\n        parser = argparse.ArgumentParser(description=\"Migration Test Tool\")\n        # Test args\n        parser.add_argument(\"--debug\", dest=\"debug\", default=False, action=\"store_true\")\n        parser.add_argument(\"--verbose\", dest=\"verbose\", default=False, action=\"store_true\")\n        parser.add_argument(\"--sleep\", dest=\"sleep\", default=15, type=int)\n        parser.add_argument(\"--binary\", dest=\"binary\", default=\"/usr/bin/qemu-system-x86_64\")\n        parser.add_argument(\"--dst-host\", dest=\"dst_host\", default=\"localhost\")\n        parser.add_argument(\"--kernel\", dest=\"kernel\", default=\"/boot/vmlinuz-%s\" % platform.release())",
        "detail": "qemu.tests.migration-stress.guestperf.shell",
        "documentation": {}
    },
    {
        "label": "Shell",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.shell",
        "description": "qemu.tests.migration-stress.guestperf.shell",
        "peekOfCode": "class Shell(BaseShell):\n    def __init__(self):\n        super(Shell, self).__init__()\n        parser = self._parser\n        parser.add_argument(\"--output\", dest=\"output\", default=None)\n        # Scenario args\n        parser.add_argument(\"--max-iters\", dest=\"max_iters\", default=30, type=int)\n        parser.add_argument(\"--max-time\", dest=\"max_time\", default=300, type=int)\n        parser.add_argument(\"--bandwidth\", dest=\"bandwidth\", default=125000, type=int)\n        parser.add_argument(\"--downtime\", dest=\"downtime\", default=500, type=int)",
        "detail": "qemu.tests.migration-stress.guestperf.shell",
        "documentation": {}
    },
    {
        "label": "BatchShell",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.shell",
        "description": "qemu.tests.migration-stress.guestperf.shell",
        "peekOfCode": "class BatchShell(BaseShell):\n    def __init__(self):\n        super(BatchShell, self).__init__()\n        parser = self._parser\n        parser.add_argument(\"--filter\", dest=\"filter\", default=\"*\")\n        parser.add_argument(\"--output\", dest=\"output\", default=os.getcwd())\n    def run(self, argv):\n        args = self._parser.parse_args(argv)\n        logging.basicConfig(level=(logging.DEBUG if args.debug else\n                                   logging.INFO if args.verbose else",
        "detail": "qemu.tests.migration-stress.guestperf.shell",
        "documentation": {}
    },
    {
        "label": "PlotShell",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.shell",
        "description": "qemu.tests.migration-stress.guestperf.shell",
        "peekOfCode": "class PlotShell(object):\n    def __init__(self):\n        super(PlotShell, self).__init__()\n        self._parser = argparse.ArgumentParser(description=\"Migration Test Tool\")\n        self._parser.add_argument(\"--output\", dest=\"output\", default=None)\n        self._parser.add_argument(\"--debug\", dest=\"debug\", default=False, action=\"store_true\")\n        self._parser.add_argument(\"--verbose\", dest=\"verbose\", default=False, action=\"store_true\")\n        self._parser.add_argument(\"--migration-iters\", dest=\"migration_iters\", default=False, action=\"store_true\")\n        self._parser.add_argument(\"--total-guest-cpu\", dest=\"total_guest_cpu\", default=False, action=\"store_true\")\n        self._parser.add_argument(\"--split-guest-cpu\", dest=\"split_guest_cpu\", default=False, action=\"store_true\")",
        "detail": "qemu.tests.migration-stress.guestperf.shell",
        "documentation": {}
    },
    {
        "label": "TimingRecord",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.timings",
        "description": "qemu.tests.migration-stress.guestperf.timings",
        "peekOfCode": "class TimingRecord(object):\n    def __init__(self, tid, timestamp, value):\n        self._tid = tid\n        self._timestamp = timestamp\n        self._value = value\n    def serialize(self):\n        return {\n            \"tid\": self._tid,\n            \"timestamp\": self._timestamp,\n            \"value\": self._value",
        "detail": "qemu.tests.migration-stress.guestperf.timings",
        "documentation": {}
    },
    {
        "label": "Timings",
        "kind": 6,
        "importPath": "qemu.tests.migration-stress.guestperf.timings",
        "description": "qemu.tests.migration-stress.guestperf.timings",
        "peekOfCode": "class Timings(object):\n    def __init__(self, records):\n        self._records = records\n    def serialize(self):\n        return [record.serialize() for record in self._records]\n    @classmethod\n    def deserialize(cls, data):\n        return Timings([TimingRecord.deserialize(record) for record in data])",
        "detail": "qemu.tests.migration-stress.guestperf.timings",
        "documentation": {}
    },
    {
        "label": "shell",
        "kind": 5,
        "importPath": "qemu.tests.migration-stress.guestperf-batch",
        "description": "qemu.tests.migration-stress.guestperf-batch",
        "peekOfCode": "shell = BatchShell()\nsys.exit(shell.run(sys.argv[1:]))",
        "detail": "qemu.tests.migration-stress.guestperf-batch",
        "documentation": {}
    },
    {
        "label": "shell",
        "kind": 5,
        "importPath": "qemu.tests.migration-stress.guestperf-plot",
        "description": "qemu.tests.migration-stress.guestperf-plot",
        "peekOfCode": "shell = PlotShell()\nsys.exit(shell.run(sys.argv[1:]))",
        "detail": "qemu.tests.migration-stress.guestperf-plot",
        "documentation": {}
    },
    {
        "label": "shell",
        "kind": 5,
        "importPath": "qemu.tests.migration-stress.guestperf",
        "description": "qemu.tests.migration-stress.guestperf",
        "peekOfCode": "shell = Shell()\nsys.exit(shell.run(sys.argv[1:]))",
        "detail": "qemu.tests.migration-stress.guestperf",
        "documentation": {}
    },
    {
        "label": "QAPISchemaTestVisitor",
        "kind": 6,
        "importPath": "qemu.tests.qapi-schema.test-qapi",
        "description": "qemu.tests.qapi-schema.test-qapi",
        "peekOfCode": "class QAPISchemaTestVisitor(QAPISchemaVisitor):\n    def visit_module(self, name):\n        print('module %s' % name)\n    def visit_include(self, name, info):\n        print('include %s' % name)\n    def visit_enum_type(self, name, info, ifcond, features, members, prefix):\n        print('enum %s' % name)\n        if prefix:\n            print('    prefix %s' % prefix)\n        for m in members:",
        "detail": "qemu.tests.qapi-schema.test-qapi",
        "documentation": {}
    },
    {
        "label": "test_frontend",
        "kind": 2,
        "importPath": "qemu.tests.qapi-schema.test-qapi",
        "description": "qemu.tests.qapi-schema.test-qapi",
        "peekOfCode": "def test_frontend(fname):\n    schema = QAPISchema(fname)\n    schema.visit(QAPISchemaTestVisitor())\n    for doc in schema.docs:\n        if doc.symbol:\n            print('doc symbol=%s' % doc.symbol)\n        else:\n            print('doc freeform')\n        print('    body=\\n%s' % doc.body.text)\n        for arg, section in doc.args.items():",
        "detail": "qemu.tests.qapi-schema.test-qapi",
        "documentation": {}
    },
    {
        "label": "open_test_result",
        "kind": 2,
        "importPath": "qemu.tests.qapi-schema.test-qapi",
        "description": "qemu.tests.qapi-schema.test-qapi",
        "peekOfCode": "def open_test_result(dir_name, file_name, update):\n    mode = 'r+' if update else 'r'\n    try:\n        return open(os.path.join(dir_name, file_name), mode, encoding='utf-8')\n    except FileNotFoundError:\n        if not update:\n            raise\n    return open(os.path.join(dir_name, file_name), 'w+', encoding='utf-8')\ndef test_and_diff(test_name, dir_name, update):\n    sys.stdout = StringIO()",
        "detail": "qemu.tests.qapi-schema.test-qapi",
        "documentation": {}
    },
    {
        "label": "test_and_diff",
        "kind": 2,
        "importPath": "qemu.tests.qapi-schema.test-qapi",
        "description": "qemu.tests.qapi-schema.test-qapi",
        "peekOfCode": "def test_and_diff(test_name, dir_name, update):\n    sys.stdout = StringIO()\n    try:\n        test_frontend(os.path.join(dir_name, test_name + '.json'))\n    except QAPIError as err:\n        errstr = str(err) + '\\n'\n        if dir_name:\n            errstr = errstr.replace(dir_name + '/', '')\n        actual_err = errstr.splitlines(True)\n    else:",
        "detail": "qemu.tests.qapi-schema.test-qapi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.qapi-schema.test-qapi",
        "description": "qemu.tests.qapi-schema.test-qapi",
        "peekOfCode": "def main(argv):\n    parser = argparse.ArgumentParser(\n        description='QAPI schema tester')\n    parser.add_argument('-d', '--dir', action='store', default='',\n                        help=\"directory containing tests\")\n    parser.add_argument('-u', '--update', action='store_true',\n                        default='QAPI_TEST_UPDATE' in os.environ,\n                        help=\"update expected test results\")\n    parser.add_argument('tests', nargs='*', metavar='TEST', action='store')\n    args = parser.parse_args()",
        "detail": "qemu.tests.qapi-schema.test-qapi",
        "documentation": {}
    },
    {
        "label": "MBR",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "class MBR:\n    def __init__(self, data: bytes):\n        assert len(data) == 512\n        self.partition_table = []\n        for i in range(4):\n            partition = data[446 + i * 16 : 446 + (i + 1) * 16]\n            self.partition_table.append(\n                {\n                    \"status\": partition[0],\n                    \"start_head\": partition[1],",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "FatBootSector",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "class FatBootSector:\n    # pylint: disable=too-many-instance-attributes\n    def __init__(self, data: bytes):\n        assert len(data) == 512\n        self.bytes_per_sector = int.from_bytes(data[11:13], \"little\")\n        self.sectors_per_cluster = data[13]\n        self.reserved_sectors = int.from_bytes(data[14:16], \"little\")\n        self.fat_count = data[16]\n        self.root_entries = int.from_bytes(data[17:19], \"little\")\n        total_sectors_16 = int.from_bytes(data[19:21], \"little\")",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "FatDirectoryEntry",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "class FatDirectoryEntry:\n    # pylint: disable=too-many-instance-attributes\n    def __init__(self, data: bytes, sector: int, offset: int):\n        self.name = data[0:8].decode(\"ascii\").strip()\n        self.ext = data[8:11].decode(\"ascii\").strip()\n        self.attributes = data[11]\n        self.reserved = data[12]\n        self.create_time_tenth = data[13]\n        self.create_time = int.from_bytes(data[14:16], \"little\")\n        self.create_date = int.from_bytes(data[16:18], \"little\")",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "SectorReader",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "class SectorReader(Protocol):\n    def __call__(self, start_sector: int, num_sectors: int = 1) -> bytes: ...\n# pylint: disable=broad-exception-raised\nclass Fat16:\n    def __init__(\n        self,\n        start_sector: int,\n        size: int,\n        sector_reader: SectorReader,\n        sector_writer: Callable[[int, bytes], None]",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "Fat16",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "class Fat16:\n    def __init__(\n        self,\n        start_sector: int,\n        size: int,\n        sector_reader: SectorReader,\n        sector_writer: Callable[[int, bytes], None]\n    ):\n        self.start_sector = start_sector\n        self.size_in_sectors = size",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "SECTOR_SIZE",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "SECTOR_SIZE = 512\nDIRENTRY_SIZE = 32\nALLOWED_FILE_CHARS = set(\n    \"!#$%&'()-@^_`{}~\" + string.digits + string.ascii_uppercase\n)\nclass MBR:\n    def __init__(self, data: bytes):\n        assert len(data) == 512\n        self.partition_table = []\n        for i in range(4):",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "DIRENTRY_SIZE",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "DIRENTRY_SIZE = 32\nALLOWED_FILE_CHARS = set(\n    \"!#$%&'()-@^_`{}~\" + string.digits + string.ascii_uppercase\n)\nclass MBR:\n    def __init__(self, data: bytes):\n        assert len(data) == 512\n        self.partition_table = []\n        for i in range(4):\n            partition = data[446 + i * 16 : 446 + (i + 1) * 16]",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "ALLOWED_FILE_CHARS",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.fat16",
        "description": "qemu.tests.qemu-iotests.fat16",
        "peekOfCode": "ALLOWED_FILE_CHARS = set(\n    \"!#$%&'()-@^_`{}~\" + string.digits + string.ascii_uppercase\n)\nclass MBR:\n    def __init__(self, data: bytes):\n        assert len(data) == 512\n        self.partition_table = []\n        for i in range(4):\n            partition = data[446 + i * 16 : 446 + (i + 1) * 16]\n            self.partition_table.append(",
        "detail": "qemu.tests.qemu-iotests.fat16",
        "documentation": {}
    },
    {
        "label": "TestFinder",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.findtests",
        "description": "qemu.tests.qemu-iotests.findtests",
        "peekOfCode": "class TestFinder:\n    def __init__(self, test_dir: Optional[str] = None) -> None:\n        self.groups = defaultdict(set)\n        with chdir(test_dir):\n            self.all_tests = glob.glob('[0-9][0-9][0-9]')\n            self.all_tests += [f for f in glob.iglob('tests/*')\n                               if not f.endswith('.out') and\n                               os.path.isfile(f + '.out')]\n            for t in self.all_tests:\n                with open(t, encoding=\"utf-8\") as f:",
        "detail": "qemu.tests.qemu-iotests.findtests",
        "documentation": {}
    },
    {
        "label": "chdir",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.findtests",
        "description": "qemu.tests.qemu-iotests.findtests",
        "peekOfCode": "def chdir(path: Optional[str] = None) -> Iterator[None]:\n    if path is None:\n        yield\n        return\n    saved_dir = os.getcwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(saved_dir)",
        "detail": "qemu.tests.qemu-iotests.findtests",
        "documentation": {}
    },
    {
        "label": "QemuIoInteractive",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class QemuIoInteractive:\n    def __init__(self, *args):\n        self.args = qemu_io_wrap_args(args)\n        # We need to keep the Popen objext around, and not\n        # close it immediately. Therefore, disable the pylint check:\n        # pylint: disable=consider-using-with\n        self._p = subprocess.Popen(self.args, stdin=subprocess.PIPE,\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.STDOUT,\n                                   universal_newlines=True)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "QemuStorageDaemon",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class QemuStorageDaemon:\n    _qmp: Optional[QEMUMonitorProtocol] = None\n    _qmpsock: Optional[str] = None\n    # Python < 3.8 would complain if this type were not a string literal\n    # (importing `annotations` from `__future__` would work; but not on <= 3.6)\n    _p: 'Optional[subprocess.Popen[bytes]]' = None\n    def __init__(self, *args: str, instance_id: str = 'a', qmp: bool = False):\n        assert '--pidfile' not in args\n        self.pidfile = os.path.join(test_dir, f'qsd-{instance_id}-pid')\n        all_args = [qsd_prog] + list(args) + ['--pidfile', self.pidfile]",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class Timeout:\n    def __init__(self, seconds, errmsg=\"Timeout\"):\n        self.seconds = seconds\n        self.errmsg = errmsg\n    def __enter__(self):\n        if qemu_gdb or qemu_valgrind:\n            return self\n        signal.signal(signal.SIGALRM, self.timeout)\n        signal.setitimer(signal.ITIMER_REAL, self.seconds)\n        return self",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "FilePath",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class FilePath:\n    \"\"\"\n    Context manager generating multiple file names. The generated files are\n    removed when exiting the context.\n    Example usage:\n        with FilePath('a.img', 'b.img') as (img_a, img_b):\n            # Use img_a and img_b here...\n        # a.img and b.img are automatically removed here.\n    By default images are created in iotests.test_dir. To create sockets use\n    iotests.sock_dir:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "VM",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class VM(qtest.QEMUQtestMachine):\n    '''A QEMU VM'''\n    def __init__(self, path_suffix=''):\n        name = \"qemu%s-%d\" % (path_suffix, os.getpid())\n        timer = 15.0 if not (qemu_gdb or qemu_valgrind) else None\n        if qemu_gdb and qemu_valgrind:\n            sys.stderr.write('gdb and valgrind are mutually exclusive\\n')\n            sys.exit(1)\n        wrapper = qemu_gdb if qemu_gdb else qemu_valgrind\n        super().__init__(qemu_prog, qemu_opts, wrapper=wrapper,",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "QMPTestCase",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class QMPTestCase(unittest.TestCase):\n    '''Abstract base class for QMP test cases'''\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Many users of this class set a VM property we rely on heavily\n        # in the methods below.\n        self.vm = None\n    def dictpath(self, d, path):\n        '''Traverse a path in a nested dict'''\n        for component in path.split('/'):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "ReproducibleTestResult",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class ReproducibleTestResult(unittest.TextTestResult):\n    def addSkip(self, test, reason):\n        # Same as TextTestResult, but print dot instead of \"s\"\n        unittest.TestResult.addSkip(self, test, reason)\n        if self.showAll:\n            self.stream.writeln(\"skipped {0!r}\".format(reason))\n        elif self.dots:\n            self.stream.write(\".\")\n            self.stream.flush()\nclass ReproducibleStreamWrapper:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "ReproducibleStreamWrapper",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class ReproducibleStreamWrapper:\n    def __init__(self, stream: TextIO):\n        self.stream = stream\n    def __getattr__(self, attr):\n        if attr in ('stream', '__getstate__'):\n            raise AttributeError(attr)\n        return getattr(self.stream, attr)\n    def write(self, arg=None):\n        arg = re.sub(r'Ran (\\d+) tests? in [\\d.]+s', r'Ran \\1 tests', arg)\n        arg = re.sub(r' \\(skipped=\\d+\\)', r'', arg)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "ReproducibleTestRunner",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "class ReproducibleTestRunner(unittest.TextTestRunner):\n    def __init__(\n        self,\n        stream: Optional[TextIO] = None,\n        resultclass: Type[unittest.TextTestResult] =\n        ReproducibleTestResult,\n        **kwargs: Any\n    ) -> None:\n        rstream = ReproducibleStreamWrapper(stream or sys.stdout)\n        super().__init__(stream=rstream,           # type: ignore",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "change_log_level",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def change_log_level(\n        logger_name: str, level: int = logging.CRITICAL) -> Iterator[None]:\n    \"\"\"\n    Utility function for temporarily changing the log level of a logger.\n    This can be used to silence errors that are expected or uninteresting.\n    \"\"\"\n    _logger = logging.getLogger(logger_name)\n    current_level = _logger.level\n    _logger.setLevel(level)\n    try:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "unarchive_sample_image",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def unarchive_sample_image(sample, fname):\n    sample_fname = os.path.join(sample_img_dir, sample + '.bz2')\n    with bz2.open(sample_fname) as f_in, open(fname, 'wb') as f_out:\n        shutil.copyfileobj(f_in, f_out)\ndef qemu_tool_popen(args: Sequence[str],\n                    connect_stderr: bool = True) -> 'subprocess.Popen[str]':\n    stderr = subprocess.STDOUT if connect_stderr else None\n    # pylint: disable=consider-using-with\n    return subprocess.Popen(args,\n                            stdout=subprocess.PIPE,",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_tool_popen",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_tool_popen(args: Sequence[str],\n                    connect_stderr: bool = True) -> 'subprocess.Popen[str]':\n    stderr = subprocess.STDOUT if connect_stderr else None\n    # pylint: disable=consider-using-with\n    return subprocess.Popen(args,\n                            stdout=subprocess.PIPE,\n                            stderr=stderr,\n                            universal_newlines=True)\ndef qemu_tool_pipe_and_status(tool: str, args: Sequence[str],\n                              connect_stderr: bool = True,",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_tool_pipe_and_status",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_tool_pipe_and_status(tool: str, args: Sequence[str],\n                              connect_stderr: bool = True,\n                              drop_successful_output: bool = False) \\\n        -> Tuple[str, int]:\n    \"\"\"\n    Run a tool and return both its output and its exit code\n    \"\"\"\n    with qemu_tool_popen(args, connect_stderr) as subp:\n        output = subp.communicate()[0]\n        if subp.returncode < 0:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_create_prepare_args",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_create_prepare_args(args: List[str]) -> List[str]:\n    if not args or args[0] != 'create':\n        return list(args)\n    args = args[1:]\n    p = argparse.ArgumentParser(allow_abbrev=False)\n    # -o option may be specified several times\n    p.add_argument('-o', action='append', default=[])\n    p.add_argument('-f')\n    parsed, remaining = p.parse_known_args(args)\n    opts_list = parsed.o",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_tool",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_tool(*args: str, check: bool = True, combine_stdio: bool = True\n              ) -> 'subprocess.CompletedProcess[str]':\n    \"\"\"\n    Run a qemu tool and return its status code and console output.\n    :param args: full command line to run.\n    :param check: Enforce a return code of zero.\n    :param combine_stdio: set to False to keep stdout/stderr separated.\n    :raise VerboseProcessError:\n        When the return code is negative, or on any non-zero exit code\n        when 'check=True' was provided (the default). This exception has",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img(*args: str, check: bool = True, combine_stdio: bool = True\n             ) -> 'subprocess.CompletedProcess[str]':\n    \"\"\"\n    Run QEMU_IMG_PROG and return its status code and console output.\n    This function always prepends QEMU_IMG_OPTIONS and may further alter\n    the args for 'create' commands.\n    See `qemu_tool()` for greater detail.\n    \"\"\"\n    full_args = qemu_img_args + qemu_img_create_prepare_args(list(args))\n    return qemu_tool(*full_args, check=check, combine_stdio=combine_stdio)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "ordered_qmp",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def ordered_qmp(qmsg, conv_keys=True):\n    # Dictionaries are not ordered prior to 3.6, therefore:\n    if isinstance(qmsg, list):\n        return [ordered_qmp(atom) for atom in qmsg]\n    if isinstance(qmsg, dict):\n        od = OrderedDict()\n        for k, v in sorted(qmsg.items()):\n            if conv_keys:\n                k = k.replace('_', '-')\n            od[k] = ordered_qmp(v, conv_keys=False)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_create",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_create(*args: str) -> 'subprocess.CompletedProcess[str]':\n    return qemu_img('create', *args)\ndef qemu_img_json(*args: str) -> Any:\n    \"\"\"\n    Run qemu-img and return its output as deserialized JSON.\n    :raise CalledProcessError:\n        When qemu-img crashes, or returns a non-zero exit code without\n        producing a valid JSON document to stdout.\n    :raise JSONDecoderError:\n        When qemu-img returns 0, but failed to produce a valid JSON document.",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_json",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_json(*args: str) -> Any:\n    \"\"\"\n    Run qemu-img and return its output as deserialized JSON.\n    :raise CalledProcessError:\n        When qemu-img crashes, or returns a non-zero exit code without\n        producing a valid JSON document to stdout.\n    :raise JSONDecoderError:\n        When qemu-img returns 0, but failed to produce a valid JSON document.\n    :return: A deserialized JSON object; probably a dict[str, Any].\n    \"\"\"",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_measure",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_measure(*args: str) -> Any:\n    return qemu_img_json(\"measure\", \"--output\", \"json\", *args)\ndef qemu_img_check(*args: str) -> Any:\n    return qemu_img_json(\"check\", \"--output\", \"json\", *args)\ndef qemu_img_info(*args: str) -> Any:\n    return qemu_img_json('info', \"--output\", \"json\", *args)\ndef qemu_img_map(*args: str) -> Any:\n    return qemu_img_json('map', \"--output\", \"json\", *args)\ndef qemu_img_log(*args: str, check: bool = True\n                 ) -> 'subprocess.CompletedProcess[str]':",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_check",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_check(*args: str) -> Any:\n    return qemu_img_json(\"check\", \"--output\", \"json\", *args)\ndef qemu_img_info(*args: str) -> Any:\n    return qemu_img_json('info', \"--output\", \"json\", *args)\ndef qemu_img_map(*args: str) -> Any:\n    return qemu_img_json('map', \"--output\", \"json\", *args)\ndef qemu_img_log(*args: str, check: bool = True\n                 ) -> 'subprocess.CompletedProcess[str]':\n    result = qemu_img(*args, check=check)\n    log(result.stdout, filters=[filter_testfiles])",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_info",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_info(*args: str) -> Any:\n    return qemu_img_json('info', \"--output\", \"json\", *args)\ndef qemu_img_map(*args: str) -> Any:\n    return qemu_img_json('map', \"--output\", \"json\", *args)\ndef qemu_img_log(*args: str, check: bool = True\n                 ) -> 'subprocess.CompletedProcess[str]':\n    result = qemu_img(*args, check=check)\n    log(result.stdout, filters=[filter_testfiles])\n    return result\ndef img_info_log(filename: str, filter_path: Optional[str] = None,",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_map",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_map(*args: str) -> Any:\n    return qemu_img_json('map', \"--output\", \"json\", *args)\ndef qemu_img_log(*args: str, check: bool = True\n                 ) -> 'subprocess.CompletedProcess[str]':\n    result = qemu_img(*args, check=check)\n    log(result.stdout, filters=[filter_testfiles])\n    return result\ndef img_info_log(filename: str, filter_path: Optional[str] = None,\n                 use_image_opts: bool = False, extra_args: Sequence[str] = (),\n                 check: bool = True, drop_child_info: bool = True,",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_log",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_img_log(*args: str, check: bool = True\n                 ) -> 'subprocess.CompletedProcess[str]':\n    result = qemu_img(*args, check=check)\n    log(result.stdout, filters=[filter_testfiles])\n    return result\ndef img_info_log(filename: str, filter_path: Optional[str] = None,\n                 use_image_opts: bool = False, extra_args: Sequence[str] = (),\n                 check: bool = True, drop_child_info: bool = True,\n                 ) -> None:\n    args = ['info']",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "img_info_log",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def img_info_log(filename: str, filter_path: Optional[str] = None,\n                 use_image_opts: bool = False, extra_args: Sequence[str] = (),\n                 check: bool = True, drop_child_info: bool = True,\n                 ) -> None:\n    args = ['info']\n    if use_image_opts:\n        args.append('--image-opts')\n    else:\n        args += ['-f', imgfmt]\n    args += extra_args",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_io_wrap_args",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_io_wrap_args(args: Sequence[str]) -> List[str]:\n    if '-f' in args or '--image-opts' in args:\n        return qemu_io_args_no_fmt + list(args)\n    else:\n        return qemu_io_args + list(args)\ndef qemu_io_popen(*args):\n    return qemu_tool_popen(qemu_io_wrap_args(args))\ndef qemu_io(*args: str, check: bool = True, combine_stdio: bool = True\n            ) -> 'subprocess.CompletedProcess[str]':\n    \"\"\"",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_io_popen",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_io_popen(*args):\n    return qemu_tool_popen(qemu_io_wrap_args(args))\ndef qemu_io(*args: str, check: bool = True, combine_stdio: bool = True\n            ) -> 'subprocess.CompletedProcess[str]':\n    \"\"\"\n    Run QEMU_IO_PROG and return the status code and console output.\n    This function always prepends either QEMU_IO_OPTIONS or\n    QEMU_IO_OPTIONS_NO_FMT.\n    \"\"\"\n    return qemu_tool(*qemu_io_wrap_args(args),",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_io",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_io(*args: str, check: bool = True, combine_stdio: bool = True\n            ) -> 'subprocess.CompletedProcess[str]':\n    \"\"\"\n    Run QEMU_IO_PROG and return the status code and console output.\n    This function always prepends either QEMU_IO_OPTIONS or\n    QEMU_IO_OPTIONS_NO_FMT.\n    \"\"\"\n    return qemu_tool(*qemu_io_wrap_args(args),\n                     check=check, combine_stdio=combine_stdio)\ndef qemu_io_log(*args: str, check: bool = True",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_io_log",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_io_log(*args: str, check: bool = True\n                ) -> 'subprocess.CompletedProcess[str]':\n    result = qemu_io(*args, check=check)\n    log(result.stdout, filters=[filter_testfiles, filter_qemu_io])\n    return result\nclass QemuIoInteractive:\n    def __init__(self, *args):\n        self.args = qemu_io_wrap_args(args)\n        # We need to keep the Popen objext around, and not\n        # close it immediately. Therefore, disable the pylint check:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_nbd",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_nbd(*args):\n    '''Run qemu-nbd in daemon mode and return the parent's exit code'''\n    return subprocess.call(qemu_nbd_args + ['--fork'] + list(args))\ndef qemu_nbd_early_pipe(*args: str) -> Tuple[int, str]:\n    '''Run qemu-nbd in daemon mode and return both the parent's exit code\n       and its output in case of an error'''\n    full_args = qemu_nbd_args + ['--fork'] + list(args)\n    output, returncode = qemu_tool_pipe_and_status('qemu-nbd', full_args,\n                                                   connect_stderr=False)\n    return returncode, output if returncode else ''",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_nbd_early_pipe",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_nbd_early_pipe(*args: str) -> Tuple[int, str]:\n    '''Run qemu-nbd in daemon mode and return both the parent's exit code\n       and its output in case of an error'''\n    full_args = qemu_nbd_args + ['--fork'] + list(args)\n    output, returncode = qemu_tool_pipe_and_status('qemu-nbd', full_args,\n                                                   connect_stderr=False)\n    return returncode, output if returncode else ''\ndef qemu_nbd_list_log(*args: str) -> str:\n    '''Run qemu-nbd to list remote exports'''\n    full_args = [qemu_nbd_prog, '-L'] + list(args)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_nbd_list_log",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_nbd_list_log(*args: str) -> str:\n    '''Run qemu-nbd to list remote exports'''\n    full_args = [qemu_nbd_prog, '-L'] + list(args)\n    output, _ = qemu_tool_pipe_and_status('qemu-nbd', full_args)\n    log(output, filters=[filter_testfiles, filter_nbd_exports])\n    return output\n@contextmanager\ndef qemu_nbd_popen(*args):\n    '''Context manager running qemu-nbd within the context'''\n    pid_file = file_path(\"qemu_nbd_popen-nbd-pid-file\")",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_nbd_popen",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_nbd_popen(*args):\n    '''Context manager running qemu-nbd within the context'''\n    pid_file = file_path(\"qemu_nbd_popen-nbd-pid-file\")\n    assert not os.path.exists(pid_file)\n    cmd = list(qemu_nbd_args)\n    cmd.extend(('--persistent', '--pid-file', pid_file))\n    cmd.extend(args)\n    log('Start NBD server')\n    with subprocess.Popen(cmd) as p:\n        try:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "compare_images",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def compare_images(img1: str, img2: str,\n                   fmt1: str = imgfmt, fmt2: str = imgfmt) -> bool:\n    \"\"\"\n    Compare two images with QEMU_IMG; return True if they are identical.\n    :raise CalledProcessError:\n        when qemu-img crashes or returns a status code of anything other\n        than 0 (identical) or 1 (different).\n    \"\"\"\n    try:\n        qemu_img('compare', '-f', fmt1, '-F', fmt2, img1, img2)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "create_image",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def create_image(name, size):\n    '''Create a fully-allocated raw image with sector markers'''\n    with open(name, 'wb') as file:\n        i = 0\n        while i < size:\n            sector = struct.pack('>l504xl', i // 512, i // 512)\n            file.write(sector)\n            i = i + 512\ndef image_size(img: str) -> int:\n    \"\"\"Return image's virtual size\"\"\"",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "image_size",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def image_size(img: str) -> int:\n    \"\"\"Return image's virtual size\"\"\"\n    value = qemu_img_info('-f', imgfmt, img)['virtual-size']\n    if not isinstance(value, int):\n        type_name = type(value).__name__\n        raise TypeError(\"Expected 'int' for 'virtual-size', \"\n                        f\"got '{value}' of type '{type_name}'\")\n    return value\ndef is_str(val):\n    return isinstance(val, str)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "is_str",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def is_str(val):\n    return isinstance(val, str)\ntest_dir_re = re.compile(r\"%s\" % test_dir)\ndef filter_test_dir(msg):\n    return test_dir_re.sub(\"TEST_DIR\", msg)\nwin32_re = re.compile(r\"\\r\")\ndef filter_win32(msg):\n    return win32_re.sub(\"\", msg)\nqemu_io_re = re.compile(r\"[0-9]* ops; [0-9\\/:. sec]* \"\n                        r\"\\([0-9\\/.inf]* [EPTGMKiBbytes]*\\/sec \"",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_test_dir",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_test_dir(msg):\n    return test_dir_re.sub(\"TEST_DIR\", msg)\nwin32_re = re.compile(r\"\\r\")\ndef filter_win32(msg):\n    return win32_re.sub(\"\", msg)\nqemu_io_re = re.compile(r\"[0-9]* ops; [0-9\\/:. sec]* \"\n                        r\"\\([0-9\\/.inf]* [EPTGMKiBbytes]*\\/sec \"\n                        r\"and [0-9\\/.inf]* ops\\/sec\\)\")\ndef filter_qemu_io(msg):\n    msg = filter_win32(msg)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_win32",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_win32(msg):\n    return win32_re.sub(\"\", msg)\nqemu_io_re = re.compile(r\"[0-9]* ops; [0-9\\/:. sec]* \"\n                        r\"\\([0-9\\/.inf]* [EPTGMKiBbytes]*\\/sec \"\n                        r\"and [0-9\\/.inf]* ops\\/sec\\)\")\ndef filter_qemu_io(msg):\n    msg = filter_win32(msg)\n    return qemu_io_re.sub(\"X ops; XX:XX:XX.X \"\n                          \"(XXX YYY/sec and XXX ops/sec)\", msg)\nchown_re = re.compile(r\"chown [0-9]+:[0-9]+\")",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qemu_io",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qemu_io(msg):\n    msg = filter_win32(msg)\n    return qemu_io_re.sub(\"X ops; XX:XX:XX.X \"\n                          \"(XXX YYY/sec and XXX ops/sec)\", msg)\nchown_re = re.compile(r\"chown [0-9]+:[0-9]+\")\ndef filter_chown(msg):\n    return chown_re.sub(\"chown UID:GID\", msg)\ndef filter_qmp_event(event):\n    '''Filter a QMP event dict'''\n    event = dict(event)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_chown",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_chown(msg):\n    return chown_re.sub(\"chown UID:GID\", msg)\ndef filter_qmp_event(event):\n    '''Filter a QMP event dict'''\n    event = dict(event)\n    if 'timestamp' in event:\n        event['timestamp']['seconds'] = 'SECS'\n        event['timestamp']['microseconds'] = 'USECS'\n    return event\ndef filter_qmp(qmsg, filter_fn):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qmp_event",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qmp_event(event):\n    '''Filter a QMP event dict'''\n    event = dict(event)\n    if 'timestamp' in event:\n        event['timestamp']['seconds'] = 'SECS'\n        event['timestamp']['microseconds'] = 'USECS'\n    return event\ndef filter_qmp(qmsg, filter_fn):\n    '''Given a string filter, filter a QMP object's values.\n    filter_fn takes a (key, value) pair.'''",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qmp",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qmp(qmsg, filter_fn):\n    '''Given a string filter, filter a QMP object's values.\n    filter_fn takes a (key, value) pair.'''\n    # Iterate through either lists or dicts;\n    if isinstance(qmsg, list):\n        items = enumerate(qmsg)\n    elif isinstance(qmsg, dict):\n        items = qmsg.items()\n    else:\n        return filter_fn(None, qmsg)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_testfiles",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_testfiles(msg):\n    pref1 = os.path.join(test_dir, \"%s-\" % (os.getpid()))\n    pref2 = os.path.join(sock_dir, \"%s-\" % (os.getpid()))\n    return msg.replace(pref1, 'TEST_DIR/PID-').replace(pref2, 'SOCK_DIR/PID-')\ndef filter_qmp_testfiles(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_testfiles(value)\n        return value\n    return filter_qmp(qmsg, _filter)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qmp_testfiles",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qmp_testfiles(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_testfiles(value)\n        return value\n    return filter_qmp(qmsg, _filter)\ndef filter_virtio_scsi(output: str) -> str:\n    return re.sub(r'(virtio-scsi)-(ccw|pci)', r'\\1', output)\ndef filter_qmp_virtio_scsi(qmsg):\n    def _filter(_key, value):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_virtio_scsi",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_virtio_scsi(output: str) -> str:\n    return re.sub(r'(virtio-scsi)-(ccw|pci)', r'\\1', output)\ndef filter_qmp_virtio_scsi(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_virtio_scsi(value)\n        return value\n    return filter_qmp(qmsg, _filter)\ndef filter_generated_node_ids(msg):\n    return re.sub(\"#block[0-9]+\", \"NODE_NAME\", msg)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qmp_virtio_scsi",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qmp_virtio_scsi(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_virtio_scsi(value)\n        return value\n    return filter_qmp(qmsg, _filter)\ndef filter_generated_node_ids(msg):\n    return re.sub(\"#block[0-9]+\", \"NODE_NAME\", msg)\ndef filter_qmp_generated_node_ids(qmsg):\n    def _filter(_key, value):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_generated_node_ids",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_generated_node_ids(msg):\n    return re.sub(\"#block[0-9]+\", \"NODE_NAME\", msg)\ndef filter_qmp_generated_node_ids(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_generated_node_ids(value)\n        return value\n    return filter_qmp(qmsg, _filter)\ndef filter_img_info(output: str, filename: str,\n                    drop_child_info: bool = True) -> str:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qmp_generated_node_ids",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qmp_generated_node_ids(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_generated_node_ids(value)\n        return value\n    return filter_qmp(qmsg, _filter)\ndef filter_img_info(output: str, filename: str,\n                    drop_child_info: bool = True) -> str:\n    lines = []\n    drop_indented = False",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_img_info",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_img_info(output: str, filename: str,\n                    drop_child_info: bool = True) -> str:\n    lines = []\n    drop_indented = False\n    for line in output.split('\\n'):\n        if 'disk size' in line or 'actual-size' in line:\n            continue\n        # Drop child node info\n        if drop_indented:\n            if line.startswith(' '):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_imgfmt",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_imgfmt(msg):\n    return msg.replace(imgfmt, 'IMGFMT')\ndef filter_qmp_imgfmt(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_imgfmt(value)\n        return value\n    return filter_qmp(qmsg, _filter)\ndef filter_nbd_exports(output: str) -> str:\n    return re.sub(r'((min|opt|max) block): [0-9]+', r'\\1: XXX', output)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qmp_imgfmt",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qmp_imgfmt(qmsg):\n    def _filter(_key, value):\n        if is_str(value):\n            return filter_imgfmt(value)\n        return value\n    return filter_qmp(qmsg, _filter)\ndef filter_nbd_exports(output: str) -> str:\n    return re.sub(r'((min|opt|max) block): [0-9]+', r'\\1: XXX', output)\ndef filter_qtest(output: str) -> str:\n    output = re.sub(r'^\\[I \\d+\\.\\d+\\] OPENED\\n', '', output)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_nbd_exports",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_nbd_exports(output: str) -> str:\n    return re.sub(r'((min|opt|max) block): [0-9]+', r'\\1: XXX', output)\ndef filter_qtest(output: str) -> str:\n    output = re.sub(r'^\\[I \\d+\\.\\d+\\] OPENED\\n', '', output)\n    output = re.sub(r'\\n?\\[I \\+\\d+\\.\\d+\\] CLOSED\\n?$', '', output)\n    return output\nMsg = TypeVar('Msg', Dict[str, Any], List[Any], str)\ndef log(msg: Msg,\n        filters: Iterable[Callable[[Msg], Msg]] = (),\n        indent: Optional[int] = None) -> None:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "filter_qtest",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def filter_qtest(output: str) -> str:\n    output = re.sub(r'^\\[I \\d+\\.\\d+\\] OPENED\\n', '', output)\n    output = re.sub(r'\\n?\\[I \\+\\d+\\.\\d+\\] CLOSED\\n?$', '', output)\n    return output\nMsg = TypeVar('Msg', Dict[str, Any], List[Any], str)\ndef log(msg: Msg,\n        filters: Iterable[Callable[[Msg], Msg]] = (),\n        indent: Optional[int] = None) -> None:\n    \"\"\"\n    Logs either a string message or a JSON serializable message (like QMP).",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def log(msg: Msg,\n        filters: Iterable[Callable[[Msg], Msg]] = (),\n        indent: Optional[int] = None) -> None:\n    \"\"\"\n    Logs either a string message or a JSON serializable message (like QMP).\n    If indent is provided, JSON serializable messages are pretty-printed.\n    \"\"\"\n    for flt in filters:\n        msg = flt(msg)\n    if isinstance(msg, (dict, list)):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "file_pattern",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def file_pattern(name):\n    return \"{0}-{1}\".format(os.getpid(), name)\nclass FilePath:\n    \"\"\"\n    Context manager generating multiple file names. The generated files are\n    removed when exiting the context.\n    Example usage:\n        with FilePath('a.img', 'b.img') as (img_a, img_b):\n            # Use img_a and img_b here...\n        # a.img and b.img are automatically removed here.",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "try_remove",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def try_remove(img):\n    try:\n        os.remove(img)\n    except OSError:\n        pass\ndef file_path_remover():\n    for path in reversed(file_path_remover.paths):\n        try_remove(path)\ndef file_path(*names, base_dir=test_dir):\n    ''' Another way to get auto-generated filename that cleans itself up.",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "file_path_remover",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def file_path_remover():\n    for path in reversed(file_path_remover.paths):\n        try_remove(path)\ndef file_path(*names, base_dir=test_dir):\n    ''' Another way to get auto-generated filename that cleans itself up.\n    Use is as simple as:\n    img_a, img_b = file_path('a.img', 'b.img')\n    sock = file_path('socket')\n    '''\n    if not hasattr(file_path_remover, 'paths'):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "file_path",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def file_path(*names, base_dir=test_dir):\n    ''' Another way to get auto-generated filename that cleans itself up.\n    Use is as simple as:\n    img_a, img_b = file_path('a.img', 'b.img')\n    sock = file_path('socket')\n    '''\n    if not hasattr(file_path_remover, 'paths'):\n        file_path_remover.paths = []\n        atexit.register(file_path_remover)\n    paths = []",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "remote_filename",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def remote_filename(path):\n    if imgproto == 'file':\n        return path\n    elif imgproto == 'ssh':\n        return \"ssh://%s@127.0.0.1:22%s\" % (os.environ.get('USER'), path)\n    else:\n        raise ValueError(\"Protocol %s not supported\" % (imgproto))\nclass VM(qtest.QEMUQtestMachine):\n    '''A QEMU VM'''\n    def __init__(self, path_suffix=''):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "notrun",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def notrun(reason):\n    '''Skip this test suite'''\n    # Each test in qemu-iotests has a number (\"seq\")\n    seq = os.path.basename(sys.argv[0])\n    with open('%s/%s.notrun' % (test_dir, seq), 'w', encoding='utf-8') \\\n            as outfile:\n        outfile.write(reason + '\\n')\n    logger.warning(\"%s not run: %s\", seq, reason)\n    sys.exit(0)\ndef case_notrun(reason):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "case_notrun",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def case_notrun(reason):\n    '''Mark this test case as not having been run (without actually\n    skipping it, that is left to the caller).  See\n    QMPTestCase.case_skip() for a variant that actually skips the\n    current test case.'''\n    # Each test in qemu-iotests has a number (\"seq\")\n    seq = os.path.basename(sys.argv[0])\n    with open('%s/%s.casenotrun' % (test_dir, seq), 'a', encoding='utf-8') \\\n            as outfile:\n        outfile.write('    [case not run] ' + reason + '\\n')",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "verify_virtio_scsi_pci_or_ccw",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def verify_virtio_scsi_pci_or_ccw() -> None:\n    out = qemu_pipe('-M', 'none', '-device', 'help')\n    if 'virtio-scsi-pci' not in out and 'virtio-scsi-ccw' not in out:\n        notrun('Missing virtio-scsi-pci or virtio-scsi-ccw in QEMU binary')\ndef _verify_imgopts(unsupported: Sequence[str] = ()) -> None:\n    imgopts = os.environ.get('IMGOPTS')\n    # One of usage examples for IMGOPTS is \"data_file=$TEST_IMG.ext_data_file\"\n    # but it supported only for bash tests. We don't have a concept of global\n    # TEST_IMG in iotests.py, not saying about somehow parsing $variables.\n    # So, for simplicity let's just not support any IMGOPTS with '$' inside.",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "supports_quorum",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def supports_quorum() -> bool:\n    return 'quorum' in qemu_img('--help').stdout\ndef verify_quorum():\n    '''Skip test suite if quorum support is not available'''\n    if not supports_quorum():\n        notrun('quorum support missing')\ndef has_working_luks() -> Tuple[bool, str]:\n    \"\"\"\n    Check whether our LUKS driver can actually create images\n    (this extends to LUKS encryption for qcow2).",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "verify_quorum",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def verify_quorum():\n    '''Skip test suite if quorum support is not available'''\n    if not supports_quorum():\n        notrun('quorum support missing')\ndef has_working_luks() -> Tuple[bool, str]:\n    \"\"\"\n    Check whether our LUKS driver can actually create images\n    (this extends to LUKS encryption for qcow2).\n    If not, return the reason why.\n    \"\"\"",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "has_working_luks",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def has_working_luks() -> Tuple[bool, str]:\n    \"\"\"\n    Check whether our LUKS driver can actually create images\n    (this extends to LUKS encryption for qcow2).\n    If not, return the reason why.\n    \"\"\"\n    img_file = f'{test_dir}/luks-test.luks'\n    res = qemu_img('create', '-f', 'luks',\n                   '--object', luks_default_secret_object,\n                   '-o', luks_default_key_secret_opt,",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "verify_working_luks",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def verify_working_luks():\n    \"\"\"\n    Skip test suite if LUKS does not work\n    \"\"\"\n    (working, reason) = has_working_luks()\n    if not working:\n        notrun(reason)\ndef supports_qcow2_zstd_compression() -> bool:\n    img_file = f'{test_dir}/qcow2-zstd-test.qcow2'\n    res = qemu_img('create', '-f', 'qcow2', '-o', 'compression_type=zstd',",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "supports_qcow2_zstd_compression",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def supports_qcow2_zstd_compression() -> bool:\n    img_file = f'{test_dir}/qcow2-zstd-test.qcow2'\n    res = qemu_img('create', '-f', 'qcow2', '-o', 'compression_type=zstd',\n                   img_file, '0',\n                   check=False)\n    try:\n        os.remove(img_file)\n    except OSError:\n        pass\n    if res.returncode == 1 and \\",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "verify_qcow2_zstd_compression",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def verify_qcow2_zstd_compression():\n    if not supports_qcow2_zstd_compression():\n        notrun('zstd compression not supported')\ndef qemu_pipe(*args: str) -> str:\n    \"\"\"\n    Run qemu with an option to print something and exit (e.g. a help option).\n    :return: QEMU's stdout output.\n    \"\"\"\n    full_args = [qemu_prog] + qemu_opts + list(args)\n    output, _ = qemu_tool_pipe_and_status('qemu', full_args)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_pipe",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def qemu_pipe(*args: str) -> str:\n    \"\"\"\n    Run qemu with an option to print something and exit (e.g. a help option).\n    :return: QEMU's stdout output.\n    \"\"\"\n    full_args = [qemu_prog] + qemu_opts + list(args)\n    output, _ = qemu_tool_pipe_and_status('qemu', full_args)\n    return output\ndef supported_formats(read_only=False):\n    '''Set 'read_only' to True to check ro-whitelist",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "supported_formats",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def supported_formats(read_only=False):\n    '''Set 'read_only' to True to check ro-whitelist\n       Otherwise, rw-whitelist is checked'''\n    if not hasattr(supported_formats, \"formats\"):\n        supported_formats.formats = {}\n    if read_only not in supported_formats.formats:\n        format_message = qemu_pipe(\"-drive\", \"format=help\")\n        line = 1 if read_only else 0\n        supported_formats.formats[read_only] = \\\n            format_message.splitlines()[line].split(\":\")[1].split()",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "skip_if_unsupported",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def skip_if_unsupported(required_formats=(), read_only=False):\n    '''Skip Test Decorator\n       Runs the test if all the required formats are whitelisted'''\n    def skip_test_decorator(func):\n        def func_wrapper(test_case: QMPTestCase, *args: List[Any],\n                         **kwargs: Dict[str, Any]) -> None:\n            if callable(required_formats):\n                fmts = required_formats(test_case)\n            else:\n                fmts = required_formats",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "skip_for_formats",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def skip_for_formats(formats: Sequence[str] = ()) \\\n    -> Callable[[Callable[[QMPTestCase, List[Any], Dict[str, Any]], None]],\n                Callable[[QMPTestCase, List[Any], Dict[str, Any]], None]]:\n    '''Skip Test Decorator\n       Skips the test for the given formats'''\n    def skip_test_decorator(func):\n        def func_wrapper(test_case: QMPTestCase, *args: List[Any],\n                         **kwargs: Dict[str, Any]) -> None:\n            if imgfmt in formats:\n                msg = f'{test_case}: Skipped for format {imgfmt}'",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "skip_if_user_is_root",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def skip_if_user_is_root(func):\n    '''Skip Test Decorator\n       Runs the test only without root permissions'''\n    def func_wrapper(*args, **kwargs):\n        if os.getuid() == 0:\n            case_notrun('{}: cannot be run as root'.format(args[0]))\n            return None\n        else:\n            return func(*args, **kwargs)\n    return func_wrapper",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "execute_unittest",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def execute_unittest(argv: List[str], debug: bool = False) -> None:\n    \"\"\"Executes unittests within the calling module.\"\"\"\n    # Some tests have warnings, especially ResourceWarnings for unclosed\n    # files and sockets.  Ignore them for now to ensure reproducibility of\n    # the test output.\n    unittest.main(argv=argv,\n                  testRunner=ReproducibleTestRunner,\n                  verbosity=2 if debug else 1,\n                  warnings=None if sys.warnoptions else 'ignore')\ndef execute_setup_common(supported_fmts: Sequence[str] = (),",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "execute_setup_common",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def execute_setup_common(supported_fmts: Sequence[str] = (),\n                         supported_platforms: Sequence[str] = (),\n                         supported_cache_modes: Sequence[str] = (),\n                         supported_aio_modes: Sequence[str] = (),\n                         unsupported_fmts: Sequence[str] = (),\n                         supported_protocols: Sequence[str] = (),\n                         unsupported_protocols: Sequence[str] = (),\n                         required_fmts: Sequence[str] = (),\n                         unsupported_imgopts: Sequence[str] = ()) -> bool:\n    \"\"\"",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "execute_test",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def execute_test(*args, test_function=None, **kwargs):\n    \"\"\"Run either unittest or script-style tests.\"\"\"\n    debug = execute_setup_common(*args, **kwargs)\n    if not test_function:\n        execute_unittest(sys.argv, debug)\n    else:\n        test_function()\ndef activate_logging():\n    \"\"\"Activate iotests.log() output to stdout for script-style tests.\"\"\"\n    handler = logging.StreamHandler(stream=sys.stdout)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "activate_logging",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def activate_logging():\n    \"\"\"Activate iotests.log() output to stdout for script-style tests.\"\"\"\n    handler = logging.StreamHandler(stream=sys.stdout)\n    formatter = logging.Formatter('%(message)s')\n    handler.setFormatter(formatter)\n    test_logger.addHandler(handler)\n    test_logger.setLevel(logging.INFO)\n    test_logger.propagate = False\n# This is called from script-style iotests without a single point of entry\ndef script_initialize(*args, **kwargs):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "script_initialize",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def script_initialize(*args, **kwargs):\n    \"\"\"Initialize script-style tests without running any tests.\"\"\"\n    activate_logging()\n    execute_setup_common(*args, **kwargs)\n# This is called from script-style iotests with a single point of entry\ndef script_main(test_function, *args, **kwargs):\n    \"\"\"Run script-style tests outside of the unittest framework\"\"\"\n    activate_logging()\n    execute_test(*args, test_function=test_function, **kwargs)\n# This is called from unittest style iotests",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "script_main",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def script_main(test_function, *args, **kwargs):\n    \"\"\"Run script-style tests outside of the unittest framework\"\"\"\n    activate_logging()\n    execute_test(*args, test_function=test_function, **kwargs)\n# This is called from unittest style iotests\ndef main(*args, **kwargs):\n    \"\"\"Run tests using the unittest framework\"\"\"\n    execute_test(*args, **kwargs)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "def main(*args, **kwargs):\n    \"\"\"Run tests using the unittest framework\"\"\"\n    execute_test(*args, **kwargs)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "logger = logging.getLogger('qemu.iotests')\nlogger.addHandler(logging.NullHandler())\n# Use this logger for messages that ought to be used for diff output.\ntest_logger = logging.getLogger('qemu.iotests.diff_io')\nfaulthandler.enable()\n# This will not work if arguments contain spaces but is necessary if we\n# want to support the override options that ./check supports.\nqemu_img_args = [os.environ.get('QEMU_IMG_PROG', 'qemu-img')]\nif os.environ.get('QEMU_IMG_OPTIONS'):\n    qemu_img_args += os.environ['QEMU_IMG_OPTIONS'].strip().split(' ')",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "test_logger",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "test_logger = logging.getLogger('qemu.iotests.diff_io')\nfaulthandler.enable()\n# This will not work if arguments contain spaces but is necessary if we\n# want to support the override options that ./check supports.\nqemu_img_args = [os.environ.get('QEMU_IMG_PROG', 'qemu-img')]\nif os.environ.get('QEMU_IMG_OPTIONS'):\n    qemu_img_args += os.environ['QEMU_IMG_OPTIONS'].strip().split(' ')\nqemu_io_args = [os.environ.get('QEMU_IO_PROG', 'qemu-io')]\nif os.environ.get('QEMU_IO_OPTIONS'):\n    qemu_io_args += os.environ['QEMU_IO_OPTIONS'].strip().split(' ')",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_img_args",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_img_args = [os.environ.get('QEMU_IMG_PROG', 'qemu-img')]\nif os.environ.get('QEMU_IMG_OPTIONS'):\n    qemu_img_args += os.environ['QEMU_IMG_OPTIONS'].strip().split(' ')\nqemu_io_args = [os.environ.get('QEMU_IO_PROG', 'qemu-io')]\nif os.environ.get('QEMU_IO_OPTIONS'):\n    qemu_io_args += os.environ['QEMU_IO_OPTIONS'].strip().split(' ')\nqemu_io_args_no_fmt = [os.environ.get('QEMU_IO_PROG', 'qemu-io')]\nif os.environ.get('QEMU_IO_OPTIONS_NO_FMT'):\n    qemu_io_args_no_fmt += \\\n        os.environ['QEMU_IO_OPTIONS_NO_FMT'].strip().split(' ')",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_io_args",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_io_args = [os.environ.get('QEMU_IO_PROG', 'qemu-io')]\nif os.environ.get('QEMU_IO_OPTIONS'):\n    qemu_io_args += os.environ['QEMU_IO_OPTIONS'].strip().split(' ')\nqemu_io_args_no_fmt = [os.environ.get('QEMU_IO_PROG', 'qemu-io')]\nif os.environ.get('QEMU_IO_OPTIONS_NO_FMT'):\n    qemu_io_args_no_fmt += \\\n        os.environ['QEMU_IO_OPTIONS_NO_FMT'].strip().split(' ')\nqemu_nbd_prog = os.environ.get('QEMU_NBD_PROG', 'qemu-nbd')\nqemu_nbd_args = [qemu_nbd_prog]\nif os.environ.get('QEMU_NBD_OPTIONS'):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_io_args_no_fmt",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_io_args_no_fmt = [os.environ.get('QEMU_IO_PROG', 'qemu-io')]\nif os.environ.get('QEMU_IO_OPTIONS_NO_FMT'):\n    qemu_io_args_no_fmt += \\\n        os.environ['QEMU_IO_OPTIONS_NO_FMT'].strip().split(' ')\nqemu_nbd_prog = os.environ.get('QEMU_NBD_PROG', 'qemu-nbd')\nqemu_nbd_args = [qemu_nbd_prog]\nif os.environ.get('QEMU_NBD_OPTIONS'):\n    qemu_nbd_args += os.environ['QEMU_NBD_OPTIONS'].strip().split(' ')\nqemu_prog = os.environ.get('QEMU_PROG', 'qemu')\nqemu_opts = os.environ.get('QEMU_OPTIONS', '').strip().split(' ')",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_nbd_prog",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_nbd_prog = os.environ.get('QEMU_NBD_PROG', 'qemu-nbd')\nqemu_nbd_args = [qemu_nbd_prog]\nif os.environ.get('QEMU_NBD_OPTIONS'):\n    qemu_nbd_args += os.environ['QEMU_NBD_OPTIONS'].strip().split(' ')\nqemu_prog = os.environ.get('QEMU_PROG', 'qemu')\nqemu_opts = os.environ.get('QEMU_OPTIONS', '').strip().split(' ')\nqsd_prog = os.environ.get('QSD_PROG', 'qemu-storage-daemon')\ngdb_qemu_env = os.environ.get('GDB_OPTIONS')\nqemu_gdb = []\nif gdb_qemu_env:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_nbd_args",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_nbd_args = [qemu_nbd_prog]\nif os.environ.get('QEMU_NBD_OPTIONS'):\n    qemu_nbd_args += os.environ['QEMU_NBD_OPTIONS'].strip().split(' ')\nqemu_prog = os.environ.get('QEMU_PROG', 'qemu')\nqemu_opts = os.environ.get('QEMU_OPTIONS', '').strip().split(' ')\nqsd_prog = os.environ.get('QSD_PROG', 'qemu-storage-daemon')\ngdb_qemu_env = os.environ.get('GDB_OPTIONS')\nqemu_gdb = []\nif gdb_qemu_env:\n    qemu_gdb = ['gdbserver'] + gdb_qemu_env.strip().split(' ')",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_prog",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_prog = os.environ.get('QEMU_PROG', 'qemu')\nqemu_opts = os.environ.get('QEMU_OPTIONS', '').strip().split(' ')\nqsd_prog = os.environ.get('QSD_PROG', 'qemu-storage-daemon')\ngdb_qemu_env = os.environ.get('GDB_OPTIONS')\nqemu_gdb = []\nif gdb_qemu_env:\n    qemu_gdb = ['gdbserver'] + gdb_qemu_env.strip().split(' ')\nqemu_print = os.environ.get('PRINT_QEMU', False)\nimgfmt = os.environ.get('IMGFMT', 'raw')\nimgproto = os.environ.get('IMGPROTO', 'file')",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_opts",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_opts = os.environ.get('QEMU_OPTIONS', '').strip().split(' ')\nqsd_prog = os.environ.get('QSD_PROG', 'qemu-storage-daemon')\ngdb_qemu_env = os.environ.get('GDB_OPTIONS')\nqemu_gdb = []\nif gdb_qemu_env:\n    qemu_gdb = ['gdbserver'] + gdb_qemu_env.strip().split(' ')\nqemu_print = os.environ.get('PRINT_QEMU', False)\nimgfmt = os.environ.get('IMGFMT', 'raw')\nimgproto = os.environ.get('IMGPROTO', 'file')\ntry:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qsd_prog",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qsd_prog = os.environ.get('QSD_PROG', 'qemu-storage-daemon')\ngdb_qemu_env = os.environ.get('GDB_OPTIONS')\nqemu_gdb = []\nif gdb_qemu_env:\n    qemu_gdb = ['gdbserver'] + gdb_qemu_env.strip().split(' ')\nqemu_print = os.environ.get('PRINT_QEMU', False)\nimgfmt = os.environ.get('IMGFMT', 'raw')\nimgproto = os.environ.get('IMGPROTO', 'file')\ntry:\n    test_dir = os.environ['TEST_DIR']",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "gdb_qemu_env",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "gdb_qemu_env = os.environ.get('GDB_OPTIONS')\nqemu_gdb = []\nif gdb_qemu_env:\n    qemu_gdb = ['gdbserver'] + gdb_qemu_env.strip().split(' ')\nqemu_print = os.environ.get('PRINT_QEMU', False)\nimgfmt = os.environ.get('IMGFMT', 'raw')\nimgproto = os.environ.get('IMGPROTO', 'file')\ntry:\n    test_dir = os.environ['TEST_DIR']\n    sock_dir = os.environ['SOCK_DIR']",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_gdb",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_gdb = []\nif gdb_qemu_env:\n    qemu_gdb = ['gdbserver'] + gdb_qemu_env.strip().split(' ')\nqemu_print = os.environ.get('PRINT_QEMU', False)\nimgfmt = os.environ.get('IMGFMT', 'raw')\nimgproto = os.environ.get('IMGPROTO', 'file')\ntry:\n    test_dir = os.environ['TEST_DIR']\n    sock_dir = os.environ['SOCK_DIR']\n    cachemode = os.environ['CACHEMODE']",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_print",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_print = os.environ.get('PRINT_QEMU', False)\nimgfmt = os.environ.get('IMGFMT', 'raw')\nimgproto = os.environ.get('IMGPROTO', 'file')\ntry:\n    test_dir = os.environ['TEST_DIR']\n    sock_dir = os.environ['SOCK_DIR']\n    cachemode = os.environ['CACHEMODE']\n    aiomode = os.environ['AIOMODE']\n    qemu_default_machine = os.environ['QEMU_DEFAULT_MACHINE']\nexcept KeyError:",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "imgfmt",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "imgfmt = os.environ.get('IMGFMT', 'raw')\nimgproto = os.environ.get('IMGPROTO', 'file')\ntry:\n    test_dir = os.environ['TEST_DIR']\n    sock_dir = os.environ['SOCK_DIR']\n    cachemode = os.environ['CACHEMODE']\n    aiomode = os.environ['AIOMODE']\n    qemu_default_machine = os.environ['QEMU_DEFAULT_MACHINE']\nexcept KeyError:\n    # We are using these variables as proxies to indicate that we're",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "imgproto",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "imgproto = os.environ.get('IMGPROTO', 'file')\ntry:\n    test_dir = os.environ['TEST_DIR']\n    sock_dir = os.environ['SOCK_DIR']\n    cachemode = os.environ['CACHEMODE']\n    aiomode = os.environ['AIOMODE']\n    qemu_default_machine = os.environ['QEMU_DEFAULT_MACHINE']\nexcept KeyError:\n    # We are using these variables as proxies to indicate that we're\n    # not being run via \"check\". There may be other things set up by",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_valgrind",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_valgrind = []\nif os.environ.get('VALGRIND_QEMU') == \"y\" and \\\n    os.environ.get('NO_VALGRIND') != \"y\":\n    valgrind_logfile = \"--log-file=\" + test_dir\n    # %p allows to put the valgrind process PID, since\n    # we don't know it a priori (subprocess.Popen is\n    # not yet invoked)\n    valgrind_logfile += \"/%p.valgrind\"\n    qemu_valgrind = ['valgrind', valgrind_logfile, '--error-exitcode=99']\nluks_default_secret_object = 'secret,id=keysec0,data=' + \\",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "luks_default_secret_object",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "luks_default_secret_object = 'secret,id=keysec0,data=' + \\\n                             os.environ.get('IMGKEYSECRET', '')\nluks_default_key_secret_opt = 'key-secret=keysec0'\nsample_img_dir = os.environ['SAMPLE_IMG_DIR']\n@contextmanager\ndef change_log_level(\n        logger_name: str, level: int = logging.CRITICAL) -> Iterator[None]:\n    \"\"\"\n    Utility function for temporarily changing the log level of a logger.\n    This can be used to silence errors that are expected or uninteresting.",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "luks_default_key_secret_opt",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "luks_default_key_secret_opt = 'key-secret=keysec0'\nsample_img_dir = os.environ['SAMPLE_IMG_DIR']\n@contextmanager\ndef change_log_level(\n        logger_name: str, level: int = logging.CRITICAL) -> Iterator[None]:\n    \"\"\"\n    Utility function for temporarily changing the log level of a logger.\n    This can be used to silence errors that are expected or uninteresting.\n    \"\"\"\n    _logger = logging.getLogger(logger_name)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "sample_img_dir",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "sample_img_dir = os.environ['SAMPLE_IMG_DIR']\n@contextmanager\ndef change_log_level(\n        logger_name: str, level: int = logging.CRITICAL) -> Iterator[None]:\n    \"\"\"\n    Utility function for temporarily changing the log level of a logger.\n    This can be used to silence errors that are expected or uninteresting.\n    \"\"\"\n    _logger = logging.getLogger(logger_name)\n    current_level = _logger.level",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "test_dir_re",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "test_dir_re = re.compile(r\"%s\" % test_dir)\ndef filter_test_dir(msg):\n    return test_dir_re.sub(\"TEST_DIR\", msg)\nwin32_re = re.compile(r\"\\r\")\ndef filter_win32(msg):\n    return win32_re.sub(\"\", msg)\nqemu_io_re = re.compile(r\"[0-9]* ops; [0-9\\/:. sec]* \"\n                        r\"\\([0-9\\/.inf]* [EPTGMKiBbytes]*\\/sec \"\n                        r\"and [0-9\\/.inf]* ops\\/sec\\)\")\ndef filter_qemu_io(msg):",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "win32_re",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "win32_re = re.compile(r\"\\r\")\ndef filter_win32(msg):\n    return win32_re.sub(\"\", msg)\nqemu_io_re = re.compile(r\"[0-9]* ops; [0-9\\/:. sec]* \"\n                        r\"\\([0-9\\/.inf]* [EPTGMKiBbytes]*\\/sec \"\n                        r\"and [0-9\\/.inf]* ops\\/sec\\)\")\ndef filter_qemu_io(msg):\n    msg = filter_win32(msg)\n    return qemu_io_re.sub(\"X ops; XX:XX:XX.X \"\n                          \"(XXX YYY/sec and XXX ops/sec)\", msg)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "qemu_io_re",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "qemu_io_re = re.compile(r\"[0-9]* ops; [0-9\\/:. sec]* \"\n                        r\"\\([0-9\\/.inf]* [EPTGMKiBbytes]*\\/sec \"\n                        r\"and [0-9\\/.inf]* ops\\/sec\\)\")\ndef filter_qemu_io(msg):\n    msg = filter_win32(msg)\n    return qemu_io_re.sub(\"X ops; XX:XX:XX.X \"\n                          \"(XXX YYY/sec and XXX ops/sec)\", msg)\nchown_re = re.compile(r\"chown [0-9]+:[0-9]+\")\ndef filter_chown(msg):\n    return chown_re.sub(\"chown UID:GID\", msg)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "chown_re",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "chown_re = re.compile(r\"chown [0-9]+:[0-9]+\")\ndef filter_chown(msg):\n    return chown_re.sub(\"chown UID:GID\", msg)\ndef filter_qmp_event(event):\n    '''Filter a QMP event dict'''\n    event = dict(event)\n    if 'timestamp' in event:\n        event['timestamp']['seconds'] = 'SECS'\n        event['timestamp']['microseconds'] = 'USECS'\n    return event",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "Msg",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "Msg = TypeVar('Msg', Dict[str, Any], List[Any], str)\ndef log(msg: Msg,\n        filters: Iterable[Callable[[Msg], Msg]] = (),\n        indent: Optional[int] = None) -> None:\n    \"\"\"\n    Logs either a string message or a JSON serializable message (like QMP).\n    If indent is provided, JSON serializable messages are pretty-printed.\n    \"\"\"\n    for flt in filters:\n        msg = flt(msg)",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "index_re",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.iotests",
        "description": "qemu.tests.qemu-iotests.iotests",
        "peekOfCode": "index_re = re.compile(r'([^\\[]+)\\[([^\\]]+)\\]')\nclass QMPTestCase(unittest.TestCase):\n    '''Abstract base class for QMP test cases'''\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Many users of this class set a VM property we rely on heavily\n        # in the methods below.\n        self.vm = None\n    def dictpath(self, d, path):\n        '''Traverse a path in a nested dict'''",
        "detail": "qemu.tests.qemu-iotests.iotests",
        "documentation": {}
    },
    {
        "label": "is_python_file",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.linters",
        "description": "qemu.tests.qemu-iotests.linters",
        "peekOfCode": "def is_python_file(filename):\n    if not os.path.isfile(filename):\n        return False\n    if filename.endswith('.py'):\n        return True\n    with open(filename, encoding='utf-8') as f:\n        try:\n            first_line = f.readline()\n            return re.match('^#!.*python', first_line) is not None\n        except UnicodeDecodeError:  # Ignore binary files",
        "detail": "qemu.tests.qemu-iotests.linters",
        "documentation": {}
    },
    {
        "label": "get_test_files",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.linters",
        "description": "qemu.tests.qemu-iotests.linters",
        "peekOfCode": "def get_test_files() -> List[str]:\n    named_tests = [f'tests/{entry}' for entry in os.listdir('tests')]\n    check_tests = set(os.listdir('.') + named_tests) - set(SKIP_FILES)\n    return list(filter(is_python_file, check_tests))\ndef run_linter(\n        tool: str,\n        args: List[str],\n        env: Optional[Mapping[str, str]] = None,\n        suppress_output: bool = False,\n) -> None:",
        "detail": "qemu.tests.qemu-iotests.linters",
        "documentation": {}
    },
    {
        "label": "run_linter",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.linters",
        "description": "qemu.tests.qemu-iotests.linters",
        "peekOfCode": "def run_linter(\n        tool: str,\n        args: List[str],\n        env: Optional[Mapping[str, str]] = None,\n        suppress_output: bool = False,\n) -> None:\n    \"\"\"\n    Run a python-based linting tool.\n    :param suppress_output: If True, suppress all stdout/stderr output.\n    :raise CalledProcessError: If the linter process exits with failure.",
        "detail": "qemu.tests.qemu-iotests.linters",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.linters",
        "description": "qemu.tests.qemu-iotests.linters",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    Used by the Python CI system as an entry point to run these linters.\n    \"\"\"\n    def show_usage() -> None:\n        print(f\"Usage: {sys.argv[0]} < --mypy | --pylint >\", file=sys.stderr)\n        sys.exit(1)\n    if len(sys.argv) != 2:\n        show_usage()\n    files = get_test_files()",
        "detail": "qemu.tests.qemu-iotests.linters",
        "documentation": {}
    },
    {
        "label": "SKIP_FILES",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.linters",
        "description": "qemu.tests.qemu-iotests.linters",
        "peekOfCode": "SKIP_FILES = (\n    '030', '040', '041', '044', '045', '055', '056', '057', '065', '093',\n    '096', '118', '124', '132', '136', '139', '147', '148', '149',\n    '151', '152', '155', '163', '165', '194', '196', '202',\n    '203', '205', '206', '207', '208', '210', '211', '212', '213', '216',\n    '218', '219', '224', '228', '234', '235', '236', '237', '238',\n    '240', '242', '245', '246', '248', '255', '256', '257', '258', '260',\n    '262', '264', '266', '274', '277', '280', '281', '295', '296', '298',\n    '299', '302', '303', '304', '307',\n    'nbd-fault-injector.py', 'qcow2.py', 'qcow2_format.py', 'qed.py'",
        "detail": "qemu.tests.qemu-iotests.linters",
        "documentation": {}
    },
    {
        "label": "Rule",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "class Rule(object):\n    def __init__(self, name, event, io, when):\n        self.name = name\n        self.event = event\n        self.io = io\n        self.when = when\n    def match(self, event, io):\n        if event != self.event:\n            return False\n        if io != self.io and self.io != 'readwrite':",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "FaultInjectionSocket",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "class FaultInjectionSocket(object):\n    def __init__(self, sock, rules):\n        self.sock = sock\n        self.rules = rules\n    def check(self, event, io, bufsize=None):\n        for rule in self.rules:\n            if rule.match(event, io):\n                if rule.when == 0 or bufsize is None:\n                    print('Closing connection on rule match %s' % rule.name)\n                    self.sock.close()",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "err",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef recvall(sock, bufsize):\n    received = 0\n    chunks = []\n    while received < bufsize:\n        chunk = sock.recv(bufsize - received)\n        if len(chunk) == 0:\n            raise Exception('unexpected disconnect')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "recvall",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def recvall(sock, bufsize):\n    received = 0\n    chunks = []\n    while received < bufsize:\n        chunk = sock.recv(bufsize - received)\n        if len(chunk) == 0:\n            raise Exception('unexpected disconnect')\n        chunks.append(chunk)\n        received += len(chunk)\n    return b''.join(chunks)",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "negotiate_classic",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def negotiate_classic(conn):\n    buf = neg_classic_struct.pack(NBD_PASSWD, NBD_CLIENT_MAGIC,\n                                  FAKE_DISK_SIZE, 0)\n    conn.send(buf, event='neg-classic')\ndef negotiate_export(conn):\n    # Send negotiation part 1\n    buf = neg1_struct.pack(NBD_PASSWD, NBD_OPTS_MAGIC, 0)\n    conn.send(buf, event='neg1')\n    # Receive export option\n    buf = conn.recv(export_struct.size, event='export')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "negotiate_export",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def negotiate_export(conn):\n    # Send negotiation part 1\n    buf = neg1_struct.pack(NBD_PASSWD, NBD_OPTS_MAGIC, 0)\n    conn.send(buf, event='neg1')\n    # Receive export option\n    buf = conn.recv(export_struct.size, event='export')\n    export = export_tuple._make(export_struct.unpack(buf))\n    assert export.magic == NBD_OPTS_MAGIC\n    assert export.opt == NBD_OPT_EXPORT_NAME\n    name = conn.recv(export.len, event='export-name')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "negotiate",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def negotiate(conn, use_export):\n    '''Negotiate export with client'''\n    if use_export:\n        negotiate_export(conn)\n    else:\n        negotiate_classic(conn)\ndef read_request(conn):\n    '''Parse NBD request from client'''\n    buf = conn.recv(request_struct.size, event='request')\n    req = request_tuple._make(request_struct.unpack(buf))",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "read_request",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def read_request(conn):\n    '''Parse NBD request from client'''\n    buf = conn.recv(request_struct.size, event='request')\n    req = request_tuple._make(request_struct.unpack(buf))\n    assert req.magic == NBD_REQUEST_MAGIC\n    return req\ndef write_reply(conn, error, handle):\n    buf = reply_struct.pack(NBD_SIMPLE_REPLY_MAGIC, error, handle)\n    conn.send(buf, event='reply')\ndef handle_connection(conn, use_export):",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "write_reply",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def write_reply(conn, error, handle):\n    buf = reply_struct.pack(NBD_SIMPLE_REPLY_MAGIC, error, handle)\n    conn.send(buf, event='reply')\ndef handle_connection(conn, use_export):\n    negotiate(conn, use_export)\n    while True:\n        req = read_request(conn)\n        if req.type == NBD_CMD_READ:\n            write_reply(conn, 0, req.handle)\n            conn.send(b'\\0' * req.len, event='data')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "handle_connection",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def handle_connection(conn, use_export):\n    negotiate(conn, use_export)\n    while True:\n        req = read_request(conn)\n        if req.type == NBD_CMD_READ:\n            write_reply(conn, 0, req.handle)\n            conn.send(b'\\0' * req.len, event='data')\n        elif req.type == NBD_CMD_WRITE:\n            _ = conn.recv(req.len, event='data')\n            write_reply(conn, 0, req.handle)",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "run_server",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def run_server(sock, rules, use_export):\n    while True:\n        conn, _ = sock.accept()\n        handle_connection(FaultInjectionSocket(conn, rules), use_export)\ndef parse_inject_error(name, options):\n    if 'event' not in options:\n        err('missing \\\"event\\\" option in %s' % name)\n    event = options['event']\n    if event not in ('neg-classic', 'neg1', 'export', 'neg2', 'request', 'reply', 'data'):\n        err('invalid \\\"event\\\" option value \\\"%s\\\" in %s' % (event, name))",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "parse_inject_error",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def parse_inject_error(name, options):\n    if 'event' not in options:\n        err('missing \\\"event\\\" option in %s' % name)\n    event = options['event']\n    if event not in ('neg-classic', 'neg1', 'export', 'neg2', 'request', 'reply', 'data'):\n        err('invalid \\\"event\\\" option value \\\"%s\\\" in %s' % (event, name))\n    io = options.get('io', 'readwrite')\n    if io not in ('read', 'write', 'readwrite'):\n        err('invalid \\\"io\\\" option value \\\"%s\\\" in %s' % (io, name))\n    when = options.get('when', 'before')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "parse_config",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def parse_config(config):\n    rules = []\n    for name in config.sections():\n        if name.startswith('inject-error'):\n            options = dict(config.items(name))\n            rules.append(parse_inject_error(name, options))\n        else:\n            err('invalid config section name: %s' % name)\n    return rules\ndef load_rules(filename):",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "load_rules",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def load_rules(filename):\n    config = configparser.RawConfigParser()\n    with open(filename, 'rt') as f:\n        config.read_file(f, filename)\n    return parse_config(config)\ndef open_socket(path):\n    '''Open a TCP or UNIX domain listen socket'''\n    if ':' in path:\n        host, port = path.split(':', 1)\n        sock = socket.socket()",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "open_socket",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def open_socket(path):\n    '''Open a TCP or UNIX domain listen socket'''\n    if ':' in path:\n        host, port = path.split(':', 1)\n        sock = socket.socket()\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind((host, int(port)))\n        # If given port was 0 the final port number is now available\n        path = '%s:%d' % sock.getsockname()\n    else:",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def usage(args):\n    sys.stderr.write('usage: %s [--classic-negotiation] <tcp-port>|<unix-path> <config-file>\\n' % args[0])\n    sys.stderr.write('Run an fault injector NBD server with rules defined in a config file.\\n')\n    sys.exit(1)\ndef main(args):\n    if len(args) != 3 and len(args) != 4:\n        usage(args)\n    use_export = True\n    if args[1] == '--classic-negotiation':\n        use_export = False",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "def main(args):\n    if len(args) != 3 and len(args) != 4:\n        usage(args)\n    use_export = True\n    if args[1] == '--classic-negotiation':\n        use_export = False\n    elif len(args) == 4:\n        usage(args)\n    sock = open_socket(args[1 if use_export else 2])\n    rules = load_rules(args[2 if use_export else 3])",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "FAKE_DISK_SIZE",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "FAKE_DISK_SIZE = 8 * 1024 * 1024 * 1024 # 8 GB\n# Protocol constants\nNBD_CMD_READ = 0\nNBD_CMD_WRITE = 1\nNBD_CMD_DISC = 2\nNBD_REQUEST_MAGIC = 0x25609513\nNBD_SIMPLE_REPLY_MAGIC = 0x67446698\nNBD_PASSWD = 0x4e42444d41474943\nNBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_CMD_READ",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_CMD_READ = 0\nNBD_CMD_WRITE = 1\nNBD_CMD_DISC = 2\nNBD_REQUEST_MAGIC = 0x25609513\nNBD_SIMPLE_REPLY_MAGIC = 0x67446698\nNBD_PASSWD = 0x4e42444d41474943\nNBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_CMD_WRITE",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_CMD_WRITE = 1\nNBD_CMD_DISC = 2\nNBD_REQUEST_MAGIC = 0x25609513\nNBD_SIMPLE_REPLY_MAGIC = 0x67446698\nNBD_PASSWD = 0x4e42444d41474943\nNBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_CMD_DISC",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_CMD_DISC = 2\nNBD_REQUEST_MAGIC = 0x25609513\nNBD_SIMPLE_REPLY_MAGIC = 0x67446698\nNBD_PASSWD = 0x4e42444d41474943\nNBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_REQUEST_MAGIC",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_REQUEST_MAGIC = 0x25609513\nNBD_SIMPLE_REPLY_MAGIC = 0x67446698\nNBD_PASSWD = 0x4e42444d41474943\nNBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_SIMPLE_REPLY_MAGIC",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_SIMPLE_REPLY_MAGIC = 0x67446698\nNBD_PASSWD = 0x4e42444d41474943\nNBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_PASSWD",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_PASSWD = 0x4e42444d41474943\nNBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_OPTS_MAGIC",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_OPTS_MAGIC = 0x49484156454F5054\nNBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_CLIENT_MAGIC",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_CLIENT_MAGIC = 0x0000420281861253\nNBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "NBD_OPT_EXPORT_NAME",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "NBD_OPT_EXPORT_NAME = 1 << 0\n# Protocol structs\nneg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "neg_classic_struct",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "neg_classic_struct = struct.Struct('>QQQI124x')\nneg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "neg1_struct",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "neg1_struct = struct.Struct('>QQH')\nexport_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "export_tuple",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "export_tuple = collections.namedtuple('Export', 'reserved magic opt len')\nexport_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef recvall(sock, bufsize):",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "export_struct",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "export_struct = struct.Struct('>IQII')\nneg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef recvall(sock, bufsize):\n    received = 0",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "neg2_struct",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "neg2_struct = struct.Struct('>QH124x')\nrequest_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef recvall(sock, bufsize):\n    received = 0\n    chunks = []",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "request_tuple",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "request_tuple = collections.namedtuple('Request', 'magic type handle from_ len')\nrequest_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef recvall(sock, bufsize):\n    received = 0\n    chunks = []\n    while received < bufsize:",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "request_struct",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "request_struct = struct.Struct('>IIQQI')\nreply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef recvall(sock, bufsize):\n    received = 0\n    chunks = []\n    while received < bufsize:\n        chunk = sock.recv(bufsize - received)",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "reply_struct",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "description": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "peekOfCode": "reply_struct = struct.Struct('>IIQ')\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef recvall(sock, bufsize):\n    received = 0\n    chunks = []\n    while received < bufsize:\n        chunk = sock.recv(bufsize - received)\n        if len(chunk) == 0:",
        "detail": "qemu.tests.qemu-iotests.nbd-fault-injector",
        "documentation": {}
    },
    {
        "label": "cmd_dump_header",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def cmd_dump_header(fd):\n    h = QcowHeader(fd)\n    h.dump(is_json)\n    print()\n    h.dump_extensions(is_json)\ndef cmd_dump_header_exts(fd):\n    h = QcowHeader(fd)\n    h.dump_extensions(is_json)\ndef cmd_set_header(fd, name, value):\n    try:",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "cmd_dump_header_exts",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def cmd_dump_header_exts(fd):\n    h = QcowHeader(fd)\n    h.dump_extensions(is_json)\ndef cmd_set_header(fd, name, value):\n    try:\n        value = int(value, 0)\n    except ValueError:\n        print(\"'%s' is not a valid number\" % value)\n        sys.exit(1)\n    fields = (field[2] for field in QcowHeader.fields)",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "cmd_set_header",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def cmd_set_header(fd, name, value):\n    try:\n        value = int(value, 0)\n    except ValueError:\n        print(\"'%s' is not a valid number\" % value)\n        sys.exit(1)\n    fields = (field[2] for field in QcowHeader.fields)\n    if name not in fields:\n        print(\"'%s' is not a known header field\" % name)\n        sys.exit(1)",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "cmd_add_header_ext",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def cmd_add_header_ext(fd, magic, data):\n    try:\n        magic = int(magic, 0)\n    except ValueError:\n        print(\"'%s' is not a valid magic number\" % magic)\n        sys.exit(1)\n    h = QcowHeader(fd)\n    h.extensions.append(QcowHeaderExtension.create(magic,\n                                                   data.encode('ascii')))\n    h.update(fd)",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "cmd_add_header_ext_stdio",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def cmd_add_header_ext_stdio(fd, magic):\n    data = sys.stdin.read()\n    cmd_add_header_ext(fd, magic, data)\ndef cmd_del_header_ext(fd, magic):\n    try:\n        magic = int(magic, 0)\n    except ValueError:\n        print(\"'%s' is not a valid magic number\" % magic)\n        sys.exit(1)\n    h = QcowHeader(fd)",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "cmd_del_header_ext",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def cmd_del_header_ext(fd, magic):\n    try:\n        magic = int(magic, 0)\n    except ValueError:\n        print(\"'%s' is not a valid magic number\" % magic)\n        sys.exit(1)\n    h = QcowHeader(fd)\n    found = False\n    for ex in h.extensions:\n        if ex.magic == magic:",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "cmd_set_feature_bit",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def cmd_set_feature_bit(fd, group, bit):\n    try:\n        bit = int(bit, 0)\n        if bit < 0 or bit >= 64:\n            raise ValueError\n    except ValueError:\n        print(\"'%s' is not a valid bit number in range [0, 64)\" % bit)\n        sys.exit(1)\n    h = QcowHeader(fd)\n    if group == 'incompatible':",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def main(filename, cmd, args):\n    fd = open(filename, \"r+b\")\n    try:\n        for name, handler, num_args, desc in cmds:\n            if name != cmd:\n                continue\n            elif len(args) != num_args:\n                usage()\n                return\n            else:",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "def usage():\n    print(\"Usage: %s <file> <cmd> [<arg>, ...] [<key>, ...]\" % sys.argv[0])\n    print(\"\")\n    print(\"Supported commands:\")\n    for name, handler, num_args, desc in cmds:\n        print(\"    %-20s - %s\" % (name, desc))\n    print(\"\")\n    print(\"Supported keys:\")\n    print(\"    %-20s - %s\" % ('-j', 'Dump in JSON format'))\nif __name__ == '__main__':",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "is_json",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "is_json = False\ndef cmd_dump_header(fd):\n    h = QcowHeader(fd)\n    h.dump(is_json)\n    print()\n    h.dump_extensions(is_json)\ndef cmd_dump_header_exts(fd):\n    h = QcowHeader(fd)\n    h.dump_extensions(is_json)\ndef cmd_set_header(fd, name, value):",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "cmds",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qcow2",
        "description": "qemu.tests.qemu-iotests.qcow2",
        "peekOfCode": "cmds = [\n    ['dump-header', cmd_dump_header, 0,\n     'Dump image header and header extensions'],\n    ['dump-header-exts', cmd_dump_header_exts, 0,\n     'Dump image header extensions'],\n    ['set-header', cmd_set_header, 2, 'Set a field in the header'],\n    ['add-header-ext', cmd_add_header_ext, 2, 'Add a header extension'],\n    ['add-header-ext-stdio', cmd_add_header_ext_stdio, 1,\n     'Add a header extension, data from stdin'],\n    ['del-header-ext', cmd_del_header_ext, 1, 'Delete a header extension'],",
        "detail": "qemu.tests.qemu-iotests.qcow2",
        "documentation": {}
    },
    {
        "label": "ComplexEncoder",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class ComplexEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if hasattr(obj, 'to_json'):\n            return obj.to_json()\n        else:\n            return json.JSONEncoder.default(self, obj)\nclass Qcow2Field:\n    def __init__(self, value):\n        self.value = value\n    def __str__(self):",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Qcow2Field",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Qcow2Field:\n    def __init__(self, value):\n        self.value = value\n    def __str__(self):\n        return str(self.value)\nclass Flags64(Qcow2Field):\n    def __str__(self):\n        bits = []\n        for bit in range(64):\n            if self.value & (1 << bit):",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Flags64",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Flags64(Qcow2Field):\n    def __str__(self):\n        bits = []\n        for bit in range(64):\n            if self.value & (1 << bit):\n                bits.append(bit)\n        return str(bits)\nclass BitmapFlags(Qcow2Field):\n    flags = {\n        0x1: 'in-use',",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "BitmapFlags",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class BitmapFlags(Qcow2Field):\n    flags = {\n        0x1: 'in-use',\n        0x2: 'auto'\n    }\n    def __str__(self):\n        bits = []\n        for bit in range(64):\n            flag = self.value & (1 << bit)\n            if flag:",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Enum",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Enum(Qcow2Field):\n    def __str__(self):\n        return f'{self.value:#x} ({self.mapping.get(self.value, \"<unknown>\")})'\nclass Qcow2StructMeta(type):\n    # Mapping from c types to python struct format\n    ctypes = {\n        'u8': 'B',\n        'u16': 'H',\n        'u32': 'I',\n        'u64': 'Q'",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Qcow2StructMeta",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Qcow2StructMeta(type):\n    # Mapping from c types to python struct format\n    ctypes = {\n        'u8': 'B',\n        'u16': 'H',\n        'u32': 'I',\n        'u64': 'Q'\n    }\n    def __init__(self, name, bases, attrs):\n        if 'fields' in attrs:",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Qcow2Struct",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Qcow2Struct(metaclass=Qcow2StructMeta):\n    \"\"\"Qcow2Struct: base class for qcow2 data structures\n    Successors should define fields class variable, which is: list of tuples,\n    each of three elements:\n        - c-type (one of 'u8', 'u16', 'u32', 'u64')\n        - format (format_spec to use with .format() when dump or 'mask' to dump\n                  bitmasks)\n        - field name\n    \"\"\"\n    def __init__(self, fd=None, offset=None, data=None):",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Qcow2BitmapExt",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Qcow2BitmapExt(Qcow2Struct):\n    fields = (\n        ('u32', '{}', 'nb_bitmaps'),\n        ('u32', '{}', 'reserved32'),\n        ('u64', '{:#x}', 'bitmap_directory_size'),\n        ('u64', '{:#x}', 'bitmap_directory_offset')\n    )\n    def __init__(self, fd, cluster_size):\n        super().__init__(fd=fd)\n        tail = struct.calcsize(self.fmt) % 8",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Qcow2BitmapDirEntry",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Qcow2BitmapDirEntry(Qcow2Struct):\n    fields = (\n        ('u64', '{:#x}', 'bitmap_table_offset'),\n        ('u32', '{}', 'bitmap_table_size'),\n        ('u32', BitmapFlags, 'flags'),\n        ('u8',  '{}', 'type'),\n        ('u8',  '{}', 'granularity_bits'),\n        ('u16', '{}', 'name_size'),\n        ('u32', '{}', 'extra_data_size')\n    )",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Qcow2BitmapTableEntry",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Qcow2BitmapTableEntry(Qcow2Struct):\n    fields = (\n        ('u64',  '{}', 'entry'),\n    )\n    BME_TABLE_ENTRY_RESERVED_MASK = 0xff000000000001fe\n    BME_TABLE_ENTRY_OFFSET_MASK = 0x00fffffffffffe00\n    BME_TABLE_ENTRY_FLAG_ALL_ONES = 1\n    def __init__(self, fd):\n        super().__init__(fd=fd)\n        self.reserved = self.entry & self.BME_TABLE_ENTRY_RESERVED_MASK",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "Qcow2BitmapTable",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class Qcow2BitmapTable:\n    def __init__(self, fd, offset, nb_entries, cluster_size):\n        self.cluster_size = cluster_size\n        position = fd.tell()\n        fd.seek(offset)\n        self.entries = [Qcow2BitmapTableEntry(fd) for _ in range(nb_entries)]\n        fd.seek(position)\n    def dump(self):\n        bitmap_table = enumerate(self.entries)\n        print(f'{\"Bitmap table\":<14} {\"type\":<15} {\"size\":<12} {\"offset\"}')",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "QcowHeaderExtension",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class QcowHeaderExtension(Qcow2Struct):\n    class Magic(Enum):\n        mapping = {\n            0xe2792aca: 'Backing format',\n            0x6803f857: 'Feature table',\n            0x0537be77: 'Crypto header',\n            QCOW2_EXT_MAGIC_BITMAPS: 'Bitmaps',\n            0x44415441: 'Data file'\n        }\n        def to_json(self):",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "QcowHeader",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "class QcowHeader(Qcow2Struct):\n    fields = (\n        # Version 2 header fields\n        ('u32', '{:#x}', 'magic'),\n        ('u32', '{}', 'version'),\n        ('u64', '{:#x}', 'backing_file_offset'),\n        ('u32', '{:#x}', 'backing_file_size'),\n        ('u32', '{}', 'cluster_bits'),\n        ('u64', '{}', 'size'),\n        ('u32', '{}', 'crypt_method'),",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "QCOW2_EXT_MAGIC_BITMAPS",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qcow2_format",
        "description": "qemu.tests.qemu-iotests.qcow2_format",
        "peekOfCode": "QCOW2_EXT_MAGIC_BITMAPS = 0x23852875\nclass QcowHeaderExtension(Qcow2Struct):\n    class Magic(Enum):\n        mapping = {\n            0xe2792aca: 'Backing format',\n            0x6803f857: 'Feature table',\n            0x0537be77: 'Crypto header',\n            QCOW2_EXT_MAGIC_BITMAPS: 'Bitmaps',\n            0x44415441: 'Data file'\n        }",
        "detail": "qemu.tests.qemu-iotests.qcow2_format",
        "documentation": {}
    },
    {
        "label": "QED",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "class QED(object):\n    def __init__(self, f):\n        self.f = f\n        self.f.seek(0, 2)\n        self.filesize = f.tell()\n        self.load_header()\n        self.load_l1_table()\n    def raw_pread(self, offset, size):\n        self.f.seek(offset)\n        return self.f.read(size)",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "err",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef unpack_header(s):\n    fields = struct.unpack(header_fmt, s)\n    return dict((field_names[idx], val) for idx, val in enumerate(fields))\ndef pack_header(header):\n    fields = tuple(header[x] for x in field_names)\n    return struct.pack(header_fmt, *fields)\ndef unpack_table_elem(s):",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "unpack_header",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def unpack_header(s):\n    fields = struct.unpack(header_fmt, s)\n    return dict((field_names[idx], val) for idx, val in enumerate(fields))\ndef pack_header(header):\n    fields = tuple(header[x] for x in field_names)\n    return struct.pack(header_fmt, *fields)\ndef unpack_table_elem(s):\n    return struct.unpack(table_elem_fmt, s)[0]\ndef pack_table_elem(elem):\n    return struct.pack(table_elem_fmt, elem)",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "pack_header",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def pack_header(header):\n    fields = tuple(header[x] for x in field_names)\n    return struct.pack(header_fmt, *fields)\ndef unpack_table_elem(s):\n    return struct.unpack(table_elem_fmt, s)[0]\ndef pack_table_elem(elem):\n    return struct.pack(table_elem_fmt, elem)\nclass QED(object):\n    def __init__(self, f):\n        self.f = f",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "unpack_table_elem",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def unpack_table_elem(s):\n    return struct.unpack(table_elem_fmt, s)[0]\ndef pack_table_elem(elem):\n    return struct.pack(table_elem_fmt, elem)\nclass QED(object):\n    def __init__(self, f):\n        self.f = f\n        self.f.seek(0, 2)\n        self.filesize = f.tell()\n        self.load_header()",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "pack_table_elem",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def pack_table_elem(elem):\n    return struct.pack(table_elem_fmt, elem)\nclass QED(object):\n    def __init__(self, f):\n        self.f = f\n        self.f.seek(0, 2)\n        self.filesize = f.tell()\n        self.load_header()\n        self.load_l1_table()\n    def raw_pread(self, offset, size):",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "random_table_item",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def random_table_item(table):\n    vals = [(index, offset) for index, offset in enumerate(table) if offset != 0]\n    if not vals:\n        err('cannot pick random item because table is empty')\n    return random.choice(vals)\ndef corrupt_table_duplicate(table):\n    '''Corrupt a table by introducing a duplicate offset'''\n    victim_idx, victim_val = random_table_item(table)\n    unique_vals = set(table)\n    if len(unique_vals) == 1:",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "corrupt_table_duplicate",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def corrupt_table_duplicate(table):\n    '''Corrupt a table by introducing a duplicate offset'''\n    victim_idx, victim_val = random_table_item(table)\n    unique_vals = set(table)\n    if len(unique_vals) == 1:\n        err('no duplication corruption possible in table')\n    dup_val = random.choice(list(unique_vals.difference([victim_val])))\n    table[victim_idx] = dup_val\ndef corrupt_table_invalidate(qed, table):\n    '''Corrupt a table by introducing an invalid offset'''",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "corrupt_table_invalidate",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def corrupt_table_invalidate(qed, table):\n    '''Corrupt a table by introducing an invalid offset'''\n    index, _ = random_table_item(table)\n    table[index] = qed.filesize + random.randint(0, 100 * 1024 * 1024 * 1024 * 1024)\ndef cmd_show(qed, *args):\n    '''show [header|l1|l2 <offset>]- Show header or l1/l2 tables'''\n    if not args or args[0] == 'header':\n        print(qed.header)\n    elif args[0] == 'l1':\n        print(qed.l1_table)",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "cmd_show",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def cmd_show(qed, *args):\n    '''show [header|l1|l2 <offset>]- Show header or l1/l2 tables'''\n    if not args or args[0] == 'header':\n        print(qed.header)\n    elif args[0] == 'l1':\n        print(qed.l1_table)\n    elif len(args) == 2 and args[0] == 'l2':\n        offset = int(args[1])\n        print(qed.read_table(offset))\n    else:",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "cmd_duplicate",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def cmd_duplicate(qed, table_level):\n    '''duplicate l1|l2 - Duplicate a random table element'''\n    if table_level == 'l1':\n        offset = qed.header['l1_table_offset']\n        table = qed.l1_table\n    elif table_level == 'l2':\n        _, offset = random_table_item(qed.l1_table)\n        table = qed.read_table(offset)\n    else:\n        err('unrecognized sub-command')",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "cmd_invalidate",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def cmd_invalidate(qed, table_level):\n    '''invalidate l1|l2 - Plant an invalid table element at random'''\n    if table_level == 'l1':\n        offset = qed.header['l1_table_offset']\n        table = qed.l1_table\n    elif table_level == 'l2':\n        _, offset = random_table_item(qed.l1_table)\n        table = qed.read_table(offset)\n    else:\n        err('unrecognized sub-command')",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "cmd_need_check",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def cmd_need_check(qed, *args):\n    '''need-check [on|off] - Test, set, or clear the QED_F_NEED_CHECK header bit'''\n    if not args:\n        print(bool(qed.header['features'] & QED_F_NEED_CHECK))\n        return\n    if args[0] == 'on':\n        qed.header['features'] |= QED_F_NEED_CHECK\n    elif args[0] == 'off':\n        qed.header['features'] &= ~QED_F_NEED_CHECK\n    else:",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "cmd_zero_cluster",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def cmd_zero_cluster(qed, pos, *args):\n    '''zero-cluster <pos> [<n>] - Zero data clusters'''\n    pos, n = int(pos), 1\n    if args:\n        if len(args) != 1:\n            err('expected one argument')\n        n = int(args[0])\n    for i in xrange(n):\n        l1_index = pos // qed.header['cluster_size'] // len(qed.l1_table)\n        if qed.l1_table[l1_index] == 0:",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "cmd_copy_metadata",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def cmd_copy_metadata(qed, outfile):\n    '''copy-metadata <outfile> - Copy metadata only (for scrubbing corrupted images)'''\n    out = open(outfile, 'wb')\n    # Match file size\n    out.seek(qed.filesize - 1)\n    out.write('\\0')\n    # Copy header clusters\n    out.seek(0)\n    header_size_bytes = qed.header['header_size'] * qed.header['cluster_size']\n    out.write(qed.raw_pread(0, header_size_bytes))",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def usage():\n    print('Usage: %s <file> <cmd> [<arg>, ...]' % sys.argv[0])\n    print()\n    print('Supported commands:')\n    for cmd in sorted(x for x in globals() if x.startswith('cmd_')):\n        print(globals()[cmd].__doc__)\n    sys.exit(1)\ndef main():\n    if len(sys.argv) < 3:\n        usage()",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "def main():\n    if len(sys.argv) < 3:\n        usage()\n    filename, cmd = sys.argv[1:3]\n    cmd = 'cmd_' + cmd.replace('-', '_')\n    if cmd not in globals():\n        usage()\n    qed = QED(open(filename, 'r+b'))\n    try:\n        globals()[cmd](qed, *sys.argv[3:])",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "__all__ = ['QED_F_NEED_CHECK', 'QED']\nQED_F_NEED_CHECK = 0x02\nheader_fmt = '<IIIIQQQQQII'\nheader_size = struct.calcsize(header_fmt)\nfield_names = ['magic', 'cluster_size', 'table_size',\n               'header_size', 'features', 'compat_features',\n               'autoclear_features', 'l1_table_offset', 'image_size',\n               'backing_filename_offset', 'backing_filename_size']\ntable_elem_fmt = '<Q'\ntable_elem_size = struct.calcsize(table_elem_fmt)",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "QED_F_NEED_CHECK",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "QED_F_NEED_CHECK = 0x02\nheader_fmt = '<IIIIQQQQQII'\nheader_size = struct.calcsize(header_fmt)\nfield_names = ['magic', 'cluster_size', 'table_size',\n               'header_size', 'features', 'compat_features',\n               'autoclear_features', 'l1_table_offset', 'image_size',\n               'backing_filename_offset', 'backing_filename_size']\ntable_elem_fmt = '<Q'\ntable_elem_size = struct.calcsize(table_elem_fmt)\ndef err(msg):",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "header_fmt",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "header_fmt = '<IIIIQQQQQII'\nheader_size = struct.calcsize(header_fmt)\nfield_names = ['magic', 'cluster_size', 'table_size',\n               'header_size', 'features', 'compat_features',\n               'autoclear_features', 'l1_table_offset', 'image_size',\n               'backing_filename_offset', 'backing_filename_size']\ntable_elem_fmt = '<Q'\ntable_elem_size = struct.calcsize(table_elem_fmt)\ndef err(msg):\n    sys.stderr.write(msg + '\\n')",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "header_size",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "header_size = struct.calcsize(header_fmt)\nfield_names = ['magic', 'cluster_size', 'table_size',\n               'header_size', 'features', 'compat_features',\n               'autoclear_features', 'l1_table_offset', 'image_size',\n               'backing_filename_offset', 'backing_filename_size']\ntable_elem_fmt = '<Q'\ntable_elem_size = struct.calcsize(table_elem_fmt)\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "field_names",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "field_names = ['magic', 'cluster_size', 'table_size',\n               'header_size', 'features', 'compat_features',\n               'autoclear_features', 'l1_table_offset', 'image_size',\n               'backing_filename_offset', 'backing_filename_size']\ntable_elem_fmt = '<Q'\ntable_elem_size = struct.calcsize(table_elem_fmt)\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef unpack_header(s):",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "table_elem_fmt",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "table_elem_fmt = '<Q'\ntable_elem_size = struct.calcsize(table_elem_fmt)\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef unpack_header(s):\n    fields = struct.unpack(header_fmt, s)\n    return dict((field_names[idx], val) for idx, val in enumerate(fields))\ndef pack_header(header):\n    fields = tuple(header[x] for x in field_names)",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "table_elem_size",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.qed",
        "description": "qemu.tests.qemu-iotests.qed",
        "peekOfCode": "table_elem_size = struct.calcsize(table_elem_fmt)\ndef err(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef unpack_header(s):\n    fields = struct.unpack(header_fmt, s)\n    return dict((field_names[idx], val) for idx, val in enumerate(fields))\ndef pack_header(header):\n    fields = tuple(header[x] for x in field_names)\n    return struct.pack(header_fmt, *fields)",
        "detail": "qemu.tests.qemu-iotests.qed",
        "documentation": {}
    },
    {
        "label": "TestEnv",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.testenv",
        "description": "qemu.tests.qemu-iotests.testenv",
        "peekOfCode": "class TestEnv(ContextManager['TestEnv']):\n    \"\"\"\n    Manage system environment for running tests\n    The following variables are supported/provided. They are represented by\n    lower-cased TestEnv attributes.\n    \"\"\"\n    # We store environment variables as instance attributes, and there are a\n    # lot of them. Silence pylint:\n    # pylint: disable=too-many-instance-attributes\n    env_variables = ['PYTHONPATH', 'TEST_DIR', 'SOCK_DIR', 'SAMPLE_IMG_DIR',",
        "detail": "qemu.tests.qemu-iotests.testenv",
        "documentation": {}
    },
    {
        "label": "isxfile",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.testenv",
        "description": "qemu.tests.qemu-iotests.testenv",
        "peekOfCode": "def isxfile(path: str) -> bool:\n    return os.path.isfile(path) and os.access(path, os.X_OK)\ndef get_default_machine(qemu_prog: str) -> str:\n    outp = subprocess.run([qemu_prog, '-machine', 'help'], check=True,\n                          universal_newlines=True,\n                          stdout=subprocess.PIPE).stdout\n    machines = outp.split('\\n')\n    try:\n        default_machine = next(m for m in machines if ' (default)' in m)\n    except StopIteration:",
        "detail": "qemu.tests.qemu-iotests.testenv",
        "documentation": {}
    },
    {
        "label": "get_default_machine",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.testenv",
        "description": "qemu.tests.qemu-iotests.testenv",
        "peekOfCode": "def get_default_machine(qemu_prog: str) -> str:\n    outp = subprocess.run([qemu_prog, '-machine', 'help'], check=True,\n                          universal_newlines=True,\n                          stdout=subprocess.PIPE).stdout\n    machines = outp.split('\\n')\n    try:\n        default_machine = next(m for m in machines if ' (default)' in m)\n    except StopIteration:\n        return ''\n    default_machine = default_machine.split(' ', 1)[0]",
        "detail": "qemu.tests.qemu-iotests.testenv",
        "documentation": {}
    },
    {
        "label": "DEF_GDB_OPTIONS",
        "kind": 5,
        "importPath": "qemu.tests.qemu-iotests.testenv",
        "description": "qemu.tests.qemu-iotests.testenv",
        "peekOfCode": "DEF_GDB_OPTIONS = 'localhost:12345'\ndef isxfile(path: str) -> bool:\n    return os.path.isfile(path) and os.access(path, os.X_OK)\ndef get_default_machine(qemu_prog: str) -> str:\n    outp = subprocess.run([qemu_prog, '-machine', 'help'], check=True,\n                          universal_newlines=True,\n                          stdout=subprocess.PIPE).stdout\n    machines = outp.split('\\n')\n    try:\n        default_machine = next(m for m in machines if ' (default)' in m)",
        "detail": "qemu.tests.qemu-iotests.testenv",
        "documentation": {}
    },
    {
        "label": "LastElapsedTime",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.testrunner",
        "description": "qemu.tests.qemu-iotests.testrunner",
        "peekOfCode": "class LastElapsedTime(ContextManager['LastElapsedTime']):\n    \"\"\" Cache for elapsed time for tests, to show it during new test run\n    It is safe to use get() at any time.  To use update(), you must either\n    use it inside with-block or use save() after update().\n    \"\"\"\n    def __init__(self, cache_file: str, env: TestEnv) -> None:\n        self.env = env\n        self.cache_file = cache_file\n        self.cache: Dict[str, Dict[str, Dict[str, float]]]\n        try:",
        "detail": "qemu.tests.qemu-iotests.testrunner",
        "documentation": {}
    },
    {
        "label": "TestResult",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.testrunner",
        "description": "qemu.tests.qemu-iotests.testrunner",
        "peekOfCode": "class TestResult:\n    def __init__(self, status: str, description: str = '',\n                 elapsed: Optional[float] = None, diff: Sequence[str] = (),\n                 casenotrun: str = '', interrupted: bool = False) -> None:\n        self.status = status\n        self.description = description\n        self.elapsed = elapsed\n        self.diff = diff\n        self.casenotrun = casenotrun\n        self.interrupted = interrupted",
        "detail": "qemu.tests.qemu-iotests.testrunner",
        "documentation": {}
    },
    {
        "label": "TestRunner",
        "kind": 6,
        "importPath": "qemu.tests.qemu-iotests.testrunner",
        "description": "qemu.tests.qemu-iotests.testrunner",
        "peekOfCode": "class TestRunner(ContextManager['TestRunner']):\n    shared_self = None\n    @staticmethod\n    def proc_run_test(test: str, test_field_width: int) -> TestResult:\n        # We are in a subprocess, we can't change the runner object!\n        runner = TestRunner.shared_self\n        assert runner is not None\n        return runner.run_test(test, test_field_width, mp=True)\n    def run_tests_pool(self, tests: List[str],\n                       test_field_width: int, jobs: int) -> List[TestResult]:",
        "detail": "qemu.tests.qemu-iotests.testrunner",
        "documentation": {}
    },
    {
        "label": "silent_unlink",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.testrunner",
        "description": "qemu.tests.qemu-iotests.testrunner",
        "peekOfCode": "def silent_unlink(path: Path) -> None:\n    try:\n        path.unlink()\n    except OSError:\n        pass\ndef file_diff(file1: str, file2: str) -> List[str]:\n    with open(file1, encoding=\"utf-8\") as f1, \\\n         open(file2, encoding=\"utf-8\") as f2:\n        # We want to ignore spaces at line ends. There are a lot of mess about\n        # it in iotests.",
        "detail": "qemu.tests.qemu-iotests.testrunner",
        "documentation": {}
    },
    {
        "label": "file_diff",
        "kind": 2,
        "importPath": "qemu.tests.qemu-iotests.testrunner",
        "description": "qemu.tests.qemu-iotests.testrunner",
        "peekOfCode": "def file_diff(file1: str, file2: str) -> List[str]:\n    with open(file1, encoding=\"utf-8\") as f1, \\\n         open(file2, encoding=\"utf-8\") as f2:\n        # We want to ignore spaces at line ends. There are a lot of mess about\n        # it in iotests.\n        # TODO: fix all tests to not produce extra spaces, fix all .out files\n        # and use strict diff here!\n        seq1 = [line.rstrip() for line in f1]\n        seq2 = [line.rstrip() for line in f2]\n        res = [line.rstrip()",
        "detail": "qemu.tests.qemu-iotests.testrunner",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "peekOfCode": "def run_test():\n    p = arg_parser(prog=\"test-mte.py\", description=\"TCG MTE tests.\")\n    p.add_argument(\"--mode\", help=\"Run test for QEMU system or user mode.\",\n                   required=True, choices=['system','user'])\n    args = p.parse_args(args=argv)\n    if args.mode == \"system\":\n        # Break address: where to break before performing the tests\n        # See mte.S for details about this label.\n        ba = \"main_end\"\n        # Tagged address: the start of the MTE-enabled memory chunk to be tested",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "documentation": {}
    },
    {
        "label": "PATTERN_0",
        "kind": 5,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "peekOfCode": "PATTERN_0 = r\"Memory tags for address 0x[0-9a-f]+ match \\(0x[0-9a-f]+\\).\"\nPATTERN_1 = r\".*(0x[0-9a-f]+)\"\ndef run_test():\n    p = arg_parser(prog=\"test-mte.py\", description=\"TCG MTE tests.\")\n    p.add_argument(\"--mode\", help=\"Run test for QEMU system or user mode.\",\n                   required=True, choices=['system','user'])\n    args = p.parse_args(args=argv)\n    if args.mode == \"system\":\n        # Break address: where to break before performing the tests\n        # See mte.S for details about this label.",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "documentation": {}
    },
    {
        "label": "PATTERN_1",
        "kind": 5,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "peekOfCode": "PATTERN_1 = r\".*(0x[0-9a-f]+)\"\ndef run_test():\n    p = arg_parser(prog=\"test-mte.py\", description=\"TCG MTE tests.\")\n    p.add_argument(\"--mode\", help=\"Run test for QEMU system or user mode.\",\n                   required=True, choices=['system','user'])\n    args = p.parse_args(args=argv)\n    if args.mode == \"system\":\n        # Break address: where to break before performing the tests\n        # See mte.S for details about this label.\n        ba = \"main_end\"",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-mte",
        "documentation": {}
    },
    {
        "label": "TestBreakpoint",
        "kind": 6,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "peekOfCode": "class TestBreakpoint(gdb.Breakpoint):\n    def __init__(self, sym_name=\"__sve_ld_done\"):\n        super(TestBreakpoint, self).__init__(sym_name)\n        # self.sym, ok = gdb.lookup_symbol(sym_name)\n    def stop(self):\n        val_i = gdb.parse_and_eval('i')\n        global initial_vlen\n        try:\n            for i in range(0, int(val_i)):\n                val_z = gdb.parse_and_eval(\"$z0.b.u[%d]\" % i)",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "peekOfCode": "def run_test():\n    \"Run through the tests one by one\"\n    print (\"Setup breakpoint\")\n    bp = TestBreakpoint()\n    global initial_vlen\n    vg = gdb.parse_and_eval(\"$vg\")\n    initial_vlen = int(vg) * 8\n    gdb.execute(\"c\")\nmain(run_test, expected_arch=\"aarch64\")",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "documentation": {}
    },
    {
        "label": "initial_vlen",
        "kind": 5,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "peekOfCode": "initial_vlen = 0\nclass TestBreakpoint(gdb.Breakpoint):\n    def __init__(self, sym_name=\"__sve_ld_done\"):\n        super(TestBreakpoint, self).__init__(sym_name)\n        # self.sym, ok = gdb.lookup_symbol(sym_name)\n    def stop(self):\n        val_i = gdb.parse_and_eval('i')\n        global initial_vlen\n        try:\n            for i in range(0, int(val_i)):",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-sve-ioctl",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-sve",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-sve",
        "peekOfCode": "def run_test():\n    \"Run through the tests one by one\"\n    gdb.execute(\"info registers\")\n    report(True, \"info registers\")\n    gdb.execute(\"info registers vector\")\n    report(True, \"info registers vector\")\n    # Now all the zregs\n    frame = gdb.selected_frame()\n    for i in range(0, 32):\n        rname = \"z%d\" % (i)",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-sve",
        "documentation": {}
    },
    {
        "label": "MAGIC",
        "kind": 5,
        "importPath": "qemu.tests.tcg.aarch64.gdbstub.test-sve",
        "description": "qemu.tests.tcg.aarch64.gdbstub.test-sve",
        "peekOfCode": "MAGIC = 0xDEADBEEF\ndef run_test():\n    \"Run through the tests one by one\"\n    gdb.execute(\"info registers\")\n    report(True, \"info registers\")\n    gdb.execute(\"info registers vector\")\n    report(True, \"info registers vector\")\n    # Now all the zregs\n    frame = gdb.selected_frame()\n    for i in range(0, 32):",
        "detail": "qemu.tests.tcg.aarch64.gdbstub.test-sve",
        "documentation": {}
    },
    {
        "label": "XMMArg",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class XMMArg():\n    isxmm = True\n    def __init__(self, reg, mw):\n        if mw not in [0, 8, 16, 32, 64, 128, 256]:\n            raise Exception(\"Bad /m width: %s\" % w)\n        self.reg = reg\n        self.mw = mw\n        self.ismem = mw != 0\n    def regstr(self, n):\n        if n < 0:",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "MMArg",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class MMArg():\n    isxmm = True\n    def __init__(self, mw):\n        if mw not in [0, 32, 64]:\n            raise Exception(\"Bad mem width: %s\" % mw)\n        self.mw = mw\n        self.ismem = mw != 0\n    def regstr(self, n):\n        return \"mm%d\" % (n & 7)\ndef match(op, pattern):",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "ArgVSIB",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class ArgVSIB():\n    isxmm = True\n    ismem = False\n    def __init__(self, reg, w):\n        if w not in [32, 64]:\n            raise Exception(\"Bad vsib width: %s\" % w)\n        self.w = w\n        self.reg = reg\n    def regstr(self, n):\n        reg = \"%smm%d\" % (self.reg, n >> 2)",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "ArgImm8u",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class ArgImm8u():\n    isxmm = False\n    ismem = False\n    def __init__(self, op):\n        for k, v in imask.items():\n            if match(op, k):\n                self.mask = imask[k];\n                return\n        raise Exception(\"Unknown immediate\")\n    def vals(self):",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "ArgRM",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class ArgRM():\n    isxmm = False\n    def __init__(self, rw, mw):\n        if rw not in [8, 16, 32, 64]:\n            raise Exception(\"Bad r/w width: %s\" % w)\n        if mw not in [0, 8, 16, 32, 64]:\n            raise Exception(\"Bad r/w width: %s\" % w)\n        self.rw = rw\n        self.mw = mw\n        self.ismem = mw != 0",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "ArgMem",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class ArgMem():\n    isxmm = False\n    ismem = True\n    def __init__(self, w):\n        if w not in [8, 16, 32, 64, 128, 256]:\n            raise Exception(\"Bad mem width: %s\" % w)\n        self.w = w\n    def regstr(self, n):\n        return mem_w(self.w)\nclass SkipInstruction(Exception):",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "SkipInstruction",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class SkipInstruction(Exception):\n    pass\ndef ArgGenerator(arg, op):\n    if arg[:3] == 'xmm' or arg[:3] == \"ymm\":\n        if \"/\" in arg:\n            r, m = arg.split('/')\n            if (m[0] != 'm'):\n                raise Exception(\"Expected /m: %s\", arg)\n            return XMMArg(arg[0], int(m[1:]));\n        else:",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "InsnGenerator",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "class InsnGenerator:\n    def __init__(self, op, args):\n        self.op = op\n        if op[-2:] in [\"PH\", \"PS\", \"PD\", \"SS\", \"SD\"]:\n            if op[-1] == 'H':\n                self.optype = 'F16'\n            elif op[-1] == 'S':\n                self.optype = 'F32'\n            else:\n                self.optype = 'F64'",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "strip_comments",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "def strip_comments(x):\n    for l in x:\n        if l != '' and l[0] != '#':\n            yield l\ndef reg_w(w):\n    if w == 8:\n        return 'al'\n    elif w == 16:\n        return 'ax'\n    elif w == 32:",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "reg_w",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "def reg_w(w):\n    if w == 8:\n        return 'al'\n    elif w == 16:\n        return 'ax'\n    elif w == 32:\n        return 'eax'\n    elif w == 64:\n        return 'rax'\n    raise Exception(\"bad reg_w %d\" % w)",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "mem_w",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "def mem_w(w):\n    if w == 8:\n        t = \"BYTE\"\n    elif w == 16:\n        t = \"WORD\"\n    elif w == 32:\n        t = \"DWORD\"\n    elif w == 64:\n        t = \"QWORD\"\n    elif w == 128:",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "match",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "def match(op, pattern):\n    if pattern[0] == 'v':\n        return fnmatch(op, pattern[1:]) or fnmatch(op, 'V'+pattern[1:])\n    return fnmatch(op, pattern)\nclass ArgVSIB():\n    isxmm = True\n    ismem = False\n    def __init__(self, reg, w):\n        if w not in [32, 64]:\n            raise Exception(\"Bad vsib width: %s\" % w)",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "ArgGenerator",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "def ArgGenerator(arg, op):\n    if arg[:3] == 'xmm' or arg[:3] == \"ymm\":\n        if \"/\" in arg:\n            r, m = arg.split('/')\n            if (m[0] != 'm'):\n                raise Exception(\"Expected /m: %s\", arg)\n            return XMMArg(arg[0], int(m[1:]));\n        else:\n            return XMMArg(arg[0], 0);\n    elif arg[:2] == 'mm':",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "split0",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "def split0(s):\n    if s == '':\n        return []\n    return s.split(',')\ndef main():\n    n = 0\n    if len(sys.argv) != 3:\n        print(\"Usage: test-avx.py x86.csv test-avx.h\")\n        exit(1)\n    csvfile = open(sys.argv[1], 'r', newline='')",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "def main():\n    n = 0\n    if len(sys.argv) != 3:\n        print(\"Usage: test-avx.py x86.csv test-avx.h\")\n        exit(1)\n    csvfile = open(sys.argv[1], 'r', newline='')\n    with open(sys.argv[2], \"w\") as outf:\n        outf.write(\"// Generated by test-avx.py. Do not edit.\\n\")\n        for row in csv.reader(strip_comments(csvfile)):\n            insn = row[0].replace(',', '').split()",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "archs",
        "kind": 5,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "archs = [\n    \"SSE\", \"SSE2\", \"SSE3\", \"SSSE3\", \"SSE4_1\", \"SSE4_2\",\n    \"AES\", \"AVX\", \"AVX2\", \"AES+AVX\", \"VAES+AVX\",\n    \"F16C\", \"FMA\", \"SHA\",\n]\nignore = set([\"FISTTP\",\n    \"LDMXCSR\", \"VLDMXCSR\", \"STMXCSR\", \"VSTMXCSR\"])\nimask = {\n    'vBLENDPD': 0xff,\n    'vBLENDPS': 0x0f,",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "ignore",
        "kind": 5,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "ignore = set([\"FISTTP\",\n    \"LDMXCSR\", \"VLDMXCSR\", \"STMXCSR\", \"VSTMXCSR\"])\nimask = {\n    'vBLENDPD': 0xff,\n    'vBLENDPS': 0x0f,\n    'CMP[PS][SD]': 0x07,\n    'VCMP[PS][SD]': 0x1f,\n    'vCVTPS2PH': 0x7,\n    'vDPPD': 0x33,\n    'vDPPS': 0xff,",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "imask",
        "kind": 5,
        "importPath": "qemu.tests.tcg.i386.test-avx",
        "description": "qemu.tests.tcg.i386.test-avx",
        "peekOfCode": "imask = {\n    'vBLENDPD': 0xff,\n    'vBLENDPS': 0x0f,\n    'CMP[PS][SD]': 0x07,\n    'VCMP[PS][SD]': 0x1f,\n    'vCVTPS2PH': 0x7,\n    'vDPPD': 0x33,\n    'vDPPS': 0xff,\n    'vEXTRACTPS': 0x03,\n    'vINSERTPS': 0xff,",
        "detail": "qemu.tests.tcg.i386.test-avx",
        "documentation": {}
    },
    {
        "label": "MMArg",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "class MMArg():\n    isxmm = True\n    def __init__(self, mw):\n        if mw not in [0, 32, 64]:\n            raise Exception(\"Bad /m width: %s\" % w)\n        self.mw = mw\n        self.ismem = mw != 0\n    def regstr(self, n):\n        if n < 0:\n            return mem_w(self.mw)",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "ArgImm8u",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "class ArgImm8u():\n    isxmm = False\n    ismem = False\n    def __init__(self, op):\n        for k, v in imask.items():\n            if match(op, k):\n                self.mask = imask[k];\n                return\n        raise Exception(\"Unknown immediate\")\n    def vals(self):",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "ArgRM",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "class ArgRM():\n    isxmm = False\n    def __init__(self, rw, mw):\n        if rw not in [8, 16, 32, 64]:\n            raise Exception(\"Bad r/w width: %s\" % w)\n        if mw not in [0, 8, 16, 32, 64]:\n            raise Exception(\"Bad r/w width: %s\" % w)\n        self.rw = rw\n        self.mw = mw\n        self.ismem = mw != 0",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "ArgMem",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "class ArgMem():\n    isxmm = False\n    ismem = True\n    def __init__(self, w):\n        if w not in [8, 16, 32, 64, 128, 256]:\n            raise Exception(\"Bad mem width: %s\" % w)\n        self.w = w\n    def regstr(self, n):\n        return mem_w(self.w)\nclass SkipInstruction(Exception):",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "SkipInstruction",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "class SkipInstruction(Exception):\n    pass\ndef ArgGenerator(arg, op):\n    if arg[:2] == 'mm':\n        if \"/\" in arg:\n            r, m = arg.split('/')\n            if (m[0] != 'm'):\n                raise Exception(\"Expected /m: %s\", arg)\n            return MMArg(int(m[1:]));\n        else:",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "InsnGenerator",
        "kind": 6,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "class InsnGenerator:\n    def __init__(self, op, args):\n        self.op = op\n        if op[0:2] == \"PF\":\n            self.optype = 'F32'\n        else:\n            self.optype = 'I'\n        try:\n            self.args = list(ArgGenerator(a, op) for a in args)\n            if len(self.args) > 0 and self.args[-1] is None:",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "strip_comments",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "def strip_comments(x):\n    for l in x:\n        if l != '' and l[0] != '#':\n            yield l\ndef reg_w(w):\n    if w == 8:\n        return 'al'\n    elif w == 16:\n        return 'ax'\n    elif w == 32:",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "reg_w",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "def reg_w(w):\n    if w == 8:\n        return 'al'\n    elif w == 16:\n        return 'ax'\n    elif w == 32:\n        return 'eax'\n    elif w == 64:\n        return 'rax'\n    raise Exception(\"bad reg_w %d\" % w)",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "mem_w",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "def mem_w(w):\n    if w == 8:\n        t = \"BYTE\"\n    elif w == 16:\n        t = \"WORD\"\n    elif w == 32:\n        t = \"DWORD\"\n    elif w == 64:\n        t = \"QWORD\"\n    else:",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "match",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "def match(op, pattern):\n    return fnmatch(op, pattern)\nclass ArgImm8u():\n    isxmm = False\n    ismem = False\n    def __init__(self, op):\n        for k, v in imask.items():\n            if match(op, k):\n                self.mask = imask[k];\n                return",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "ArgGenerator",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "def ArgGenerator(arg, op):\n    if arg[:2] == 'mm':\n        if \"/\" in arg:\n            r, m = arg.split('/')\n            if (m[0] != 'm'):\n                raise Exception(\"Expected /m: %s\", arg)\n            return MMArg(int(m[1:]));\n        else:\n            return MMArg(0);\n    elif arg[:4] == 'imm8':",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "split0",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "def split0(s):\n    if s == '':\n        return []\n    return s.split(',')\ndef main():\n    n = 0\n    if len(sys.argv) <= 3:\n        print(\"Usage: test-mmx.py x86.csv test-mmx.h CPUID...\")\n        exit(1)\n    csvfile = open(sys.argv[1], 'r', newline='')",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "def main():\n    n = 0\n    if len(sys.argv) <= 3:\n        print(\"Usage: test-mmx.py x86.csv test-mmx.h CPUID...\")\n        exit(1)\n    csvfile = open(sys.argv[1], 'r', newline='')\n    archs = sys.argv[3:]\n    with open(sys.argv[2], \"w\") as outf:\n        outf.write(\"// Generated by test-mmx.py. Do not edit.\\n\")\n        for row in csv.reader(strip_comments(csvfile)):",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "ignore",
        "kind": 5,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "ignore = set([\"EMMS\", \"FEMMS\", \"FISTTP\",\n    \"LDMXCSR\", \"VLDMXCSR\", \"STMXCSR\", \"VSTMXCSR\"])\nimask = {\n    'PALIGNR': 0x3f,\n    'PEXTRB': 0x0f,\n    'PEXTRW': 0x07,\n    'PEXTRD': 0x03,\n    'PEXTRQ': 0x01,\n    'PINSRB': 0x0f,\n    'PINSRW': 0x07,",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "imask",
        "kind": 5,
        "importPath": "qemu.tests.tcg.i386.test-mmx",
        "description": "qemu.tests.tcg.i386.test-mmx",
        "peekOfCode": "imask = {\n    'PALIGNR': 0x3f,\n    'PEXTRB': 0x0f,\n    'PEXTRW': 0x07,\n    'PEXTRD': 0x03,\n    'PEXTRQ': 0x01,\n    'PINSRB': 0x0f,\n    'PINSRW': 0x07,\n    'PINSRD': 0x03,\n    'PINSRQ': 0x01,",
        "detail": "qemu.tests.tcg.i386.test-mmx",
        "documentation": {}
    },
    {
        "label": "check_state",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.catch-syscalls",
        "description": "qemu.tests.tcg.multiarch.gdbstub.catch-syscalls",
        "peekOfCode": "def check_state(expected):\n    \"\"\"Check the catch_syscalls_state value\"\"\"\n    actual = gdb.parse_and_eval(\"catch_syscalls_state\").string()\n    report(actual == expected, \"{} == {}\".format(actual, expected))\ndef run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    gdb.Breakpoint(\"main\")\n    gdb.execute(\"continue\")\n    # Check that GDB stops for pipe2/read calls/returns, but not for write.\n    gdb.execute(\"delete\")",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.catch-syscalls",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.catch-syscalls",
        "description": "qemu.tests.tcg.multiarch.gdbstub.catch-syscalls",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    gdb.Breakpoint(\"main\")\n    gdb.execute(\"continue\")\n    # Check that GDB stops for pipe2/read calls/returns, but not for write.\n    gdb.execute(\"delete\")\n    try:\n        gdb.execute(\"catch syscall pipe2 read\")\n    except gdb.error as exc:\n        exc_str = str(exc)",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.catch-syscalls",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.follow-fork-mode-child",
        "description": "qemu.tests.tcg.multiarch.gdbstub.follow-fork-mode-child",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    gdb.execute(\"set follow-fork-mode child\")\n    # Check that the parent breakpoints are unset.\n    gdb.execute(\"break break_after_fork\")\n    # Check that the parent syscall catchpoints are unset.\n    # Skip this check on the architectures that don't have them.\n    have_fork_syscall = False\n    for fork_syscall in (\"fork\", \"clone\", \"clone2\", \"clone3\"):\n        try:",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.follow-fork-mode-child",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.follow-fork-mode-parent",
        "description": "qemu.tests.tcg.multiarch.gdbstub.follow-fork-mode-parent",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    gdb.execute(\"set follow-fork-mode parent\")\n    gdb.execute(\"continue\")\n    exitcode = int(gdb.parse_and_eval(\"$_exitcode\"))\n    report(exitcode == 0, \"{} == 0\".format(exitcode))\nmain(run_test)",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.follow-fork-mode-parent",
        "documentation": {}
    },
    {
        "label": "check_interrupt",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.interrupt",
        "description": "qemu.tests.tcg.multiarch.gdbstub.interrupt",
        "peekOfCode": "def check_interrupt(thread):\n    \"\"\"\n    Check that, if thread is resumed, we go back to the same thread when the\n    program gets interrupted.\n    \"\"\"\n    # Switch to the thread we're going to be running the test in.\n    print(\"thread \", thread.num)\n    gdb.execute(\"thr %d\" % thread.num)\n    # Enter the loop() function on this thread.\n    #",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.interrupt",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.interrupt",
        "description": "qemu.tests.tcg.multiarch.gdbstub.interrupt",
        "peekOfCode": "def run_test():\n    \"\"\"\n    Test if interrupting the code always lands us on the same thread when\n    running with scheduler-lock enabled.\n    \"\"\"\n    if len(gdb.selected_inferior().threads()) == 1:\n        print(\"SKIP: set to run on a single thread\")\n        gdb_exit(0)\n    gdb.execute(\"set scheduler-locking on\")\n    for thread in gdb.selected_inferior().threads():",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.interrupt",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.late-attach",
        "description": "qemu.tests.tcg.multiarch.gdbstub.late-attach",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    try:\n        phase = gdb.parse_and_eval(\"phase\").string()\n    except gdb.error:\n        # Assume the guest did not reach main().\n        phase = \"start\"\n    if phase == \"start\":\n        gdb.execute(\"break sigwait\")\n        gdb.execute(\"continue\")",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.late-attach",
        "documentation": {}
    },
    {
        "label": "check_step",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "description": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "peekOfCode": "def check_step():\n    \"Step an instruction, check it moved.\"\n    start_pc = gdb.parse_and_eval('$pc')\n    gdb.execute(\"si\")\n    end_pc = gdb.parse_and_eval('$pc')\n    return not (start_pc == end_pc)\n#\n# Currently it's hard to create a hbreak with the pure python API and\n# manually matching PC to symbol address is a bit flaky thanks to\n# function prologues. However internally QEMU's gdbstub treats them",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "documentation": {}
    },
    {
        "label": "check_break",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "description": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "peekOfCode": "def check_break(sym_name):\n    \"Setup breakpoint, continue and check we stopped.\"\n    sym, ok = gdb.lookup_symbol(sym_name)\n    bp = gdb.Breakpoint(sym_name, gdb.BP_BREAKPOINT)\n    gdb.execute(\"c\")\n    # hopefully we came back\n    end_pc = gdb.parse_and_eval('$pc')\n    report(bp.hit_count == 1,\n           \"break @ %s (%s %d hits)\" % (end_pc, sym.value(), bp.hit_count))\n    bp.delete()",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "documentation": {}
    },
    {
        "label": "do_one_watch",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "description": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "peekOfCode": "def do_one_watch(sym, wtype, text):\n    wp = gdb.Breakpoint(sym, gdb.BP_WATCHPOINT, wtype)\n    gdb.execute(\"c\")\n    report_str = \"%s for %s\" % (text, sym)\n    if wp.hit_count > 0:\n        report(True, report_str)\n        wp.delete()\n    else:\n        report(False, report_str)\ndef check_watches(sym_name):",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "documentation": {}
    },
    {
        "label": "check_watches",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "description": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "peekOfCode": "def check_watches(sym_name):\n    \"Watch a symbol for any access.\"\n    # Should hit for any read\n    do_one_watch(sym_name, gdb.WP_ACCESS, \"awatch\")\n    # Again should hit for reads\n    do_one_watch(sym_name, gdb.WP_READ, \"rwatch\")\n    # Finally when it is written\n    do_one_watch(sym_name, gdb.WP_WRITE, \"watch\")\ndef run_test():\n    \"Run through the tests one by one\"",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "description": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "peekOfCode": "def run_test():\n    \"Run through the tests one by one\"\n    print(\"Checking we can step the first few instructions\")\n    step_ok = 0\n    for i in range(3):\n        if check_step():\n            step_ok += 1\n    report(step_ok == 3, \"single step in boot code\")\n    # If we get here we have missed some of the other breakpoints.\n    print(\"Setup catch-all for _exit\")",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.memory",
        "documentation": {}
    },
    {
        "label": "probe_proc_self_mem",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.prot-none",
        "description": "qemu.tests.tcg.multiarch.gdbstub.prot-none",
        "peekOfCode": "def probe_proc_self_mem():\n    buf = ctypes.create_string_buffer(b'aaa')\n    try:\n        with open(\"/proc/self/mem\", \"rb\") as fp:\n            fp.seek(ctypes.addressof(buf))\n            return fp.read(3) == b'aaa'\n    except OSError:\n        return False\ndef run_test():\n    \"\"\"Run through the tests one by one\"\"\"",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.prot-none",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.prot-none",
        "description": "qemu.tests.tcg.multiarch.gdbstub.prot-none",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    if not probe_proc_self_mem():\n        print(\"SKIP: /proc/self/mem is not usable\")\n        gdb_exit(0)\n    gdb.Breakpoint(\"break_here\")\n    gdb.execute(\"continue\")\n    val = gdb.parse_and_eval(\"*(char[2] *)q\").string()\n    report(val == \"42\", \"{} == 42\".format(val))\n    gdb.execute(\"set *(char[3] *)q = \\\"24\\\"\")",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.prot-none",
        "documentation": {}
    },
    {
        "label": "fetch_xml_regmap",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "description": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "peekOfCode": "def fetch_xml_regmap():\n    \"\"\"\n    Iterate through the XML descriptions and validate.\n    We check for any duplicate registers and report them. Return a\n    reg_map hash containing the names, regnums and initial values of\n    all registers.\n    \"\"\"\n    # First check the XML descriptions we have sent. Most arches\n    # support XML but a few of the ancient ones don't in which case we\n    # need to gracefully fail.",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "documentation": {}
    },
    {
        "label": "get_register_by_regnum",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "description": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "peekOfCode": "def get_register_by_regnum(reg_map, regnum):\n    \"\"\"\n    Helper to find a register from the map via its XML regnum\n    \"\"\"\n    for regname, entry in reg_map.items():\n        if entry['regnum'] == regnum:\n            return entry\n    return None\ndef crosscheck_remote_xml(reg_map):\n    \"\"\"",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "documentation": {}
    },
    {
        "label": "crosscheck_remote_xml",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "description": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "peekOfCode": "def crosscheck_remote_xml(reg_map):\n    \"\"\"\n    Cross-check the list of remote-registers with the XML info.\n    \"\"\"\n    remote = gdb.execute(\"maint print remote-registers\", False, True)\n    r_regs = remote.split(\"\\n\")\n    total_regs = len(reg_map.keys())\n    total_r_regs = 0\n    total_r_elided_regs = 0\n    for r in r_regs:",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "documentation": {}
    },
    {
        "label": "initial_register_read",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "description": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "peekOfCode": "def initial_register_read(reg_map):\n    \"\"\"\n    Do an initial read of all registers that we know gdb cares about\n    (so ignore the elided ones).\n    \"\"\"\n    frame = gdb.selected_frame()\n    for e in reg_map.values():\n        name = e[\"name\"]\n        regnum = e[\"regnum\"]\n        try:",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "documentation": {}
    },
    {
        "label": "complete_and_diff",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "description": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "peekOfCode": "def complete_and_diff(reg_map):\n    \"\"\"\n    Let the program run to (almost) completion and then iterate\n    through all the registers we know about and report which ones have\n    changed.\n    \"\"\"\n    # Let the program get to the end and we can check what changed\n    b = gdb.Breakpoint(\"_exit\")\n    if b.pending: # workaround Microblaze weirdness\n        b.delete()",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "description": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "peekOfCode": "def run_test():\n    \"Run through the tests\"\n    reg_map = fetch_xml_regmap()\n    if reg_map is not None:\n        crosscheck_remote_xml(reg_map)\n        initial_register_read(reg_map)\n        complete_and_diff(reg_map)\nmain(run_test)",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "documentation": {}
    },
    {
        "label": "initial_vlen",
        "kind": 5,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "description": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "peekOfCode": "initial_vlen = 0\ndef fetch_xml_regmap():\n    \"\"\"\n    Iterate through the XML descriptions and validate.\n    We check for any duplicate registers and report them. Return a\n    reg_map hash containing the names, regnums and initial values of\n    all registers.\n    \"\"\"\n    # First check the XML descriptions we have sent. Most arches\n    # support XML but a few of the ancient ones don't in which case we",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.registers",
        "documentation": {}
    },
    {
        "label": "check_break",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "description": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "peekOfCode": "def check_break(sym_name):\n    \"Setup breakpoint, continue and check we stopped.\"\n    sym, ok = gdb.lookup_symbol(sym_name)\n    bp = gdb.Breakpoint(sym_name)\n    gdb.execute(\"c\")\n    # hopefully we came back\n    end_pc = gdb.parse_and_eval('$pc')\n    report(bp.hit_count == 1,\n           \"break @ %s (%s %d hits)\" % (end_pc, sym.value(), bp.hit_count))\n    bp.delete()",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "description": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "peekOfCode": "def run_test():\n    \"Run through the tests one by one\"\n    check_break(\"SHA1Init\")\n    # Check step and inspect values. We do a double next after the\n    # breakpoint as depending on the version of gdb we may step the\n    # preamble and not the first actual line of source.\n    gdb.execute(\"next\")\n    gdb.execute(\"next\")\n    val_ctx = gdb.parse_and_eval(\"context->state[0]\")\n    exp_ctx = 0x67452301",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "documentation": {}
    },
    {
        "label": "initial_vlen",
        "kind": 5,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "description": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "peekOfCode": "initial_vlen = 0\ndef check_break(sym_name):\n    \"Setup breakpoint, continue and check we stopped.\"\n    sym, ok = gdb.lookup_symbol(sym_name)\n    bp = gdb.Breakpoint(sym_name)\n    gdb.execute(\"c\")\n    # hopefully we came back\n    end_pc = gdb.parse_and_eval('$pc')\n    report(bp.hit_count == 1,\n           \"break @ %s (%s %d hits)\" % (end_pc, sym.value(), bp.hit_count))",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.sha1",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.test-proc-mappings",
        "description": "qemu.tests.tcg.multiarch.gdbstub.test-proc-mappings",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    if gdb.selected_inferior().architecture().name() == \"m68k\":\n        # m68k GDB supports only GDB_OSABI_SVR4, but GDB_OSABI_LINUX is\n        # required for the info proc support (see set_gdbarch_info_proc()).\n        print(\"SKIP: m68k GDB does not support GDB_OSABI_LINUX\")\n        gdb_exit(0)\n    mappings = gdb.execute(\"info proc mappings\", False, True)\n    report(isinstance(mappings, str), \"Fetched the mappings from the inferior\")\n    # Broken with host page size > guest page size",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.test-proc-mappings",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.test-qxfer-auxv-read",
        "description": "qemu.tests.tcg.multiarch.gdbstub.test-qxfer-auxv-read",
        "peekOfCode": "def run_test():\n    \"Run through the tests one by one\"\n    auxv = gdb.execute(\"info auxv\", False, True)\n    report(isinstance(auxv, str), \"Fetched auxv from inferior\")\n    report(auxv.find(\"sha1\"), \"Found test binary name in auxv\")\nmain(run_test)",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.test-qxfer-auxv-read",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.test-qxfer-siginfo-read",
        "description": "qemu.tests.tcg.multiarch.gdbstub.test-qxfer-siginfo-read",
        "peekOfCode": "def run_test():\n    \"Run through the test\"\n    gdb.execute(\"continue\", False, True)\n    resp = gdb.execute(\"print/x $_siginfo\", False, True)\n    report(resp.find(\"si_addr = 0xdeadbeef\"), \"Found fault address.\")\nmain(run_test)",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.test-qxfer-siginfo-read",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.gdbstub.test-thread-breakpoint",
        "description": "qemu.tests.tcg.multiarch.gdbstub.test-thread-breakpoint",
        "peekOfCode": "def run_test():\n    \"Run through the tests one by one\"\n    sym, ok = gdb.lookup_symbol(\"thread1_func\")\n    gdb.execute(\"b thread1_func\")\n    gdb.execute(\"c\")\n    frame = gdb.selected_frame()\n    report(str(frame.function()) == \"thread1_func\", \"break @ %s\"%frame)\nmain(run_test)",
        "detail": "qemu.tests.tcg.multiarch.gdbstub.test-thread-breakpoint",
        "documentation": {}
    },
    {
        "label": "extract_counts",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "description": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "peekOfCode": "def extract_counts(path):\n    \"\"\"\n    Load the output from path and extract the lines containing:\n      Test data start: 0x40214000\n      Test data end: 0x40218001\n      Test data read: 2522280\n      Test data write: 262111\n    From the stream of data. Extract the values for use in the\n    validation function.\n    \"\"\"",
        "detail": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "documentation": {}
    },
    {
        "label": "parse_plugin_output",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "description": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "peekOfCode": "def parse_plugin_output(path, start, end):\n    \"\"\"\n    Load the plugin output from path in the form of:\n      Region Base, Reads, Writes, Seen all\n      0x0000000040004000, 31093, 0, false\n      0x0000000040214000, 2522280, 278579, true\n      0x0000000040000000, 137398, 0, false\n      0x0000000040210000, 54727397, 33721956, false\n    And extract the ranges that match test data start and end and\n    return the results.",
        "detail": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "description": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "peekOfCode": "def main() -> None:\n    \"\"\"\n    Process the arguments, injest the program and plugin out and\n    verify they match up and report if they do not.\n    \"\"\"\n    parser = ArgumentParser(description=\"Validate memory instrumentation\")\n    parser.add_argument('test_output',\n                        help=\"The output from the test itself\")\n    parser.add_argument('plugin_output',\n                        help=\"The output from memory plugin\")",
        "detail": "qemu.tests.tcg.multiarch.system.validate-memory-counts",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.s390x.gdbstub.test-signals-s390x",
        "description": "qemu.tests.tcg.s390x.gdbstub.test-signals-s390x",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    illegal_op = gdb.Breakpoint(\"illegal_op\")\n    stg = gdb.Breakpoint(\"stg\")\n    mvc_8 = gdb.Breakpoint(\"mvc_8\")\n    # Expect the following events:\n    # 1x illegal_op breakpoint\n    # 2x stg breakpoint, segv, breakpoint\n    # 2x mvc_8 breakpoint, segv, breakpoint\n    for _ in range(14):",
        "detail": "qemu.tests.tcg.s390x.gdbstub.test-signals-s390x",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "qemu.tests.tcg.s390x.gdbstub.test-svc",
        "description": "qemu.tests.tcg.s390x.gdbstub.test-svc",
        "peekOfCode": "def run_test():\n    \"\"\"Run through the tests one by one\"\"\"\n    report(\"lghi\\t\" in gdb.execute(\"x/i $pc\", False, True), \"insn #1\")\n    gdb.execute(\"si\")\n    report(\"larl\\t\" in gdb.execute(\"x/i $pc\", False, True), \"insn #2\")\n    gdb.execute(\"si\")\n    report(\"lgrl\\t\" in gdb.execute(\"x/i $pc\", False, True), \"insn #3\")\n    gdb.execute(\"si\")\n    report(\"svc\\t\" in gdb.execute(\"x/i $pc\", False, True), \"insn #4\")\n    gdb.execute(\"si\")",
        "detail": "qemu.tests.tcg.s390x.gdbstub.test-svc",
        "documentation": {}
    },
    {
        "label": "get_config_defaults",
        "kind": 2,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "def get_config_defaults(vmcls, default_config):\n    \"\"\"Fetch the configuration defaults for this VM,\n       taking into consideration the defaults for\n       aarch64 first, followed by the defaults for this VM.\"\"\"\n    config = default_config\n    config.update(aarch_get_config_defaults(vmcls))\n    return config\ndef aarch_get_config_defaults(vmcls):\n    \"\"\"Set the defaults for current version of QEMU.\"\"\"\n    config = CURRENT_CONFIG",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "aarch_get_config_defaults",
        "kind": 2,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "def aarch_get_config_defaults(vmcls):\n    \"\"\"Set the defaults for current version of QEMU.\"\"\"\n    config = CURRENT_CONFIG\n    args = basevm.parse_args(vmcls)\n    qemu_path = basevm.get_qemu_path(vmcls.arch, args.build_path)\n    qemu_version = basevm.get_qemu_version(qemu_path)\n    if qemu_version < QEMU_AARCH64_MIN_VERSION:\n        error = \"\\nThis major version of QEMU {} is to old for aarch64 VMs.\\n\"\\\n                \"The major version must be at least {}.\\n\"\\\n                \"To continue with the current build of QEMU, \"\\",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "create_flash_images",
        "kind": 2,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "def create_flash_images(flash_dir=\"./\", efi_img=\"\"):\n    \"\"\"Creates the appropriate pflash files\n       for an aarch64 VM.\"\"\"\n    flash0_path = get_flash_path(flash_dir, \"flash0\")\n    flash1_path = get_flash_path(flash_dir, \"flash1\")\n    fd_null = open(os.devnull, 'w')\n    subprocess.check_call([\"dd\", \"if=/dev/zero\", \"of={}\".format(flash0_path),\n                           \"bs=1M\", \"count=64\"],\n                           stdout=fd_null, stderr=subprocess.STDOUT)\n    # A reliable way to get the QEMU EFI image is via an installed package or",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "get_pflash_args",
        "kind": 2,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "def get_pflash_args(flash_dir=\"./\"):\n    \"\"\"Returns a string that can be used to\n       boot qemu using the appropriate pflash files\n       for aarch64.\"\"\"\n    flash0_path = get_flash_path(flash_dir, \"flash0\")\n    flash1_path = get_flash_path(flash_dir, \"flash1\")\n    pflash_args_str = \"-drive file={},format=raw,if=pflash \"\\\n                      \"-drive file={},format=raw,if=pflash\"\n    pflash_args = pflash_args_str.format(flash0_path, flash1_path)\n    return pflash_args.split(\" \")",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "get_flash_path",
        "kind": 2,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "def get_flash_path(flash_dir, name):\n    return os.path.join(flash_dir, \"{}.img\".format(name))",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "CURRENT_CONFIG",
        "kind": 5,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "CURRENT_CONFIG = {\n    'cpu'          : \"max\",\n    'machine'      : \"virt,gic-version=max\",\n}\n# The minimum minor version of QEMU we will support with aarch64 VMs is 3.\n# QEMU versions less than 3 have various issues running these VMs.\nQEMU_AARCH64_MIN_VERSION = 3\n# The DEFAULT_CONFIG will default to a version of\n# parameters that works for backwards compatibility.\nDEFAULT_CONFIG = {'kvm' : {'cpu'          : \"host\",",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "QEMU_AARCH64_MIN_VERSION",
        "kind": 5,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "QEMU_AARCH64_MIN_VERSION = 3\n# The DEFAULT_CONFIG will default to a version of\n# parameters that works for backwards compatibility.\nDEFAULT_CONFIG = {'kvm' : {'cpu'          : \"host\",\n                           'machine'      : \"virt,gic-version=host\"},\n                  'tcg' : {'cpu'          : \"cortex-a57\",\n                           'machine'      : \"virt\"},\n}\ndef get_config_defaults(vmcls, default_config):\n    \"\"\"Fetch the configuration defaults for this VM,",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "kind": 5,
        "importPath": "qemu.tests.vm.aarch64vm",
        "description": "qemu.tests.vm.aarch64vm",
        "peekOfCode": "DEFAULT_CONFIG = {'kvm' : {'cpu'          : \"host\",\n                           'machine'      : \"virt,gic-version=host\"},\n                  'tcg' : {'cpu'          : \"cortex-a57\",\n                           'machine'      : \"virt\"},\n}\ndef get_config_defaults(vmcls, default_config):\n    \"\"\"Fetch the configuration defaults for this VM,\n       taking into consideration the defaults for\n       aarch64 first, followed by the defaults for this VM.\"\"\"\n    config = default_config",
        "detail": "qemu.tests.vm.aarch64vm",
        "documentation": {}
    },
    {
        "label": "BaseVM",
        "kind": 6,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "class BaseVM(object):\n    envvars = [\n        \"https_proxy\",\n        \"http_proxy\",\n        \"ftp_proxy\",\n        \"no_proxy\",\n    ]\n    # The script to run in the guest that builds QEMU\n    BUILD_SCRIPT = \"\"\n    # The guest name, to be overridden by subclasses",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "get_qemu_path",
        "kind": 2,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "def get_qemu_path(arch, build_path=None):\n    \"\"\"Fetch the path to the qemu binary.\"\"\"\n    # If QEMU environment variable set, it takes precedence\n    if \"QEMU\" in os.environ:\n        qemu_path = os.environ[\"QEMU\"]\n    elif build_path:\n        qemu_path = os.path.join(build_path, \"qemu-system-\" + arch)\n    else:\n        # Default is to use system path for qemu.\n        qemu_path = \"qemu-system-\" + arch",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "get_qemu_version",
        "kind": 2,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "def get_qemu_version(qemu_path):\n    \"\"\"Get the version number from the current QEMU,\n       and return the major number.\"\"\"\n    output = subprocess.check_output([qemu_path, '--version'])\n    version_line = output.decode(\"utf-8\")\n    version_num = re.split(r' |\\(', version_line)[3].split('.')[0]\n    return int(version_num)\ndef parse_config(config, args):\n    \"\"\" Parse yaml config and populate our config structure.\n        The yaml config allows the user to override the",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "parse_config",
        "kind": 2,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "def parse_config(config, args):\n    \"\"\" Parse yaml config and populate our config structure.\n        The yaml config allows the user to override the\n        defaults for VM parameters.  In many cases these\n        defaults can be overridden without rebuilding the VM.\"\"\"\n    if args.config:\n        config_file = args.config\n    elif 'QEMU_CONFIG' in os.environ:\n        config_file = os.environ['QEMU_CONFIG']\n    else:",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "def parse_args(vmcls):\n    def get_default_jobs():\n        if multiprocessing.cpu_count() > 1:\n            if kvm_available(vmcls.arch):\n                return multiprocessing.cpu_count() // 2\n            elif os.uname().machine == \"x86_64\" and \\\n                 vmcls.arch in [\"aarch64\", \"x86_64\", \"i386\"]:\n                # MTTCG is available on these arches and we can allow\n                # more cores. but only up to a reasonable limit. User\n                # can always override these limits with --jobs.",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "def main(vmcls, config=None):\n    try:\n        if config == None:\n            config = DEFAULT_CONFIG\n        args = parse_args(vmcls)\n        if not args.commands and not args.build_qemu and not args.build_image:\n            print(\"Nothing to do?\")\n            return 1\n        config = parse_config(config, args)\n        logging.basicConfig(level=(logging.DEBUG if args.debug",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "SSH_KEY_FILE",
        "kind": 5,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "SSH_KEY_FILE = os.path.join(os.path.dirname(__file__),\n               \"..\", \"keys\", \"id_rsa\")\nSSH_PUB_KEY_FILE = os.path.join(os.path.dirname(__file__),\n                   \"..\", \"keys\", \"id_rsa.pub\")\n# This is the standard configuration.\n# Any or all of these can be overridden by\n# passing in a config argument to the VM constructor.\nDEFAULT_CONFIG = {\n    'cpu'             : \"max\",\n    'machine'         : 'pc',",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "SSH_PUB_KEY_FILE",
        "kind": 5,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "SSH_PUB_KEY_FILE = os.path.join(os.path.dirname(__file__),\n                   \"..\", \"keys\", \"id_rsa.pub\")\n# This is the standard configuration.\n# Any or all of these can be overridden by\n# passing in a config argument to the VM constructor.\nDEFAULT_CONFIG = {\n    'cpu'             : \"max\",\n    'machine'         : 'pc',\n    'guest_user'      : \"qemu\",\n    'guest_pass'      : \"qemupass\",",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "kind": 5,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "DEFAULT_CONFIG = {\n    'cpu'             : \"max\",\n    'machine'         : 'pc',\n    'guest_user'      : \"qemu\",\n    'guest_pass'      : \"qemupass\",\n    'root_user'       : \"root\",\n    'root_pass'       : \"qemupass\",\n    'ssh_key_file'    : SSH_KEY_FILE,\n    'ssh_pub_key_file': SSH_PUB_KEY_FILE,\n    'memory'          : \"4G\",",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "BOOT_DEVICE",
        "kind": 5,
        "importPath": "qemu.tests.vm.basevm",
        "description": "qemu.tests.vm.basevm",
        "peekOfCode": "BOOT_DEVICE = {\n    'block' :  \"-drive file={},if=none,id=drive0,cache=writeback \"\\\n               \"-device virtio-blk,drive=drive0,bootindex=0\",\n    'scsi'  :  \"-device virtio-scsi-device,id=scsi \"\\\n               \"-drive file={},format=raw,if=none,id=hd0 \"\\\n               \"-device scsi-hd,drive=hd0,bootindex=0\",\n}\nclass BaseVM(object):\n    envvars = [\n        \"https_proxy\",",
        "detail": "qemu.tests.vm.basevm",
        "documentation": {}
    },
    {
        "label": "UbuntuVM",
        "kind": 6,
        "importPath": "qemu.tests.vm.ubuntuvm",
        "description": "qemu.tests.vm.ubuntuvm",
        "peekOfCode": "class UbuntuVM(basevm.BaseVM):\n    def __init__(self, args, config=None):\n        self.login_prompt = \"ubuntu-{}-guest login:\".format(self.arch)\n        basevm.BaseVM.__init__(self, args, config)\n    def build_image(self, img):\n        \"\"\"Build an Ubuntu VM image.  The child class will\n           define the install_cmds to init the VM.\"\"\"\n        os_img = self._download_with_cache(self.image_link,\n                                           sha256sum=self.image_sha256)\n        img_tmp = img + \".tmp\"",
        "detail": "qemu.tests.vm.ubuntuvm",
        "documentation": {}
    }
]